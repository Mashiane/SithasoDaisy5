class SVGRenderer extends HTMLElement {
  constructor() {
    super();
    this.eventListeners = new Map();
    this.attachShadow({ mode: "open" }); // keep internal <svg>
  }

  static get observedAttributes() {
    return ["data-src", "width", "height", "fill", "background", "data-js", "style", "replace", "class"];
  }

  async connectedCallback() {
    await this.loadSVG();
  }

  async attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;

    if (name === "data-src") {
      await this.loadSVG(); // redraw
    } else if (name === "data-js") {
      this.updateEventHandling();
    } else {
      if (this.svgContent) this.applyStyles(this.svgContent);
    }
  }

  async loadSVG() {
    const src = this.getAttribute("data-src");
    this.svgContent = null;
    this.eventListeners.clear();

    if (!src) return;

    try {
      let svgText = localStorage.getItem(src);

      if (!svgText) {
        const res = await fetch(src);
        if (!res.ok) throw new Error("Failed to fetch SVG");
        svgText = await res.text();
        localStorage.setItem(src, svgText);
      }

      const tmp = document.createElement("div");
      tmp.innerHTML = svgText.trim();
      const svgEl = tmp.querySelector("svg");
      if (!svgEl) throw new Error("Invalid SVG content");

      // copy attributes (except data-src)
      Array.from(this.attributes).forEach((attr) => {
        if (attr.name !== "data-src") svgEl.setAttribute(attr.name, attr.value);
      });

      this.applyStyles(svgEl);

      // --- NEW: don't replace self, update shadow DOM instead ---
      if (this.shadowRoot) {
        this.shadowRoot.innerHTML = ""; // clear old
        this.shadowRoot.appendChild(svgEl);
      } else {
        this.innerHTML = "";
        this.appendChild(svgEl);
      }

      this.svgContent = svgEl;

      if (this.getAttribute("data-js") === "enabled") {
        this.updateEventHandling();
      }
    } catch (err) {
      console.error("Error loading SVG:", err);
      const errBox = document.createElement("div");
      errBox.style.color = "red";
      errBox.textContent = "Failed to load SVG";
      if (this.shadowRoot) {
        this.shadowRoot.innerHTML = "";
        this.shadowRoot.appendChild(errBox);
      } else {
        this.innerHTML = "";
        this.appendChild(errBox);
      }
    }
  }

  applyStyles(target) {
    const width = this.getAttribute("width"),
      height = this.getAttribute("height"),
      fill = this.getAttribute("fill"),
      background = this.getAttribute("background"),
      styleAttr = this.getAttribute("style"),
      fit = this.getAttribute("fit"),
      classAttr = this.getAttribute("class");

    if (width) target.setAttribute("width", width);
    if (height) target.setAttribute("height", height);
    if (background) target.style.background = background;
    if (classAttr) target.setAttribute("class", classAttr);

    target.setAttribute("preserveAspectRatio", "xMidYMid meet");

    if (fill) {
      target.style.fill = fill;
      target.style.color = fill;
      target.querySelectorAll("[fill]").forEach((el) => el.setAttribute("fill", fill));
    }

    if (styleAttr) {
      target.style.cssText += ";" + styleAttr;
      const colorMatch = styleAttr.match(/color\s*:\s*([^;]+);?/i);
      if (colorMatch) {
        const styleColor = colorMatch[1].trim();
        target.style.fill = styleColor;
        target.style.color = styleColor;
        target.querySelectorAll("[fill]").forEach((el) => el.setAttribute("fill", styleColor));
      }
    }

        // âœ… Auto-fit mode
    if (fit === "true") {
      target.removeAttribute("width");
      target.removeAttribute("height");
      target.setAttribute("width", "100%");
      target.setAttribute("height", "100%");
      //
      if (target.hasAttribute("style")) {
        let cleanedStyle = target.getAttribute("style")
          .replace(/width\s*:\s*[^;]+;?/gi, "")
          .replace(/height\s*:\s*[^;]+;?/gi, "")
          .trim();
        if (cleanedStyle) {
          target.setAttribute("style", cleanedStyle);
        } else {
          target.removeAttribute("style");
        }
      }
    }
  }

  updateEventHandling() {
    if (!this.svgContent) return;

    this.eventListeners.forEach((handler, event) => {
      this.svgContent.removeEventListener(event, handler);
    });
    this.eventListeners.clear();

    const isEnabled = this.getAttribute("data-js") === "enabled";
    if (isEnabled) {
      const events = ["click", "mouseover", "mouseout", "mousedown", "mouseup"];
      events.forEach((event) => {
        const handler = (e) => {
          const customEvent = new CustomEvent(`svg-${event}`, {
            detail: { originalEvent: e, svgElement: this.svgContent },
            bubbles: true,
          });
          this.dispatchEvent(customEvent);
        };
        this.svgContent.addEventListener(event, handler);
        this.eventListeners.set(event, handler);
      });
      this.svgContent.style.cursor = "pointer";
    } else {
      this.svgContent.style.cursor = "default";
      this.svgContent.style.pointerEvents = "none";
    }
  }
}

customElements.define("svg-renderer", SVGRenderer);
