!(function (f) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = f();
  else if ("function" == typeof define && define.amd) define([], f);
  else {
    var g;
    (g =
      "undefined" != typeof window
        ? window
        : "undefined" != typeof global
        ? global
        : "undefined" != typeof self
        ? self
        : this).shp = f();
  }
})(function () {
  var define, module, exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = "function" == typeof require && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw ((f.code = "MODULE_NOT_FOUND"), f);
        }
        var l = (n[o] = { exports: {} });
        t[o][0].call(
          l.exports,
          function (e) {
            var n = t[o][1][e];
            return s(n || e);
          },
          l,
          l.exports,
          e,
          t,
          n,
          r
        );
      }
      return n[o].exports;
    }
    for (
      var i = "function" == typeof require && require, o = 0;
      o < r.length;
      o++
    )
      s(r[o]);
    return s;
  })(
    {
      1: [
        function (require, module, exports) {
          "use strict";
          var Promise = require("lie");
          function binaryAjax(url) {
            return new Promise(function (resolve, reject) {
              var type = url.slice(-3),
                ajax = new XMLHttpRequest();
              ajax.open("GET", url, !0),
                "prj" !== type && (ajax.responseType = "arraybuffer"),
                ajax.addEventListener(
                  "load",
                  function () {
                    if (ajax.status > 399)
                      return "prj" === type
                        ? resolve(!1)
                        : reject(new Error(ajax.status));
                    resolve(ajax.response);
                  },
                  !1
                ),
                ajax.send();
            });
          }
          module.exports = binaryAjax;
        },
        { lie: 51 },
      ],
      2: [
        function (require, module, exports) {
          "use strict";
          function isClockWise(array) {
            for (var sum = 0, i = 1, len = array.length, prev, cur; i < len; )
              (prev = cur || array[0]),
                (sum += ((cur = array[i])[0] - prev[0]) * (cur[1] + prev[1])),
                i++;
            return sum > 0;
          }
          function polyReduce(a, b) {
            return (
              isClockWise(b) || !a.length
                ? a.push([b])
                : a[a.length - 1].push(b),
              a
            );
          }
          (ParseShp.prototype.parsePoint = function (data) {
            return { type: "Point", coordinates: this.parseCoord(data, 0) };
          }),
            (ParseShp.prototype.parseZPoint = function (data) {
              var pointXY = this.parsePoint(data);
              return (
                pointXY.coordinates.push(this.parseCoord(data, 16)), pointXY
              );
            }),
            (ParseShp.prototype.parsePointArray = function (data, offset, num) {
              for (var out = [], done = 0; done < num; )
                out.push(this.parseCoord(data, offset)), (offset += 16), done++;
              return out;
            }),
            (ParseShp.prototype.parseZPointArray = function (
              data,
              zOffset,
              num,
              coordinates
            ) {
              for (var i = 0; i < num; )
                coordinates[i].push(data.getFloat64(zOffset, !0)),
                  i++,
                  (zOffset += 8);
              return coordinates;
            }),
            (ParseShp.prototype.parseArrayGroup = function (
              data,
              offset,
              partOffset,
              num,
              tot
            ) {
              for (
                var out = [], done = 0, curNum, nextNum = 0, pointNumber;
                done < num;

              )
                (partOffset += 4),
                  (curNum = nextNum),
                  (pointNumber =
                    (nextNum =
                      ++done === num ? tot : data.getInt32(partOffset, !0)) -
                    curNum) &&
                    (out.push(this.parsePointArray(data, offset, pointNumber)),
                    (offset += pointNumber << 4));
              return out;
            }),
            (ParseShp.prototype.parseZArrayGroup = function (
              data,
              zOffset,
              num,
              coordinates
            ) {
              for (var i = 0; i < num; )
                (coordinates[i] = this.parseZPointArray(
                  data,
                  zOffset,
                  coordinates[i].length,
                  coordinates[i]
                )),
                  (zOffset += coordinates[i].length << 3),
                  i++;
              return coordinates;
            }),
            (ParseShp.prototype.parseMultiPoint = function (data) {
              var out = {},
                mins = this.parseCoord(data, 0),
                maxs = this.parseCoord(data, 16);
              out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];
              var num = data.getInt32(32, !0),
                offset = 36;
              return (
                1 === num
                  ? ((out.type = "Point"),
                    (out.coordinates = this.parseCoord(data, 36)))
                  : ((out.type = "MultiPoint"),
                    (out.coordinates = this.parsePointArray(data, 36, num))),
                out
              );
            }),
            (ParseShp.prototype.parseZMultiPoint = function (data) {
              var geoJson = this.parseMultiPoint(data),
                num;
              if ("Point" === geoJson.type)
                return (
                  geoJson.coordinates.push(data.getFloat64(72, !0)), geoJson
                );
              var zOffset = 56 + ((num = geoJson.coordinates.length) << 4);
              return (
                (geoJson.coordinates = this.parseZPointArray(
                  data,
                  zOffset,
                  num,
                  geoJson.coordinates
                )),
                geoJson
              );
            }),
            (ParseShp.prototype.parsePolyline = function (data) {
              var out = {},
                mins = this.parseCoord(data, 0),
                maxs = this.parseCoord(data, 16);
              out.bbox = [mins[0], mins[1], maxs[0], maxs[1]];
              var numParts = data.getInt32(32, !0),
                num = data.getInt32(36, !0),
                offset,
                partOffset;
              return (
                1 === numParts
                  ? ((out.type = "LineString"),
                    (offset = 44),
                    (out.coordinates = this.parsePointArray(data, offset, num)))
                  : ((out.type = "MultiLineString"),
                    (offset = 40 + (numParts << 2)),
                    (partOffset = 40),
                    (out.coordinates = this.parseArrayGroup(
                      data,
                      offset,
                      40,
                      numParts,
                      num
                    ))),
                out
              );
            }),
            (ParseShp.prototype.parseZPolyline = function (data) {
              var geoJson = this.parsePolyline(data),
                num = geoJson.coordinates.length,
                zOffset = 60 + (num << 4);
              return "LineString" === geoJson.type
                ? ((geoJson.coordinates = this.parseZPointArray(
                    data,
                    zOffset,
                    num,
                    geoJson.coordinates
                  )),
                  geoJson)
                : ((geoJson.coordinates = this.parseZArrayGroup(
                    data,
                    zOffset,
                    num,
                    geoJson.coordinates
                  )),
                  geoJson);
            }),
            (ParseShp.prototype.polyFuncs = function (out) {
              return "LineString" === out.type
                ? ((out.type = "Polygon"),
                  (out.coordinates = [out.coordinates]),
                  out)
                : ((out.coordinates = out.coordinates.reduce(polyReduce, [])),
                  1 === out.coordinates.length
                    ? ((out.type = "Polygon"),
                      (out.coordinates = out.coordinates[0]),
                      out)
                    : ((out.type = "MultiPolygon"), out));
            }),
            (ParseShp.prototype.parsePolygon = function (data) {
              return this.polyFuncs(this.parsePolyline(data));
            }),
            (ParseShp.prototype.parseZPolygon = function (data) {
              return this.polyFuncs(this.parseZPolyline(data));
            });
          var shpFuncObj = {
            1: "parsePoint",
            3: "parsePolyline",
            5: "parsePolygon",
            8: "parseMultiPoint",
            11: "parseZPoint",
            13: "parseZPolyline",
            15: "parseZPolygon",
            18: "parseZMultiPoint",
          };
          function makeParseCoord(trans) {
            return trans
              ? function (data, offset) {
                  return trans.inverse([
                    data.getFloat64(offset, !0),
                    data.getFloat64(offset + 8, !0),
                  ]);
                }
              : function (data, offset) {
                  return [
                    data.getFloat64(offset, !0),
                    data.getFloat64(offset + 8, !0),
                  ];
                };
          }
          function ParseShp(buffer, trans) {
            if (!(this instanceof ParseShp)) return new ParseShp(buffer, trans);
            (this.buffer = buffer),
              this.shpFuncs(trans),
              (this.rows = this.getRows());
          }
          (ParseShp.prototype.shpFuncs = function (tran) {
            var num = this.getShpCode();
            if ((num > 20 && (num -= 20), !(num in shpFuncObj)))
              throw new Error("I don't know that shp type");
            (this.parseFunc = this[shpFuncObj[num]]),
              (this.parseCoord = makeParseCoord(tran));
          }),
            (ParseShp.prototype.getShpCode = function () {
              return this.parseHeader().shpCode;
            }),
            (ParseShp.prototype.parseHeader = function () {
              var view = new DataView(this.buffer, 0, 100);
              return {
                length: view.getInt32(24, !1),
                version: view.getInt32(28, !0),
                shpCode: view.getInt32(32, !0),
                bbox: [
                  view.getFloat64(36, !0),
                  view.getFloat64(44, !0),
                  view.getFloat64(52, !0),
                  view.getFloat64(52, !0),
                ],
              };
            }),
            (ParseShp.prototype.getRows = function () {
              for (
                var offset = 100,
                  len = this.buffer.byteLength,
                  out = [],
                  current;
                offset < len;

              )
                (current = this.getRow(offset)),
                  (offset += 8),
                  (offset += current.len),
                  current.type && out.push(this.parseFunc(current.data));
              return out;
            }),
            (ParseShp.prototype.getRow = function (offset) {
              var view = new DataView(this.buffer, offset, 12),
                len = view.getInt32(4, !1) << 1,
                data = new DataView(this.buffer, offset + 12, len - 4);
              return {
                id: view.getInt32(0, !1),
                len: len,
                data: data,
                type: view.getInt32(8, !0),
              };
            }),
            (module.exports = function (buffer, trans) {
              return new ParseShp(buffer, trans).rows;
            });
        },
        {},
      ],
      3: [
        function (require, module, exports) {
          "use strict";
          function toArrayBuffer(buffer) {
            for (
              var arrayBuffer = new ArrayBuffer(buffer.length),
                view = new Uint8Array(arrayBuffer),
                i = -1,
                len = buffer.length;
              ++i < len;

            )
              view[i] = buffer[i];
            return arrayBuffer;
          }
          module.exports = toArrayBuffer;
        },
        {},
      ],
      4: [
        function (require, module, exports) {
          "use strict";
          var JSZip = require("jszip");
          module.exports = function (buffer) {
            var zip,
              files = new JSZip(buffer).file(/.+/),
              out = {};
            return (
              files.forEach(function (a) {
                "shp" === a.name.slice(-3).toLowerCase() ||
                "dbf" === a.name.slice(-3).toLowerCase()
                  ? (out[a.name] = a.asArrayBuffer())
                  : (out[a.name] = a.asText());
              }),
              out
            );
          };
        },
        { jszip: 17 },
      ],
      5: [
        function (require, module, exports) {
          var base64 = require("base64-js"),
            ieee754 = require("ieee754"),
            isArray = require("is-array");
          (exports.Buffer = Buffer),
            (exports.SlowBuffer = SlowBuffer),
            (exports.INSPECT_MAX_BYTES = 50),
            (Buffer.poolSize = 8192);
          var rootParent = {};
          function kMaxLength() {
            return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
          }
          function Buffer(arg) {
            return this instanceof Buffer
              ? ((this.length = 0),
                (this.parent = void 0),
                "number" == typeof arg
                  ? fromNumber(this, arg)
                  : "string" == typeof arg
                  ? fromString(
                      this,
                      arg,
                      arguments.length > 1 ? arguments[1] : "utf8"
                    )
                  : fromObject(this, arg))
              : arguments.length > 1
              ? new Buffer(arg, arguments[1])
              : new Buffer(arg);
          }
          function fromNumber(that, length) {
            if (
              ((that = allocate(that, length < 0 ? 0 : 0 | checked(length))),
              !Buffer.TYPED_ARRAY_SUPPORT)
            )
              for (var i = 0; i < length; i++) that[i] = 0;
            return that;
          }
          function fromString(that, string, encoding) {
            var length;
            return (
              ("string" == typeof encoding && "" !== encoding) ||
                (encoding = "utf8"),
              (that = allocate(that, 0 | byteLength(string, encoding))).write(
                string,
                encoding
              ),
              that
            );
          }
          function fromObject(that, object) {
            if (Buffer.isBuffer(object)) return fromBuffer(that, object);
            if (isArray(object)) return fromArray(that, object);
            if (null == object)
              throw new TypeError(
                "must start with number, buffer, array or string"
              );
            if ("undefined" != typeof ArrayBuffer) {
              if (object.buffer instanceof ArrayBuffer)
                return fromTypedArray(that, object);
              if (object instanceof ArrayBuffer)
                return fromArrayBuffer(that, object);
            }
            return object.length
              ? fromArrayLike(that, object)
              : fromJsonObject(that, object);
          }
          function fromBuffer(that, buffer) {
            var length = 0 | checked(buffer.length);
            return (
              (that = allocate(that, length)),
              buffer.copy(that, 0, 0, length),
              that
            );
          }
          function fromArray(that, array) {
            var length = 0 | checked(array.length);
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
            return that;
          }
          function fromTypedArray(that, array) {
            var length = 0 | checked(array.length);
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
            return that;
          }
          function fromArrayBuffer(that, array) {
            return (
              Buffer.TYPED_ARRAY_SUPPORT
                ? (array.byteLength,
                  (that = Buffer._augment(new Uint8Array(array))))
                : (that = fromTypedArray(that, new Uint8Array(array))),
              that
            );
          }
          function fromArrayLike(that, array) {
            var length = 0 | checked(array.length);
            that = allocate(that, length);
            for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
            return that;
          }
          function fromJsonObject(that, object) {
            var array,
              length = 0;
            "Buffer" === object.type &&
              isArray(object.data) &&
              (length = 0 | checked((array = object.data).length)),
              (that = allocate(that, length));
            for (var i = 0; i < length; i += 1) that[i] = 255 & array[i];
            return that;
          }
          function allocate(that, length) {
            var fromPool;
            return (
              Buffer.TYPED_ARRAY_SUPPORT
                ? (that = Buffer._augment(new Uint8Array(length)))
                : ((that.length = length), (that._isBuffer = !0)),
              0 !== length &&
                length <= Buffer.poolSize >>> 1 &&
                (that.parent = rootParent),
              that
            );
          }
          function checked(length) {
            if (length >= kMaxLength())
              throw new RangeError(
                "Attempt to allocate Buffer larger than maximum size: 0x" +
                  kMaxLength().toString(16) +
                  " bytes"
              );
            return 0 | length;
          }
          function SlowBuffer(subject, encoding) {
            if (!(this instanceof SlowBuffer))
              return new SlowBuffer(subject, encoding);
            var buf = new Buffer(subject, encoding);
            return delete buf.parent, buf;
          }
          function byteLength(string, encoding) {
            "string" != typeof string && (string = "" + string);
            var len = string.length;
            if (0 === len) return 0;
            for (var loweredCase = !1; ; )
              switch (encoding) {
                case "ascii":
                case "binary":
                case "raw":
                case "raws":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * len;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) return utf8ToBytes(string).length;
                  (encoding = ("" + encoding).toLowerCase()),
                    (loweredCase = !0);
              }
          }
          function slowToString(encoding, start, end) {
            var loweredCase = !1;
            if (
              (encoding || (encoding = "utf8"),
              (start |= 0) < 0 && (start = 0),
              (end = void 0 === end || end === 1 / 0 ? this.length : 0 | end) >
                this.length && (end = this.length),
              end <= start)
            )
              return "";
            for (;;)
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "binary":
                  return binarySlice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  (encoding = (encoding + "").toLowerCase()),
                    (loweredCase = !0);
              }
          }
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            length
              ? (length = Number(length)) > remaining && (length = remaining)
              : (length = remaining);
            var strLen = string.length;
            if (strLen % 2 != 0) throw new Error("Invalid hex string");
            length > strLen / 2 && (length = strLen / 2);
            for (var i = 0; i < length; i++) {
              var parsed = parseInt(string.substr(2 * i, 2), 16);
              if (isNaN(parsed)) throw new Error("Invalid hex string");
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(
              utf8ToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            );
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function binaryWrite(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(
              utf16leToBytes(string, buf.length - offset),
              buf,
              offset,
              length
            );
          }
          function base64Slice(buf, start, end) {
            return 0 === start && end === buf.length
              ? base64.fromByteArray(buf)
              : base64.fromByteArray(buf.slice(start, end));
          }
          function utf8Slice(buf, start, end) {
            var firstByte,
              secondByte,
              thirdByte,
              fourthByte,
              bytesPerSequence,
              tempCodePoint,
              codePoint;
            end = Math.min(buf.length, end);
            for (var res = [], i = start; i < end; i += bytesPerSequence) {
              if (
                ((codePoint = 65533),
                i +
                  (bytesPerSequence =
                    (firstByte = buf[i]) > 239
                      ? 4
                      : firstByte > 223
                      ? 3
                      : firstByte > 191
                      ? 2
                      : 1) <=
                  end)
              )
                switch (bytesPerSequence) {
                  case 1:
                    firstByte < 128 && (codePoint = firstByte);
                    break;
                  case 2:
                    128 == (192 & (secondByte = buf[i + 1])) &&
                      (tempCodePoint =
                        ((31 & firstByte) << 6) | (63 & secondByte)) > 127 &&
                      (codePoint = tempCodePoint);
                    break;
                  case 3:
                    (secondByte = buf[i + 1]),
                      (thirdByte = buf[i + 2]),
                      128 == (192 & secondByte) &&
                        128 == (192 & thirdByte) &&
                        (tempCodePoint =
                          ((15 & firstByte) << 12) |
                          ((63 & secondByte) << 6) |
                          (63 & thirdByte)) > 2047 &&
                        (tempCodePoint < 55296 || tempCodePoint > 57343) &&
                        (codePoint = tempCodePoint);
                    break;
                  case 4:
                    (secondByte = buf[i + 1]),
                      (thirdByte = buf[i + 2]),
                      (fourthByte = buf[i + 3]),
                      128 == (192 & secondByte) &&
                        128 == (192 & thirdByte) &&
                        128 == (192 & fourthByte) &&
                        (tempCodePoint =
                          ((15 & firstByte) << 18) |
                          ((63 & secondByte) << 12) |
                          ((63 & thirdByte) << 6) |
                          (63 & fourthByte)) > 65535 &&
                        tempCodePoint < 1114112 &&
                        (codePoint = tempCodePoint);
                }
              65533 === codePoint
                ? (bytesPerSequence = 1)
                : codePoint > 65535 &&
                  ((codePoint -= 65536),
                  res.push(((codePoint >>> 10) & 1023) | 55296),
                  (codePoint = 56320 | (1023 & codePoint))),
                res.push(codePoint);
            }
            return String.fromCharCode.apply(String, res);
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++)
              ret += String.fromCharCode(127 & buf[i]);
            return ret;
          }
          function binarySlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; i++)
              ret += String.fromCharCode(buf[i]);
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            (!start || start < 0) && (start = 0),
              (!end || end < 0 || end > len) && (end = len);
            for (var out = "", i = start; i < end; i++) out += toHex(buf[i]);
            return out;
          }
          function utf16leSlice(buf, start, end) {
            for (
              var bytes = buf.slice(start, end), res = "", i = 0;
              i < bytes.length;
              i += 2
            )
              res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
            return res;
          }
          function checkOffset(offset, ext, length) {
            if (offset % 1 != 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError("buffer must be a Buffer instance");
            if (value > max || value < min)
              throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length)
              throw new RangeError("index out of range");
          }
          function objectWriteUInt16(buf, value, offset, littleEndian) {
            value < 0 && (value = 65535 + value + 1);
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++)
              buf[offset + i] =
                (value & (255 << (8 * (littleEndian ? i : 1 - i)))) >>>
                (8 * (littleEndian ? i : 1 - i));
          }
          function objectWriteUInt32(buf, value, offset, littleEndian) {
            value < 0 && (value = 4294967295 + value + 1);
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++)
              buf[offset + i] =
                (value >>> (8 * (littleEndian ? i : 3 - i))) & 255;
          }
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (value > max || value < min)
              throw new RangeError("value is out of bounds");
            if (offset + ext > buf.length)
              throw new RangeError("index out of range");
            if (offset < 0) throw new RangeError("index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            return (
              noAssert ||
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  4,
                  3.4028234663852886e38,
                  -3.4028234663852886e38
                ),
              ieee754.write(buf, value, offset, littleEndian, 23, 4),
              offset + 4
            );
          }
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            return (
              noAssert ||
                checkIEEE754(
                  buf,
                  value,
                  offset,
                  8,
                  1.7976931348623157e308,
                  -1.7976931348623157e308
                ),
              ieee754.write(buf, value, offset, littleEndian, 52, 8),
              offset + 8
            );
          }
          (Buffer.TYPED_ARRAY_SUPPORT = (function () {
            function Bar() {}
            try {
              var arr = new Uint8Array(1);
              return (
                (arr.foo = function () {
                  return 42;
                }),
                (arr.constructor = Bar),
                42 === arr.foo() &&
                  arr.constructor === Bar &&
                  "function" == typeof arr.subarray &&
                  0 === arr.subarray(1, 1).byteLength
              );
            } catch (e) {
              return !1;
            }
          })()),
            (Buffer.isBuffer = function isBuffer(b) {
              return !(null == b || !b._isBuffer);
            }),
            (Buffer.compare = function compare(a, b) {
              if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
                throw new TypeError("Arguments must be Buffers");
              if (a === b) return 0;
              for (
                var x = a.length, y = b.length, i = 0, len = Math.min(x, y);
                i < len && a[i] === b[i];

              )
                ++i;
              return (
                i !== len && ((x = a[i]), (y = b[i])),
                x < y ? -1 : y < x ? 1 : 0
              );
            }),
            (Buffer.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "raw":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }),
            (Buffer.concat = function concat(list, length) {
              if (!isArray(list))
                throw new TypeError(
                  "list argument must be an Array of Buffers."
                );
              if (0 === list.length) return new Buffer(0);
              var i;
              if (void 0 === length)
                for (length = 0, i = 0; i < list.length; i++)
                  length += list[i].length;
              var buf = new Buffer(length),
                pos = 0;
              for (i = 0; i < list.length; i++) {
                var item = list[i];
                item.copy(buf, pos), (pos += item.length);
              }
              return buf;
            }),
            (Buffer.byteLength = byteLength),
            (Buffer.prototype.length = void 0),
            (Buffer.prototype.parent = void 0),
            (Buffer.prototype.toString = function toString() {
              var length = 0 | this.length;
              return 0 === length
                ? ""
                : 0 === arguments.length
                ? utf8Slice(this, 0, length)
                : slowToString.apply(this, arguments);
            }),
            (Buffer.prototype.equals = function equals(b) {
              if (!Buffer.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              return this === b || 0 === Buffer.compare(this, b);
            }),
            (Buffer.prototype.inspect = function inspect() {
              var str = "",
                max = exports.INSPECT_MAX_BYTES;
              return (
                this.length > 0 &&
                  ((str = this.toString("hex", 0, max)
                    .match(/.{2}/g)
                    .join(" ")),
                  this.length > max && (str += " ... ")),
                "<Buffer " + str + ">"
              );
            }),
            (Buffer.prototype.compare = function compare(b) {
              if (!Buffer.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              return this === b ? 0 : Buffer.compare(this, b);
            }),
            (Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
              if (
                (byteOffset > 2147483647
                  ? (byteOffset = 2147483647)
                  : byteOffset < -2147483648 && (byteOffset = -2147483648),
                (byteOffset >>= 0),
                0 === this.length)
              )
                return -1;
              if (byteOffset >= this.length) return -1;
              if (
                (byteOffset < 0 &&
                  (byteOffset = Math.max(this.length + byteOffset, 0)),
                "string" == typeof val)
              )
                return 0 === val.length
                  ? -1
                  : String.prototype.indexOf.call(this, val, byteOffset);
              if (Buffer.isBuffer(val))
                return arrayIndexOf(this, val, byteOffset);
              if ("number" == typeof val)
                return Buffer.TYPED_ARRAY_SUPPORT &&
                  "function" === Uint8Array.prototype.indexOf
                  ? Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                  : arrayIndexOf(this, [val], byteOffset);
              function arrayIndexOf(arr, val, byteOffset) {
                for (
                  var foundIndex = -1, i = 0;
                  byteOffset + i < arr.length;
                  i++
                )
                  if (
                    arr[byteOffset + i] ===
                    val[-1 === foundIndex ? 0 : i - foundIndex]
                  ) {
                    if (
                      (-1 === foundIndex && (foundIndex = i),
                      i - foundIndex + 1 === val.length)
                    )
                      return byteOffset + foundIndex;
                  } else foundIndex = -1;
                return -1;
              }
              throw new TypeError("val must be string, number or Buffer");
            }),
            (Buffer.prototype.get = function get(offset) {
              return (
                console.log(
                  ".get() is deprecated. Access using array indexes instead."
                ),
                this.readUInt8(offset)
              );
            }),
            (Buffer.prototype.set = function set(v, offset) {
              return (
                console.log(
                  ".set() is deprecated. Access using array indexes instead."
                ),
                this.writeUInt8(v, offset)
              );
            }),
            (Buffer.prototype.write = function write(
              string,
              offset,
              length,
              encoding
            ) {
              if (void 0 === offset)
                (encoding = "utf8"), (length = this.length), (offset = 0);
              else if (void 0 === length && "string" == typeof offset)
                (encoding = offset), (length = this.length), (offset = 0);
              else if (isFinite(offset))
                (offset |= 0),
                  isFinite(length)
                    ? ((length |= 0),
                      void 0 === encoding && (encoding = "utf8"))
                    : ((encoding = length), (length = void 0));
              else {
                var swap = encoding;
                (encoding = offset), (offset = 0 | length), (length = swap);
              }
              var remaining = this.length - offset;
              if (
                ((void 0 === length || length > remaining) &&
                  (length = remaining),
                (string.length > 0 && (length < 0 || offset < 0)) ||
                  offset > this.length)
              )
                throw new RangeError("attempt to write outside buffer bounds");
              encoding || (encoding = "utf8");
              for (var loweredCase = !1; ; )
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset, length);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset, length);
                  case "ascii":
                    return asciiWrite(this, string, offset, length);
                  case "binary":
                    return binaryWrite(this, string, offset, length);
                  case "base64":
                    return base64Write(this, string, offset, length);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset, length);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    (encoding = ("" + encoding).toLowerCase()),
                      (loweredCase = !0);
                }
            }),
            (Buffer.prototype.toJSON = function toJSON() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            }),
            (Buffer.prototype.slice = function slice(start, end) {
              var len = this.length,
                newBuf;
              if (
                ((start = ~~start) < 0
                  ? (start += len) < 0 && (start = 0)
                  : start > len && (start = len),
                (end = void 0 === end ? len : ~~end) < 0
                  ? (end += len) < 0 && (end = 0)
                  : end > len && (end = len),
                end < start && (end = start),
                Buffer.TYPED_ARRAY_SUPPORT)
              )
                newBuf = Buffer._augment(this.subarray(start, end));
              else {
                var sliceLen = end - start;
                newBuf = new Buffer(sliceLen, void 0);
                for (var i = 0; i < sliceLen; i++) newBuf[i] = this[i + start];
              }
              return (
                newBuf.length && (newBuf.parent = this.parent || this), newBuf
              );
            }),
            (Buffer.prototype.readUIntLE = function readUIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              (offset |= 0),
                (byteLength |= 0),
                noAssert || checkOffset(offset, byteLength, this.length);
              for (
                var val = this[offset], mul = 1, i = 0;
                ++i < byteLength && (mul *= 256);

              )
                val += this[offset + i] * mul;
              return val;
            }),
            (Buffer.prototype.readUIntBE = function readUIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              (offset |= 0),
                (byteLength |= 0),
                noAssert || checkOffset(offset, byteLength, this.length);
              for (
                var val = this[offset + --byteLength], mul = 1;
                byteLength > 0 && (mul *= 256);

              )
                val += this[offset + --byteLength] * mul;
              return val;
            }),
            (Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
              return (
                noAssert || checkOffset(offset, 1, this.length), this[offset]
              );
            }),
            (Buffer.prototype.readUInt16LE = function readUInt16LE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 2, this.length),
                this[offset] | (this[offset + 1] << 8)
              );
            }),
            (Buffer.prototype.readUInt16BE = function readUInt16BE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 2, this.length),
                (this[offset] << 8) | this[offset + 1]
              );
            }),
            (Buffer.prototype.readUInt32LE = function readUInt32LE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                (this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16)) +
                  16777216 * this[offset + 3]
              );
            }),
            (Buffer.prototype.readUInt32BE = function readUInt32BE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                16777216 * this[offset] +
                  ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
              );
            }),
            (Buffer.prototype.readIntLE = function readIntLE(
              offset,
              byteLength,
              noAssert
            ) {
              (offset |= 0),
                (byteLength |= 0),
                noAssert || checkOffset(offset, byteLength, this.length);
              for (
                var val = this[offset], mul = 1, i = 0;
                ++i < byteLength && (mul *= 256);

              )
                val += this[offset + i] * mul;
              return (
                val >= (mul *= 128) && (val -= Math.pow(2, 8 * byteLength)), val
              );
            }),
            (Buffer.prototype.readIntBE = function readIntBE(
              offset,
              byteLength,
              noAssert
            ) {
              (offset |= 0),
                (byteLength |= 0),
                noAssert || checkOffset(offset, byteLength, this.length);
              for (
                var i = byteLength, mul = 1, val = this[offset + --i];
                i > 0 && (mul *= 256);

              )
                val += this[offset + --i] * mul;
              return (
                val >= (mul *= 128) && (val -= Math.pow(2, 8 * byteLength)), val
              );
            }),
            (Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
              return (
                noAssert || checkOffset(offset, 1, this.length),
                128 & this[offset]
                  ? -1 * (255 - this[offset] + 1)
                  : this[offset]
              );
            }),
            (Buffer.prototype.readInt16LE = function readInt16LE(
              offset,
              noAssert
            ) {
              noAssert || checkOffset(offset, 2, this.length);
              var val = this[offset] | (this[offset + 1] << 8);
              return 32768 & val ? 4294901760 | val : val;
            }),
            (Buffer.prototype.readInt16BE = function readInt16BE(
              offset,
              noAssert
            ) {
              noAssert || checkOffset(offset, 2, this.length);
              var val = this[offset + 1] | (this[offset] << 8);
              return 32768 & val ? 4294901760 | val : val;
            }),
            (Buffer.prototype.readInt32LE = function readInt32LE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                this[offset] |
                  (this[offset + 1] << 8) |
                  (this[offset + 2] << 16) |
                  (this[offset + 3] << 24)
              );
            }),
            (Buffer.prototype.readInt32BE = function readInt32BE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                (this[offset] << 24) |
                  (this[offset + 1] << 16) |
                  (this[offset + 2] << 8) |
                  this[offset + 3]
              );
            }),
            (Buffer.prototype.readFloatLE = function readFloatLE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                ieee754.read(this, offset, !0, 23, 4)
              );
            }),
            (Buffer.prototype.readFloatBE = function readFloatBE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 4, this.length),
                ieee754.read(this, offset, !1, 23, 4)
              );
            }),
            (Buffer.prototype.readDoubleLE = function readDoubleLE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 8, this.length),
                ieee754.read(this, offset, !0, 52, 8)
              );
            }),
            (Buffer.prototype.readDoubleBE = function readDoubleBE(
              offset,
              noAssert
            ) {
              return (
                noAssert || checkOffset(offset, 8, this.length),
                ieee754.read(this, offset, !1, 52, 8)
              );
            }),
            (Buffer.prototype.writeUIntLE = function writeUIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              (value = +value),
                (offset |= 0),
                (byteLength |= 0),
                noAssert ||
                  checkInt(
                    this,
                    value,
                    offset,
                    byteLength,
                    Math.pow(2, 8 * byteLength),
                    0
                  );
              var mul = 1,
                i = 0;
              for (
                this[offset] = 255 & value;
                ++i < byteLength && (mul *= 256);

              )
                this[offset + i] = (value / mul) & 255;
              return offset + byteLength;
            }),
            (Buffer.prototype.writeUIntBE = function writeUIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              (value = +value),
                (offset |= 0),
                (byteLength |= 0),
                noAssert ||
                  checkInt(
                    this,
                    value,
                    offset,
                    byteLength,
                    Math.pow(2, 8 * byteLength),
                    0
                  );
              var i = byteLength - 1,
                mul = 1;
              for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256); )
                this[offset + i] = (value / mul) & 255;
              return offset + byteLength;
            }),
            (Buffer.prototype.writeUInt8 = function writeUInt8(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 1, 255, 0),
                Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)),
                (this[offset] = value),
                offset + 1
              );
            }),
            (Buffer.prototype.writeUInt16LE = function writeUInt16LE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 2, 65535, 0),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value), (this[offset + 1] = value >>> 8))
                  : objectWriteUInt16(this, value, offset, !0),
                offset + 2
              );
            }),
            (Buffer.prototype.writeUInt16BE = function writeUInt16BE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 2, 65535, 0),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value >>> 8), (this[offset + 1] = value))
                  : objectWriteUInt16(this, value, offset, !1),
                offset + 2
              );
            }),
            (Buffer.prototype.writeUInt32LE = function writeUInt32LE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset + 3] = value >>> 24),
                    (this[offset + 2] = value >>> 16),
                    (this[offset + 1] = value >>> 8),
                    (this[offset] = value))
                  : objectWriteUInt32(this, value, offset, !0),
                offset + 4
              );
            }),
            (Buffer.prototype.writeUInt32BE = function writeUInt32BE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 4, 4294967295, 0),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value >>> 24),
                    (this[offset + 1] = value >>> 16),
                    (this[offset + 2] = value >>> 8),
                    (this[offset + 3] = value))
                  : objectWriteUInt32(this, value, offset, !1),
                offset + 4
              );
            }),
            (Buffer.prototype.writeIntLE = function writeIntLE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              if (((value = +value), (offset |= 0), !noAssert)) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }
              var i = 0,
                mul = 1,
                sub = value < 0 ? 1 : 0;
              for (
                this[offset] = 255 & value;
                ++i < byteLength && (mul *= 256);

              )
                this[offset + i] = (((value / mul) >> 0) - sub) & 255;
              return offset + byteLength;
            }),
            (Buffer.prototype.writeIntBE = function writeIntBE(
              value,
              offset,
              byteLength,
              noAssert
            ) {
              if (((value = +value), (offset |= 0), !noAssert)) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
              }
              var i = byteLength - 1,
                mul = 1,
                sub = value < 0 ? 1 : 0;
              for (this[offset + i] = 255 & value; --i >= 0 && (mul *= 256); )
                this[offset + i] = (((value / mul) >> 0) - sub) & 255;
              return offset + byteLength;
            }),
            (Buffer.prototype.writeInt8 = function writeInt8(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 1, 127, -128),
                Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)),
                value < 0 && (value = 255 + value + 1),
                (this[offset] = value),
                offset + 1
              );
            }),
            (Buffer.prototype.writeInt16LE = function writeInt16LE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 2, 32767, -32768),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value), (this[offset + 1] = value >>> 8))
                  : objectWriteUInt16(this, value, offset, !0),
                offset + 2
              );
            }),
            (Buffer.prototype.writeInt16BE = function writeInt16BE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert || checkInt(this, value, offset, 2, 32767, -32768),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value >>> 8), (this[offset + 1] = value))
                  : objectWriteUInt16(this, value, offset, !1),
                offset + 2
              );
            }),
            (Buffer.prototype.writeInt32LE = function writeInt32LE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert ||
                  checkInt(this, value, offset, 4, 2147483647, -2147483648),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value),
                    (this[offset + 1] = value >>> 8),
                    (this[offset + 2] = value >>> 16),
                    (this[offset + 3] = value >>> 24))
                  : objectWriteUInt32(this, value, offset, !0),
                offset + 4
              );
            }),
            (Buffer.prototype.writeInt32BE = function writeInt32BE(
              value,
              offset,
              noAssert
            ) {
              return (
                (value = +value),
                (offset |= 0),
                noAssert ||
                  checkInt(this, value, offset, 4, 2147483647, -2147483648),
                value < 0 && (value = 4294967295 + value + 1),
                Buffer.TYPED_ARRAY_SUPPORT
                  ? ((this[offset] = value >>> 24),
                    (this[offset + 1] = value >>> 16),
                    (this[offset + 2] = value >>> 8),
                    (this[offset + 3] = value))
                  : objectWriteUInt32(this, value, offset, !1),
                offset + 4
              );
            }),
            (Buffer.prototype.writeFloatLE = function writeFloatLE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, !0, noAssert);
            }),
            (Buffer.prototype.writeFloatBE = function writeFloatBE(
              value,
              offset,
              noAssert
            ) {
              return writeFloat(this, value, offset, !1, noAssert);
            }),
            (Buffer.prototype.writeDoubleLE = function writeDoubleLE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, !0, noAssert);
            }),
            (Buffer.prototype.writeDoubleBE = function writeDoubleBE(
              value,
              offset,
              noAssert
            ) {
              return writeDouble(this, value, offset, !1, noAssert);
            }),
            (Buffer.prototype.copy = function copy(
              target,
              targetStart,
              start,
              end
            ) {
              if (
                (start || (start = 0),
                end || 0 === end || (end = this.length),
                targetStart >= target.length && (targetStart = target.length),
                targetStart || (targetStart = 0),
                end > 0 && end < start && (end = start),
                end === start)
              )
                return 0;
              if (0 === target.length || 0 === this.length) return 0;
              if (targetStart < 0)
                throw new RangeError("targetStart out of bounds");
              if (start < 0 || start >= this.length)
                throw new RangeError("sourceStart out of bounds");
              if (end < 0) throw new RangeError("sourceEnd out of bounds");
              end > this.length && (end = this.length),
                target.length - targetStart < end - start &&
                  (end = target.length - targetStart + start);
              var len = end - start,
                i;
              if (this === target && start < targetStart && targetStart < end)
                for (i = len - 1; i >= 0; i--)
                  target[i + targetStart] = this[i + start];
              else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT)
                for (i = 0; i < len; i++)
                  target[i + targetStart] = this[i + start];
              else target._set(this.subarray(start, start + len), targetStart);
              return len;
            }),
            (Buffer.prototype.fill = function fill(value, start, end) {
              if (
                (value || (value = 0),
                start || (start = 0),
                end || (end = this.length),
                end < start)
              )
                throw new RangeError("end < start");
              if (end !== start && 0 !== this.length) {
                if (start < 0 || start >= this.length)
                  throw new RangeError("start out of bounds");
                if (end < 0 || end > this.length)
                  throw new RangeError("end out of bounds");
                var i;
                if ("number" == typeof value)
                  for (i = start; i < end; i++) this[i] = value;
                else {
                  var bytes = utf8ToBytes(value.toString()),
                    len = bytes.length;
                  for (i = start; i < end; i++) this[i] = bytes[i % len];
                }
                return this;
              }
            }),
            (Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
              if ("undefined" != typeof Uint8Array) {
                if (Buffer.TYPED_ARRAY_SUPPORT) return new Buffer(this).buffer;
                for (
                  var buf = new Uint8Array(this.length),
                    i = 0,
                    len = buf.length;
                  i < len;
                  i += 1
                )
                  buf[i] = this[i];
                return buf.buffer;
              }
              throw new TypeError(
                "Buffer.toArrayBuffer not supported in this browser"
              );
            });
          var BP = Buffer.prototype;
          Buffer._augment = function _augment(arr) {
            return (
              (arr.constructor = Buffer),
              (arr._isBuffer = !0),
              (arr._set = arr.set),
              (arr.get = BP.get),
              (arr.set = BP.set),
              (arr.write = BP.write),
              (arr.toString = BP.toString),
              (arr.toLocaleString = BP.toString),
              (arr.toJSON = BP.toJSON),
              (arr.equals = BP.equals),
              (arr.compare = BP.compare),
              (arr.indexOf = BP.indexOf),
              (arr.copy = BP.copy),
              (arr.slice = BP.slice),
              (arr.readUIntLE = BP.readUIntLE),
              (arr.readUIntBE = BP.readUIntBE),
              (arr.readUInt8 = BP.readUInt8),
              (arr.readUInt16LE = BP.readUInt16LE),
              (arr.readUInt16BE = BP.readUInt16BE),
              (arr.readUInt32LE = BP.readUInt32LE),
              (arr.readUInt32BE = BP.readUInt32BE),
              (arr.readIntLE = BP.readIntLE),
              (arr.readIntBE = BP.readIntBE),
              (arr.readInt8 = BP.readInt8),
              (arr.readInt16LE = BP.readInt16LE),
              (arr.readInt16BE = BP.readInt16BE),
              (arr.readInt32LE = BP.readInt32LE),
              (arr.readInt32BE = BP.readInt32BE),
              (arr.readFloatLE = BP.readFloatLE),
              (arr.readFloatBE = BP.readFloatBE),
              (arr.readDoubleLE = BP.readDoubleLE),
              (arr.readDoubleBE = BP.readDoubleBE),
              (arr.writeUInt8 = BP.writeUInt8),
              (arr.writeUIntLE = BP.writeUIntLE),
              (arr.writeUIntBE = BP.writeUIntBE),
              (arr.writeUInt16LE = BP.writeUInt16LE),
              (arr.writeUInt16BE = BP.writeUInt16BE),
              (arr.writeUInt32LE = BP.writeUInt32LE),
              (arr.writeUInt32BE = BP.writeUInt32BE),
              (arr.writeIntLE = BP.writeIntLE),
              (arr.writeIntBE = BP.writeIntBE),
              (arr.writeInt8 = BP.writeInt8),
              (arr.writeInt16LE = BP.writeInt16LE),
              (arr.writeInt16BE = BP.writeInt16BE),
              (arr.writeInt32LE = BP.writeInt32LE),
              (arr.writeInt32BE = BP.writeInt32BE),
              (arr.writeFloatLE = BP.writeFloatLE),
              (arr.writeFloatBE = BP.writeFloatBE),
              (arr.writeDoubleLE = BP.writeDoubleLE),
              (arr.writeDoubleBE = BP.writeDoubleBE),
              (arr.fill = BP.fill),
              (arr.inspect = BP.inspect),
              (arr.toArrayBuffer = BP.toArrayBuffer),
              arr
            );
          };
          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
          function base64clean(str) {
            if (
              (str = stringtrim(str).replace(INVALID_BASE64_RE, "")).length < 2
            )
              return "";
            for (; str.length % 4 != 0; ) str += "=";
            return str;
          }
          function stringtrim(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
          }
          function toHex(n) {
            return n < 16 ? "0" + n.toString(16) : n.toString(16);
          }
          function utf8ToBytes(string, units) {
            var codePoint;
            units = units || 1 / 0;
            for (
              var length = string.length,
                leadSurrogate = null,
                bytes = [],
                i = 0;
              i < length;
              i++
            ) {
              if (
                (codePoint = string.charCodeAt(i)) > 55295 &&
                codePoint < 57344
              ) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    (units -= 3) > -1 && bytes.push(239, 191, 189);
                    continue;
                  }
                  if (i + 1 === length) {
                    (units -= 3) > -1 && bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  (units -= 3) > -1 && bytes.push(239, 191, 189),
                    (leadSurrogate = codePoint);
                  continue;
                }
                codePoint =
                  ((leadSurrogate - 55296) << 10) | (codePoint - 56320) | 65536;
              } else
                leadSurrogate && (units -= 3) > -1 && bytes.push(239, 191, 189);
              if (((leadSurrogate = null), codePoint < 128)) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0) break;
                bytes.push((codePoint >> 6) | 192, (63 & codePoint) | 128);
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0) break;
                bytes.push(
                  (codePoint >> 12) | 224,
                  ((codePoint >> 6) & 63) | 128,
                  (63 & codePoint) | 128
                );
              } else {
                if (!(codePoint < 1114112))
                  throw new Error("Invalid code point");
                if ((units -= 4) < 0) break;
                bytes.push(
                  (codePoint >> 18) | 240,
                  ((codePoint >> 12) & 63) | 128,
                  ((codePoint >> 6) & 63) | 128,
                  (63 & codePoint) | 128
                );
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            for (var byteArray = [], i = 0; i < str.length; i++)
              byteArray.push(255 & str.charCodeAt(i));
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            for (
              var c, hi, lo, byteArray = [], i = 0;
              i < str.length && !((units -= 2) < 0);
              i++
            )
              (hi = (c = str.charCodeAt(i)) >> 8),
                (lo = c % 256),
                byteArray.push(lo),
                byteArray.push(hi);
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (
              var i = 0;
              i < length && !(i + offset >= dst.length || i >= src.length);
              i++
            )
              dst[i + offset] = src[i];
            return i;
          }
        },
        { "base64-js": 6, ieee754: 7, "is-array": 8 },
      ],
      6: [
        function (require, module, exports) {
          var lookup =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          !(function (exports) {
            "use strict";
            var Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array,
              PLUS = "+".charCodeAt(0),
              SLASH = "/".charCodeAt(0),
              NUMBER = "0".charCodeAt(0),
              LOWER = "a".charCodeAt(0),
              UPPER = "A".charCodeAt(0),
              PLUS_URL_SAFE = "-".charCodeAt(0),
              SLASH_URL_SAFE = "_".charCodeAt(0);
            function decode(elt) {
              var code = elt.charCodeAt(0);
              return code === PLUS || code === PLUS_URL_SAFE
                ? 62
                : code === SLASH || code === SLASH_URL_SAFE
                ? 63
                : code < NUMBER
                ? -1
                : code < NUMBER + 10
                ? code - NUMBER + 26 + 26
                : code < UPPER + 26
                ? code - UPPER
                : code < LOWER + 26
                ? code - LOWER + 26
                : void 0;
            }
            function b64ToByteArray(b64) {
              var i, j, l, tmp, placeHolders, arr;
              if (b64.length % 4 > 0)
                throw new Error(
                  "Invalid string. Length must be a multiple of 4"
                );
              var len = b64.length;
              (placeHolders =
                "=" === b64.charAt(len - 2)
                  ? 2
                  : "=" === b64.charAt(len - 1)
                  ? 1
                  : 0),
                (arr = new Arr((3 * b64.length) / 4 - placeHolders)),
                (l = placeHolders > 0 ? b64.length - 4 : b64.length);
              var L = 0;
              function push(v) {
                arr[L++] = v;
              }
              for (i = 0, j = 0; i < l; i += 4, j += 3)
                push(
                  (16711680 &
                    (tmp =
                      (decode(b64.charAt(i)) << 18) |
                      (decode(b64.charAt(i + 1)) << 12) |
                      (decode(b64.charAt(i + 2)) << 6) |
                      decode(b64.charAt(i + 3)))) >>
                    16
                ),
                  push((65280 & tmp) >> 8),
                  push(255 & tmp);
              return (
                2 === placeHolders
                  ? push(
                      255 &
                        (tmp =
                          (decode(b64.charAt(i)) << 2) |
                          (decode(b64.charAt(i + 1)) >> 4))
                    )
                  : 1 === placeHolders &&
                    (push(
                      ((tmp =
                        (decode(b64.charAt(i)) << 10) |
                        (decode(b64.charAt(i + 1)) << 4) |
                        (decode(b64.charAt(i + 2)) >> 2)) >>
                        8) &
                        255
                    ),
                    push(255 & tmp)),
                arr
              );
            }
            function uint8ToBase64(uint8) {
              var i,
                extraBytes = uint8.length % 3,
                output = "",
                temp,
                length;
              function encode(num) {
                return lookup.charAt(num);
              }
              function tripletToBase64(num) {
                return (
                  encode((num >> 18) & 63) +
                  encode((num >> 12) & 63) +
                  encode((num >> 6) & 63) +
                  encode(63 & num)
                );
              }
              for (
                i = 0, length = uint8.length - extraBytes;
                i < length;
                i += 3
              )
                output += tripletToBase64(
                  (temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2])
                );
              switch (extraBytes) {
                case 1:
                  (output += encode((temp = uint8[uint8.length - 1]) >> 2)),
                    (output += encode((temp << 4) & 63)),
                    (output += "==");
                  break;
                case 2:
                  (output += encode(
                    (temp =
                      (uint8[uint8.length - 2] << 8) +
                      uint8[uint8.length - 1]) >> 10
                  )),
                    (output += encode((temp >> 4) & 63)),
                    (output += encode((temp << 2) & 63)),
                    (output += "=");
              }
              return output;
            }
            (exports.toByteArray = b64ToByteArray),
              (exports.fromByteArray = uint8ToBase64);
          })(void 0 === exports ? (this.base64js = {}) : exports);
        },
        {},
      ],
      7: [
        function (require, module, exports) {
          (exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e,
              m,
              eLen = 8 * nBytes - mLen - 1,
              eMax = (1 << eLen) - 1,
              eBias = eMax >> 1,
              nBits = -7,
              i = isLE ? nBytes - 1 : 0,
              d = isLE ? -1 : 1,
              s = buffer[offset + i];
            for (
              i += d, e = s & ((1 << -nBits) - 1), s >>= -nBits, nBits += eLen;
              nBits > 0;
              e = 256 * e + buffer[offset + i], i += d, nBits -= 8
            );
            for (
              m = e & ((1 << -nBits) - 1), e >>= -nBits, nBits += mLen;
              nBits > 0;
              m = 256 * m + buffer[offset + i], i += d, nBits -= 8
            );
            if (0 === e) e = 1 - eBias;
            else {
              if (e === eMax) return m ? NaN : (1 / 0) * (s ? -1 : 1);
              (m += Math.pow(2, mLen)), (e -= eBias);
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          }),
            (exports.write = function (
              buffer,
              value,
              offset,
              isLE,
              mLen,
              nBytes
            ) {
              var e,
                m,
                c,
                eLen = 8 * nBytes - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                i = isLE ? 0 : nBytes - 1,
                d = isLE ? 1 : -1,
                s = value < 0 || (0 === value && 1 / value < 0) ? 1 : 0;
              for (
                value = Math.abs(value),
                  isNaN(value) || value === 1 / 0
                    ? ((m = isNaN(value) ? 1 : 0), (e = eMax))
                    : ((e = Math.floor(Math.log(value) / Math.LN2)),
                      value * (c = Math.pow(2, -e)) < 1 && (e--, (c *= 2)),
                      (value +=
                        e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias)) *
                        c >=
                        2 && (e++, (c /= 2)),
                      e + eBias >= eMax
                        ? ((m = 0), (e = eMax))
                        : e + eBias >= 1
                        ? ((m = (value * c - 1) * Math.pow(2, mLen)),
                          (e += eBias))
                        : ((m =
                            value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)),
                          (e = 0)));
                mLen >= 8;
                buffer[offset + i] = 255 & m, i += d, m /= 256, mLen -= 8
              );
              for (
                e = (e << mLen) | m, eLen += mLen;
                eLen > 0;
                buffer[offset + i] = 255 & e, i += d, e /= 256, eLen -= 8
              );
              buffer[offset + i - d] |= 128 * s;
            });
        },
        {},
      ],
      8: [
        function (require, module, exports) {
          var isArray = Array.isArray,
            str = Object.prototype.toString;
          module.exports =
            isArray ||
            function (val) {
              return !!val && "[object Array]" == str.call(val);
            };
        },
        {},
      ],
      9: [
        function (require, module, exports) {
          "use strict";
          var _keyStr =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          (exports.encode = function (input, utf8) {
            for (
              var output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
              i < input.length;

            )
              (enc1 = (chr1 = input.charCodeAt(i++)) >> 2),
                (enc2 =
                  ((3 & chr1) << 4) | ((chr2 = input.charCodeAt(i++)) >> 4)),
                (enc3 =
                  ((15 & chr2) << 2) | ((chr3 = input.charCodeAt(i++)) >> 6)),
                (enc4 = 63 & chr3),
                isNaN(chr2) ? (enc3 = enc4 = 64) : isNaN(chr3) && (enc4 = 64),
                (output =
                  output +
                  _keyStr.charAt(enc1) +
                  _keyStr.charAt(enc2) +
                  _keyStr.charAt(enc3) +
                  _keyStr.charAt(enc4));
            return output;
          }),
            (exports.decode = function (input, utf8) {
              var output = "",
                chr1,
                chr2,
                chr3,
                enc1,
                enc2,
                enc3,
                enc4,
                i = 0;
              for (
                input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                i < input.length;

              )
                (chr1 =
                  ((enc1 = _keyStr.indexOf(input.charAt(i++))) << 2) |
                  ((enc2 = _keyStr.indexOf(input.charAt(i++))) >> 4)),
                  (chr2 =
                    ((15 & enc2) << 4) |
                    ((enc3 = _keyStr.indexOf(input.charAt(i++))) >> 2)),
                  (chr3 =
                    ((3 & enc3) << 6) |
                    (enc4 = _keyStr.indexOf(input.charAt(i++)))),
                  (output += String.fromCharCode(chr1)),
                  64 != enc3 && (output += String.fromCharCode(chr2)),
                  64 != enc4 && (output += String.fromCharCode(chr3));
              return output;
            });
        },
        {},
      ],
      10: [
        function (require, module, exports) {
          "use strict";
          function CompressedObject() {
            (this.compressedSize = 0),
              (this.uncompressedSize = 0),
              (this.crc32 = 0),
              (this.compressionMethod = null),
              (this.compressedContent = null);
          }
          (CompressedObject.prototype = {
            getContent: function () {
              return null;
            },
            getCompressedContent: function () {
              return null;
            },
          }),
            (module.exports = CompressedObject);
        },
        {},
      ],
      11: [
        function (require, module, exports) {
          "use strict";
          (exports.STORE = {
            magic: "\0\0",
            compress: function (content, compressionOptions) {
              return content;
            },
            uncompress: function (content) {
              return content;
            },
            compressInputType: null,
            uncompressInputType: null,
          }),
            (exports.DEFLATE = require("./flate"));
        },
        { "./flate": 16 },
      ],
      12: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./utils"),
            table = [
              0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615,
              3915621685, 2657392035, 249268274, 2044508324, 3772115230,
              2547177864, 162941995, 2125561021, 3887607047, 2428444049,
              498536548, 1789927666, 4089016648, 2227061214, 450548861,
              1843258603, 4107580753, 2211677639, 325883990, 1684777152,
              4251122042, 2321926636, 335633487, 1661365465, 4195302755,
              2366115317, 997073096, 1281953886, 3579855332, 2724688242,
              1006888145, 1258607687, 3524101629, 2768942443, 901097722,
              1119000684, 3686517206, 2898065728, 853044451, 1172266101,
              3705015759, 2882616665, 651767980, 1373503546, 3369554304,
              3218104598, 565507253, 1454621731, 3485111705, 3099436303,
              671266974, 1594198024, 3322730930, 2970347812, 795835527,
              1483230225, 3244367275, 3060149565, 1994146192, 31158534,
              2563907772, 4023717930, 1907459465, 112637215, 2680153253,
              3904427059, 2013776290, 251722036, 2517215374, 3775830040,
              2137656763, 141376813, 2439277719, 3865271297, 1802195444,
              476864866, 2238001368, 4066508878, 1812370925, 453092731,
              2181625025, 4111451223, 1706088902, 314042704, 2344532202,
              4240017532, 1658658271, 366619977, 2362670323, 4224994405,
              1303535960, 984961486, 2747007092, 3569037538, 1256170817,
              1037604311, 2765210733, 3554079995, 1131014506, 879679996,
              2909243462, 3663771856, 1141124467, 855842277, 2852801631,
              3708648649, 1342533948, 654459306, 3188396048, 3373015174,
              1466479909, 544179635, 3110523913, 3462522015, 1591671054,
              702138776, 2966460450, 3352799412, 1504918807, 783551873,
              3082640443, 3233442989, 3988292384, 2596254646, 62317068,
              1957810842, 3939845945, 2647816111, 81470997, 1943803523,
              3814918930, 2489596804, 225274430, 2053790376, 3826175755,
              2466906013, 167816743, 2097651377, 4027552580, 2265490386,
              503444072, 1762050814, 4150417245, 2154129355, 426522225,
              1852507879, 4275313526, 2312317920, 282753626, 1742555852,
              4189708143, 2394877945, 397917763, 1622183637, 3604390888,
              2714866558, 953729732, 1340076626, 3518719985, 2797360999,
              1068828381, 1219638859, 3624741850, 2936675148, 906185462,
              1090812512, 3747672003, 2825379669, 829329135, 1181335161,
              3412177804, 3160834842, 628085408, 1382605366, 3423369109,
              3138078467, 570562233, 1426400815, 3317316542, 2998733608,
              733239954, 1555261956, 3268935591, 3050360625, 752459403,
              1541320221, 2607071920, 3965973030, 1969922972, 40735498,
              2617837225, 3943577151, 1913087877, 83908371, 2512341634,
              3803740692, 2075208622, 213261112, 2463272603, 3855990285,
              2094854071, 198958881, 2262029012, 4057260610, 1759359992,
              534414190, 2176718541, 4139329115, 1873836001, 414664567,
              2282248934, 4279200368, 1711684554, 285281116, 2405801727,
              4167216745, 1634467795, 376229701, 2685067896, 3608007406,
              1308918612, 956543938, 2808555105, 3495958263, 1231636301,
              1047427035, 2932959818, 3654703836, 1088359270, 936918e3,
              2847714899, 3736837829, 1202900863, 817233897, 3183342108,
              3401237130, 1404277552, 615818150, 3134207493, 3453421203,
              1423857449, 601450431, 3009837614, 3294710456, 1567103746,
              711928724, 3020668471, 3272380065, 1510334235, 755167117,
            ];
          module.exports = function crc32(input, crc) {
            if (void 0 === input || !input.length) return 0;
            var isArray = "string" !== utils.getTypeOf(input);
            void 0 === crc && (crc = 0);
            var x = 0,
              y = 0,
              b = 0;
            crc ^= -1;
            for (var i = 0, iTop = input.length; i < iTop; i++)
              (b = isArray ? input[i] : input.charCodeAt(i)),
                (crc = (crc >>> 8) ^ (x = table[(y = 255 & (crc ^ b))]));
            return -1 ^ crc;
          };
        },
        { "./utils": 29 },
      ],
      13: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./utils");
          function DataReader(data) {
            (this.data = null), (this.length = 0), (this.index = 0);
          }
          (DataReader.prototype = {
            checkOffset: function (offset) {
              this.checkIndex(this.index + offset);
            },
            checkIndex: function (newIndex) {
              if (this.length < newIndex || newIndex < 0)
                throw new Error(
                  "End of data reached (data length = " +
                    this.length +
                    ", asked index = " +
                    newIndex +
                    "). Corrupted zip ?"
                );
            },
            setIndex: function (newIndex) {
              this.checkIndex(newIndex), (this.index = newIndex);
            },
            skip: function (n) {
              this.setIndex(this.index + n);
            },
            byteAt: function (i) {},
            readInt: function (size) {
              var result = 0,
                i;
              for (
                this.checkOffset(size), i = this.index + size - 1;
                i >= this.index;
                i--
              )
                result = (result << 8) + this.byteAt(i);
              return (this.index += size), result;
            },
            readString: function (size) {
              return utils.transformTo("string", this.readData(size));
            },
            readData: function (size) {},
            lastIndexOfSignature: function (sig) {},
            readDate: function () {
              var dostime = this.readInt(4);
              return new Date(
                1980 + ((dostime >> 25) & 127),
                ((dostime >> 21) & 15) - 1,
                (dostime >> 16) & 31,
                (dostime >> 11) & 31,
                (dostime >> 5) & 63,
                (31 & dostime) << 1
              );
            },
          }),
            (module.exports = DataReader);
        },
        { "./utils": 29 },
      ],
      14: [
        function (require, module, exports) {
          "use strict";
          (exports.base64 = !1),
            (exports.binary = !1),
            (exports.dir = !1),
            (exports.createFolders = !1),
            (exports.date = null),
            (exports.compression = null),
            (exports.compressionOptions = null),
            (exports.comment = null),
            (exports.unixPermissions = null),
            (exports.dosPermissions = null);
        },
        {},
      ],
      15: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./utils");
          (exports.string2binary = function (str) {
            return utils.string2binary(str);
          }),
            (exports.string2Uint8Array = function (str) {
              return utils.transformTo("uint8array", str);
            }),
            (exports.uint8Array2String = function (array) {
              return utils.transformTo("string", array);
            }),
            (exports.string2Blob = function (str) {
              var buffer = utils.transformTo("arraybuffer", str);
              return utils.arrayBuffer2Blob(buffer);
            }),
            (exports.arrayBuffer2Blob = function (buffer) {
              return utils.arrayBuffer2Blob(buffer);
            }),
            (exports.transformTo = function (outputType, input) {
              return utils.transformTo(outputType, input);
            }),
            (exports.getTypeOf = function (input) {
              return utils.getTypeOf(input);
            }),
            (exports.checkSupport = function (type) {
              return utils.checkSupport(type);
            }),
            (exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS),
            (exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS),
            (exports.pretty = function (str) {
              return utils.pretty(str);
            }),
            (exports.findCompression = function (compressionMethod) {
              return utils.findCompression(compressionMethod);
            }),
            (exports.isRegExp = function (object) {
              return utils.isRegExp(object);
            });
        },
        { "./utils": 29 },
      ],
      16: [
        function (require, module, exports) {
          "use strict";
          var USE_TYPEDARRAY =
              "undefined" != typeof Uint8Array &&
              "undefined" != typeof Uint16Array &&
              "undefined" != typeof Uint32Array,
            pako = require("pako");
          (exports.uncompressInputType = USE_TYPEDARRAY
            ? "uint8array"
            : "array"),
            (exports.compressInputType = USE_TYPEDARRAY
              ? "uint8array"
              : "array"),
            (exports.magic = "\b\0"),
            (exports.compress = function (input, compressionOptions) {
              return pako.deflateRaw(input, {
                level: compressionOptions.level || -1,
              });
            }),
            (exports.uncompress = function (input) {
              return pako.inflateRaw(input);
            });
        },
        { pako: 32 },
      ],
      17: [
        function (require, module, exports) {
          "use strict";
          var base64 = require("./base64");
          function JSZip(data, options) {
            if (!(this instanceof JSZip)) return new JSZip(data, options);
            (this.files = {}),
              (this.comment = null),
              (this.root = ""),
              data && this.load(data, options),
              (this.clone = function () {
                var newObj = new JSZip();
                for (var i in this)
                  "function" != typeof this[i] && (newObj[i] = this[i]);
                return newObj;
              });
          }
          (JSZip.prototype = require("./object")),
            (JSZip.prototype.load = require("./load")),
            (JSZip.support = require("./support")),
            (JSZip.defaults = require("./defaults")),
            (JSZip.utils = require("./deprecatedPublicUtils")),
            (JSZip.base64 = {
              encode: function (input) {
                return base64.encode(input);
              },
              decode: function (input) {
                return base64.decode(input);
              },
            }),
            (JSZip.compressions = require("./compressions")),
            (module.exports = JSZip);
        },
        {
          "./base64": 9,
          "./compressions": 11,
          "./defaults": 14,
          "./deprecatedPublicUtils": 15,
          "./load": 18,
          "./object": 21,
          "./support": 25,
        },
      ],
      18: [
        function (require, module, exports) {
          "use strict";
          var base64 = require("./base64"),
            ZipEntries = require("./zipEntries");
          module.exports = function (data, options) {
            var files, zipEntries, i, input;
            for (
              (options = options || {}).base64 && (data = base64.decode(data)),
                files = (zipEntries = new ZipEntries(data, options)).files,
                i = 0;
              i < files.length;
              i++
            )
              (input = files[i]),
                this.file(input.fileName, input.decompressed, {
                  binary: !0,
                  optimizedBinaryString: !0,
                  date: input.date,
                  dir: input.dir,
                  comment: input.fileComment.length ? input.fileComment : null,
                  unixPermissions: input.unixPermissions,
                  dosPermissions: input.dosPermissions,
                  createFolders: options.createFolders,
                });
            return (
              zipEntries.zipComment.length &&
                (this.comment = zipEntries.zipComment),
              this
            );
          };
        },
        { "./base64": 9, "./zipEntries": 30 },
      ],
      19: [
        function (require, module, exports) {
          (function (Buffer) {
            "use strict";
            (module.exports = function (data, encoding) {
              return new Buffer(data, encoding);
            }),
              (module.exports.test = function (b) {
                return Buffer.isBuffer(b);
              });
          }).call(this, require("buffer").Buffer);
        },
        { buffer: 5 },
      ],
      20: [
        function (require, module, exports) {
          "use strict";
          var Uint8ArrayReader = require("./uint8ArrayReader");
          function NodeBufferReader(data) {
            (this.data = data),
              (this.length = this.data.length),
              (this.index = 0);
          }
          (NodeBufferReader.prototype = new Uint8ArrayReader()),
            (NodeBufferReader.prototype.readData = function (size) {
              this.checkOffset(size);
              var result = this.data.slice(this.index, this.index + size);
              return (this.index += size), result;
            }),
            (module.exports = NodeBufferReader);
        },
        { "./uint8ArrayReader": 26 },
      ],
      21: [
        function (require, module, exports) {
          "use strict";
          var support = require("./support"),
            utils = require("./utils"),
            crc32 = require("./crc32"),
            signature = require("./signature"),
            defaults = require("./defaults"),
            base64 = require("./base64"),
            compressions = require("./compressions"),
            CompressedObject = require("./compressedObject"),
            nodeBuffer = require("./nodeBuffer"),
            utf8 = require("./utf8"),
            StringWriter = require("./stringWriter"),
            Uint8ArrayWriter = require("./uint8ArrayWriter"),
            getRawData = function (file) {
              if (
                file._data instanceof CompressedObject &&
                ((file._data = file._data.getContent()),
                (file.options.binary = !0),
                (file.options.base64 = !1),
                "uint8array" === utils.getTypeOf(file._data))
              ) {
                var copy = file._data;
                (file._data = new Uint8Array(copy.length)),
                  0 !== copy.length && file._data.set(copy, 0);
              }
              return file._data;
            },
            getBinaryData = function (file) {
              var result = getRawData(file),
                type;
              return "string" === utils.getTypeOf(result)
                ? !file.options.binary && support.nodebuffer
                  ? nodeBuffer(result, "utf-8")
                  : file.asBinary()
                : result;
            },
            dataToString = function (asUTF8) {
              var result = getRawData(this);
              return null == result
                ? ""
                : (this.options.base64 && (result = base64.decode(result)),
                  (result =
                    asUTF8 && this.options.binary
                      ? out.utf8decode(result)
                      : utils.transformTo("string", result)),
                  asUTF8 ||
                    this.options.binary ||
                    (result = utils.transformTo(
                      "string",
                      out.utf8encode(result)
                    )),
                  result);
            },
            ZipObject = function (name, data, options) {
              (this.name = name),
                (this.dir = options.dir),
                (this.date = options.date),
                (this.comment = options.comment),
                (this.unixPermissions = options.unixPermissions),
                (this.dosPermissions = options.dosPermissions),
                (this._data = data),
                (this.options = options),
                (this._initialMetadata = {
                  dir: options.dir,
                  date: options.date,
                });
            };
          ZipObject.prototype = {
            asText: function () {
              return dataToString.call(this, !0);
            },
            asBinary: function () {
              return dataToString.call(this, !1);
            },
            asNodeBuffer: function () {
              var result = getBinaryData(this);
              return utils.transformTo("nodebuffer", result);
            },
            asUint8Array: function () {
              var result = getBinaryData(this);
              return utils.transformTo("uint8array", result);
            },
            asArrayBuffer: function () {
              return this.asUint8Array().buffer;
            },
          };
          var decToHex = function (dec, bytes) {
              var hex = "",
                i;
              for (i = 0; i < bytes; i++)
                (hex += String.fromCharCode(255 & dec)), (dec >>>= 8);
              return hex;
            },
            extend = function () {
              var result = {},
                i,
                attr;
              for (i = 0; i < arguments.length; i++)
                for (attr in arguments[i])
                  arguments[i].hasOwnProperty(attr) &&
                    void 0 === result[attr] &&
                    (result[attr] = arguments[i][attr]);
              return result;
            },
            prepareFileAttrs = function (o) {
              return (
                !0 !== (o = o || {}).base64 ||
                  (null !== o.binary && void 0 !== o.binary) ||
                  (o.binary = !0),
                ((o = extend(o, defaults)).date = o.date || new Date()),
                null !== o.compression &&
                  (o.compression = o.compression.toUpperCase()),
                o
              );
            },
            fileAdd = function (name, data, o) {
              var dataType = utils.getTypeOf(data),
                parent;
              if (
                ("string" == typeof (o = prepareFileAttrs(o)).unixPermissions &&
                  (o.unixPermissions = parseInt(o.unixPermissions, 8)),
                o.unixPermissions && 16384 & o.unixPermissions && (o.dir = !0),
                o.dosPermissions && 16 & o.dosPermissions && (o.dir = !0),
                o.dir && (name = forceTrailingSlash(name)),
                o.createFolders &&
                  (parent = parentFolder(name)) &&
                  folderAdd.call(this, parent, !0),
                o.dir || null == data)
              )
                (o.base64 = !1),
                  (o.binary = !1),
                  (data = null),
                  (dataType = null);
              else if ("string" === dataType)
                o.binary &&
                  !o.base64 &&
                  !0 !== o.optimizedBinaryString &&
                  (data = utils.string2binary(data));
              else {
                if (
                  ((o.base64 = !1),
                  (o.binary = !0),
                  !(dataType || data instanceof CompressedObject))
                )
                  throw new Error(
                    "The data of '" + name + "' is in an unsupported format !"
                  );
                "arraybuffer" === dataType &&
                  (data = utils.transformTo("uint8array", data));
              }
              var object = new ZipObject(name, data, o);
              return (this.files[name] = object), object;
            },
            parentFolder = function (path) {
              "/" == path.slice(-1) &&
                (path = path.substring(0, path.length - 1));
              var lastSlash = path.lastIndexOf("/");
              return lastSlash > 0 ? path.substring(0, lastSlash) : "";
            },
            forceTrailingSlash = function (path) {
              return "/" != path.slice(-1) && (path += "/"), path;
            },
            folderAdd = function (name, createFolders) {
              return (
                (createFolders = void 0 !== createFolders && createFolders),
                (name = forceTrailingSlash(name)),
                this.files[name] ||
                  fileAdd.call(this, name, null, {
                    dir: !0,
                    createFolders: createFolders,
                  }),
                this.files[name]
              );
            },
            generateCompressedObjectFrom = function (
              file,
              compression,
              compressionOptions
            ) {
              var result = new CompressedObject(),
                content;
              return (
                file._data instanceof CompressedObject
                  ? ((result.uncompressedSize = file._data.uncompressedSize),
                    (result.crc32 = file._data.crc32),
                    0 === result.uncompressedSize || file.dir
                      ? ((compression = compressions.STORE),
                        (result.compressedContent = ""),
                        (result.crc32 = 0))
                      : file._data.compressionMethod === compression.magic
                      ? (result.compressedContent =
                          file._data.getCompressedContent())
                      : ((content = file._data.getContent()),
                        (result.compressedContent = compression.compress(
                          utils.transformTo(
                            compression.compressInputType,
                            content
                          ),
                          compressionOptions
                        ))))
                  : (((content = getBinaryData(file)) &&
                      0 !== content.length &&
                      !file.dir) ||
                      ((compression = compressions.STORE), (content = "")),
                    (result.uncompressedSize = content.length),
                    (result.crc32 = crc32(content)),
                    (result.compressedContent = compression.compress(
                      utils.transformTo(compression.compressInputType, content),
                      compressionOptions
                    ))),
                (result.compressedSize = result.compressedContent.length),
                (result.compressionMethod = compression.magic),
                result
              );
            },
            generateUnixExternalFileAttr = function (unixPermissions, isDir) {
              var result = unixPermissions;
              return (
                unixPermissions || (result = isDir ? 16893 : 33204),
                (65535 & result) << 16
              );
            },
            generateDosExternalFileAttr = function (dosPermissions, isDir) {
              return 63 & (dosPermissions || 0);
            },
            generateZipParts = function (
              name,
              file,
              compressedObject,
              offset,
              platform
            ) {
              var data = compressedObject.compressedContent,
                utfEncodedFileName = utils.transformTo(
                  "string",
                  utf8.utf8encode(file.name)
                ),
                comment = file.comment || "",
                utfEncodedComment = utils.transformTo(
                  "string",
                  utf8.utf8encode(comment)
                ),
                useUTF8ForFileName =
                  utfEncodedFileName.length !== file.name.length,
                useUTF8ForComment = utfEncodedComment.length !== comment.length,
                o = file.options,
                dosTime,
                dosDate,
                extraFields = "",
                unicodePathExtraField = "",
                unicodeCommentExtraField = "",
                dir,
                date;
              (dir = file._initialMetadata.dir !== file.dir ? file.dir : o.dir),
                (date =
                  file._initialMetadata.date !== file.date
                    ? file.date
                    : o.date);
              var extFileAttr = 0,
                versionMadeBy = 0;
              dir && (extFileAttr |= 16),
                "UNIX" === platform
                  ? ((versionMadeBy = 798),
                    (extFileAttr |= generateUnixExternalFileAttr(
                      file.unixPermissions,
                      dir
                    )))
                  : ((versionMadeBy = 20),
                    (extFileAttr |= generateDosExternalFileAttr(
                      file.dosPermissions,
                      dir
                    ))),
                (dosTime = date.getHours()),
                (dosTime <<= 6),
                (dosTime |= date.getMinutes()),
                (dosTime <<= 5),
                (dosTime |= date.getSeconds() / 2),
                (dosDate = date.getFullYear() - 1980),
                (dosDate <<= 4),
                (dosDate |= date.getMonth() + 1),
                (dosDate <<= 5),
                (dosDate |= date.getDate()),
                useUTF8ForFileName &&
                  ((unicodePathExtraField =
                    decToHex(1, 1) +
                    decToHex(crc32(utfEncodedFileName), 4) +
                    utfEncodedFileName),
                  (extraFields +=
                    "up" +
                    decToHex(unicodePathExtraField.length, 2) +
                    unicodePathExtraField)),
                useUTF8ForComment &&
                  ((unicodeCommentExtraField =
                    decToHex(1, 1) +
                    decToHex(this.crc32(utfEncodedComment), 4) +
                    utfEncodedComment),
                  (extraFields +=
                    "uc" +
                    decToHex(unicodeCommentExtraField.length, 2) +
                    unicodeCommentExtraField));
              var header = "",
                fileRecord,
                dirRecord;
              return (
                (header += "\n\0"),
                (header +=
                  useUTF8ForFileName || useUTF8ForComment ? "\0\b" : "\0\0"),
                (header += compressedObject.compressionMethod),
                (header += decToHex(dosTime, 2)),
                (header += decToHex(dosDate, 2)),
                (header += decToHex(compressedObject.crc32, 4)),
                (header += decToHex(compressedObject.compressedSize, 4)),
                (header += decToHex(compressedObject.uncompressedSize, 4)),
                (header += decToHex(utfEncodedFileName.length, 2)),
                (header += decToHex(extraFields.length, 2)),
                {
                  fileRecord:
                    signature.LOCAL_FILE_HEADER +
                    header +
                    utfEncodedFileName +
                    extraFields,
                  dirRecord:
                    signature.CENTRAL_FILE_HEADER +
                    decToHex(versionMadeBy, 2) +
                    header +
                    decToHex(utfEncodedComment.length, 2) +
                    "\0\0\0\0" +
                    decToHex(extFileAttr, 4) +
                    decToHex(offset, 4) +
                    utfEncodedFileName +
                    extraFields +
                    utfEncodedComment,
                  compressedObject: compressedObject,
                }
              );
            },
            out = {
              load: function (stream, options) {
                throw new Error(
                  "Load method is not defined. Is the file jszip-load.js included ?"
                );
              },
              filter: function (search) {
                var result = [],
                  filename,
                  relativePath,
                  file,
                  fileClone;
                for (filename in this.files)
                  this.files.hasOwnProperty(filename) &&
                    ((file = this.files[filename]),
                    (fileClone = new ZipObject(
                      file.name,
                      file._data,
                      extend(file.options)
                    )),
                    (relativePath = filename.slice(
                      this.root.length,
                      filename.length
                    )),
                    filename.slice(0, this.root.length) === this.root &&
                      search(relativePath, fileClone) &&
                      result.push(fileClone));
                return result;
              },
              file: function (name, data, o) {
                if (1 === arguments.length) {
                  if (utils.isRegExp(name)) {
                    var regexp = name;
                    return this.filter(function (relativePath, file) {
                      return !file.dir && regexp.test(relativePath);
                    });
                  }
                  return (
                    this.filter(function (relativePath, file) {
                      return !file.dir && relativePath === name;
                    })[0] || null
                  );
                }
                return (
                  (name = this.root + name),
                  fileAdd.call(this, name, data, o),
                  this
                );
              },
              folder: function (arg) {
                if (!arg) return this;
                if (utils.isRegExp(arg))
                  return this.filter(function (relativePath, file) {
                    return file.dir && arg.test(relativePath);
                  });
                var name = this.root + arg,
                  newFolder = folderAdd.call(this, name),
                  ret = this.clone();
                return (ret.root = newFolder.name), ret;
              },
              remove: function (name) {
                name = this.root + name;
                var file = this.files[name];
                if (
                  (file ||
                    ("/" != name.slice(-1) && (name += "/"),
                    (file = this.files[name])),
                  file && !file.dir)
                )
                  delete this.files[name];
                else
                  for (
                    var kids = this.filter(function (relativePath, file) {
                        return file.name.slice(0, name.length) === name;
                      }),
                      i = 0;
                    i < kids.length;
                    i++
                  )
                    delete this.files[kids[i].name];
                return this;
              },
              generate: function (options) {
                (options = extend(options || {}, {
                  base64: !0,
                  compression: "STORE",
                  compressionOptions: null,
                  type: "base64",
                  platform: "DOS",
                  comment: null,
                  mimeType: "application/zip",
                })),
                  utils.checkSupport(options.type),
                  ("darwin" !== options.platform &&
                    "freebsd" !== options.platform &&
                    "linux" !== options.platform &&
                    "sunos" !== options.platform) ||
                    (options.platform = "UNIX"),
                  "win32" === options.platform && (options.platform = "DOS");
                var zipData = [],
                  localDirLength = 0,
                  centralDirLength = 0,
                  writer,
                  i,
                  utfEncodedComment = utils.transformTo(
                    "string",
                    this.utf8encode(options.comment || this.comment || "")
                  );
                for (var name in this.files)
                  if (this.files.hasOwnProperty(name)) {
                    var file = this.files[name],
                      compressionName =
                        file.options.compression ||
                        options.compression.toUpperCase(),
                      compression = compressions[compressionName];
                    if (!compression)
                      throw new Error(
                        compressionName + " is not a valid compression method !"
                      );
                    var compressionOptions =
                        file.options.compressionOptions ||
                        options.compressionOptions ||
                        {},
                      compressedObject = generateCompressedObjectFrom.call(
                        this,
                        file,
                        compression,
                        compressionOptions
                      ),
                      zipPart = generateZipParts.call(
                        this,
                        name,
                        file,
                        compressedObject,
                        localDirLength,
                        options.platform
                      );
                    (localDirLength +=
                      zipPart.fileRecord.length +
                      compressedObject.compressedSize),
                      (centralDirLength += zipPart.dirRecord.length),
                      zipData.push(zipPart);
                  }
                var dirEnd = "";
                dirEnd =
                  signature.CENTRAL_DIRECTORY_END +
                  "\0\0\0\0" +
                  decToHex(zipData.length, 2) +
                  decToHex(zipData.length, 2) +
                  decToHex(centralDirLength, 4) +
                  decToHex(localDirLength, 4) +
                  decToHex(utfEncodedComment.length, 2) +
                  utfEncodedComment;
                var typeName = options.type.toLowerCase();
                for (
                  writer =
                    "uint8array" === typeName ||
                    "arraybuffer" === typeName ||
                    "blob" === typeName ||
                    "nodebuffer" === typeName
                      ? new Uint8ArrayWriter(
                          localDirLength + centralDirLength + dirEnd.length
                        )
                      : new StringWriter(
                          localDirLength + centralDirLength + dirEnd.length
                        ),
                    i = 0;
                  i < zipData.length;
                  i++
                )
                  writer.append(zipData[i].fileRecord),
                    writer.append(
                      zipData[i].compressedObject.compressedContent
                    );
                for (i = 0; i < zipData.length; i++)
                  writer.append(zipData[i].dirRecord);
                writer.append(dirEnd);
                var zip = writer.finalize();
                switch (options.type.toLowerCase()) {
                  case "uint8array":
                  case "arraybuffer":
                  case "nodebuffer":
                    return utils.transformTo(options.type.toLowerCase(), zip);
                  case "blob":
                    return utils.arrayBuffer2Blob(
                      utils.transformTo("arraybuffer", zip),
                      options.mimeType
                    );
                  case "base64":
                    return options.base64 ? base64.encode(zip) : zip;
                  default:
                    return zip;
                }
              },
              crc32: function (input, crc) {
                return crc32(input, crc);
              },
              utf8encode: function (string) {
                return utils.transformTo("string", utf8.utf8encode(string));
              },
              utf8decode: function (input) {
                return utf8.utf8decode(input);
              },
            };
          module.exports = out;
        },
        {
          "./base64": 9,
          "./compressedObject": 10,
          "./compressions": 11,
          "./crc32": 12,
          "./defaults": 14,
          "./nodeBuffer": 19,
          "./signature": 22,
          "./stringWriter": 24,
          "./support": 25,
          "./uint8ArrayWriter": 27,
          "./utf8": 28,
          "./utils": 29,
        },
      ],
      22: [
        function (require, module, exports) {
          "use strict";
          (exports.LOCAL_FILE_HEADER = "PK"),
            (exports.CENTRAL_FILE_HEADER = "PK"),
            (exports.CENTRAL_DIRECTORY_END = "PK"),
            (exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK"),
            (exports.ZIP64_CENTRAL_DIRECTORY_END = "PK"),
            (exports.DATA_DESCRIPTOR = "PK\b");
        },
        {},
      ],
      23: [
        function (require, module, exports) {
          "use strict";
          var DataReader = require("./dataReader"),
            utils = require("./utils");
          function StringReader(data, optimizedBinaryString) {
            (this.data = data),
              optimizedBinaryString ||
                (this.data = utils.string2binary(this.data)),
              (this.length = this.data.length),
              (this.index = 0);
          }
          (StringReader.prototype = new DataReader()),
            (StringReader.prototype.byteAt = function (i) {
              return this.data.charCodeAt(i);
            }),
            (StringReader.prototype.lastIndexOfSignature = function (sig) {
              return this.data.lastIndexOf(sig);
            }),
            (StringReader.prototype.readData = function (size) {
              this.checkOffset(size);
              var result = this.data.slice(this.index, this.index + size);
              return (this.index += size), result;
            }),
            (module.exports = StringReader);
        },
        { "./dataReader": 13, "./utils": 29 },
      ],
      24: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./utils"),
            StringWriter = function () {
              this.data = [];
            };
          (StringWriter.prototype = {
            append: function (input) {
              (input = utils.transformTo("string", input)),
                this.data.push(input);
            },
            finalize: function () {
              return this.data.join("");
            },
          }),
            (module.exports = StringWriter);
        },
        { "./utils": 29 },
      ],
      25: [
        function (require, module, exports) {
          (function (Buffer) {
            "use strict";
            if (
              ((exports.base64 = !0),
              (exports.array = !0),
              (exports.string = !0),
              (exports.arraybuffer =
                "undefined" != typeof ArrayBuffer &&
                "undefined" != typeof Uint8Array),
              (exports.nodebuffer = void 0 !== Buffer),
              (exports.uint8array = "undefined" != typeof Uint8Array),
              "undefined" == typeof ArrayBuffer)
            )
              exports.blob = !1;
            else {
              var buffer = new ArrayBuffer(0);
              try {
                exports.blob =
                  0 === new Blob([buffer], { type: "application/zip" }).size;
              } catch (e) {
                try {
                  var Builder,
                    builder = new (window.BlobBuilder ||
                      window.WebKitBlobBuilder ||
                      window.MozBlobBuilder ||
                      window.MSBlobBuilder)();
                  builder.append(buffer),
                    (exports.blob =
                      0 === builder.getBlob("application/zip").size);
                } catch (e) {
                  exports.blob = !1;
                }
              }
            }
          }).call(this, require("buffer").Buffer);
        },
        { buffer: 5 },
      ],
      26: [
        function (require, module, exports) {
          "use strict";
          var DataReader = require("./dataReader");
          function Uint8ArrayReader(data) {
            data &&
              ((this.data = data),
              (this.length = this.data.length),
              (this.index = 0));
          }
          (Uint8ArrayReader.prototype = new DataReader()),
            (Uint8ArrayReader.prototype.byteAt = function (i) {
              return this.data[i];
            }),
            (Uint8ArrayReader.prototype.lastIndexOfSignature = function (sig) {
              for (
                var sig0 = sig.charCodeAt(0),
                  sig1 = sig.charCodeAt(1),
                  sig2 = sig.charCodeAt(2),
                  sig3 = sig.charCodeAt(3),
                  i = this.length - 4;
                i >= 0;
                --i
              )
                if (
                  this.data[i] === sig0 &&
                  this.data[i + 1] === sig1 &&
                  this.data[i + 2] === sig2 &&
                  this.data[i + 3] === sig3
                )
                  return i;
              return -1;
            }),
            (Uint8ArrayReader.prototype.readData = function (size) {
              if ((this.checkOffset(size), 0 === size))
                return new Uint8Array(0);
              var result = this.data.subarray(this.index, this.index + size);
              return (this.index += size), result;
            }),
            (module.exports = Uint8ArrayReader);
        },
        { "./dataReader": 13 },
      ],
      27: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./utils"),
            Uint8ArrayWriter = function (length) {
              (this.data = new Uint8Array(length)), (this.index = 0);
            };
          (Uint8ArrayWriter.prototype = {
            append: function (input) {
              0 !== input.length &&
                ((input = utils.transformTo("uint8array", input)),
                this.data.set(input, this.index),
                (this.index += input.length));
            },
            finalize: function () {
              return this.data;
            },
          }),
            (module.exports = Uint8ArrayWriter);
        },
        { "./utils": 29 },
      ],
      28: [
        function (require, module, exports) {
          "use strict";
          for (
            var utils = require("./utils"),
              support = require("./support"),
              nodeBuffer = require("./nodeBuffer"),
              _utf8len = new Array(256),
              i = 0;
            i < 256;
            i++
          )
            _utf8len[i] =
              i >= 252
                ? 6
                : i >= 248
                ? 5
                : i >= 240
                ? 4
                : i >= 224
                ? 3
                : i >= 192
                ? 2
                : 1;
          _utf8len[254] = _utf8len[254] = 1;
          var string2buf = function (str) {
              var buf,
                c,
                c2,
                m_pos,
                i,
                str_len = str.length,
                buf_len = 0;
              for (m_pos = 0; m_pos < str_len; m_pos++)
                55296 == (64512 & (c = str.charCodeAt(m_pos))) &&
                  m_pos + 1 < str_len &&
                  56320 == (64512 & (c2 = str.charCodeAt(m_pos + 1))) &&
                  ((c = 65536 + ((c - 55296) << 10) + (c2 - 56320)), m_pos++),
                  (buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4);
              for (
                buf = support.uint8array
                  ? new Uint8Array(buf_len)
                  : new Array(buf_len),
                  i = 0,
                  m_pos = 0;
                i < buf_len;
                m_pos++
              )
                55296 == (64512 & (c = str.charCodeAt(m_pos))) &&
                  m_pos + 1 < str_len &&
                  56320 == (64512 & (c2 = str.charCodeAt(m_pos + 1))) &&
                  ((c = 65536 + ((c - 55296) << 10) + (c2 - 56320)), m_pos++),
                  c < 128
                    ? (buf[i++] = c)
                    : c < 2048
                    ? ((buf[i++] = 192 | (c >>> 6)),
                      (buf[i++] = 128 | (63 & c)))
                    : c < 65536
                    ? ((buf[i++] = 224 | (c >>> 12)),
                      (buf[i++] = 128 | ((c >>> 6) & 63)),
                      (buf[i++] = 128 | (63 & c)))
                    : ((buf[i++] = 240 | (c >>> 18)),
                      (buf[i++] = 128 | ((c >>> 12) & 63)),
                      (buf[i++] = 128 | ((c >>> 6) & 63)),
                      (buf[i++] = 128 | (63 & c)));
              return buf;
            },
            utf8border = function (buf, max) {
              var pos;
              for (
                (max = max || buf.length) > buf.length && (max = buf.length),
                  pos = max - 1;
                pos >= 0 && 128 == (192 & buf[pos]);

              )
                pos--;
              return pos < 0
                ? max
                : 0 === pos
                ? max
                : pos + _utf8len[buf[pos]] > max
                ? pos
                : max;
            },
            buf2string = function (buf) {
              var str,
                i,
                out,
                c,
                c_len,
                len = buf.length,
                utf16buf = new Array(2 * len);
              for (out = 0, i = 0; i < len; )
                if ((c = buf[i++]) < 128) utf16buf[out++] = c;
                else if ((c_len = _utf8len[c]) > 4)
                  (utf16buf[out++] = 65533), (i += c_len - 1);
                else {
                  for (
                    c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7;
                    c_len > 1 && i < len;

                  )
                    (c = (c << 6) | (63 & buf[i++])), c_len--;
                  c_len > 1
                    ? (utf16buf[out++] = 65533)
                    : c < 65536
                    ? (utf16buf[out++] = c)
                    : ((c -= 65536),
                      (utf16buf[out++] = 55296 | ((c >> 10) & 1023)),
                      (utf16buf[out++] = 56320 | (1023 & c)));
                }
              return (
                utf16buf.length !== out &&
                  (utf16buf.subarray
                    ? (utf16buf = utf16buf.subarray(0, out))
                    : (utf16buf.length = out)),
                utils.applyFromCharCode(utf16buf)
              );
            };
          (exports.utf8encode = function utf8encode(str) {
            return support.nodebuffer
              ? nodeBuffer(str, "utf-8")
              : string2buf(str);
          }),
            (exports.utf8decode = function utf8decode(buf) {
              if (support.nodebuffer)
                return utils.transformTo("nodebuffer", buf).toString("utf-8");
              for (
                var result = [],
                  k = 0,
                  len = (buf = utils.transformTo(
                    support.uint8array ? "uint8array" : "array",
                    buf
                  )).length,
                  chunk = 65536;
                k < len;

              ) {
                var nextBoundary = utf8border(buf, Math.min(k + 65536, len));
                support.uint8array
                  ? result.push(buf2string(buf.subarray(k, nextBoundary)))
                  : result.push(buf2string(buf.slice(k, nextBoundary))),
                  (k = nextBoundary);
              }
              return result.join("");
            });
        },
        { "./nodeBuffer": 19, "./support": 25, "./utils": 29 },
      ],
      29: [
        function (require, module, exports) {
          "use strict";
          var support = require("./support"),
            compressions = require("./compressions"),
            nodeBuffer = require("./nodeBuffer");
          function identity(input) {
            return input;
          }
          function stringToArrayLike(str, array) {
            for (var i = 0; i < str.length; ++i)
              array[i] = 255 & str.charCodeAt(i);
            return array;
          }
          function arrayLikeToString(array) {
            var chunk = 65536,
              result = [],
              len = array.length,
              type = exports.getTypeOf(array),
              k = 0,
              canUseApply = !0;
            try {
              switch (type) {
                case "uint8array":
                  String.fromCharCode.apply(null, new Uint8Array(0));
                  break;
                case "nodebuffer":
                  String.fromCharCode.apply(null, nodeBuffer(0));
              }
            } catch (e) {
              canUseApply = !1;
            }
            if (!canUseApply) {
              for (var resultStr = "", i = 0; i < array.length; i++)
                resultStr += String.fromCharCode(array[i]);
              return resultStr;
            }
            for (; k < len && chunk > 1; )
              try {
                "array" === type || "nodebuffer" === type
                  ? result.push(
                      String.fromCharCode.apply(
                        null,
                        array.slice(k, Math.min(k + chunk, len))
                      )
                    )
                  : result.push(
                      String.fromCharCode.apply(
                        null,
                        array.subarray(k, Math.min(k + chunk, len))
                      )
                    ),
                  (k += chunk);
              } catch (e) {
                chunk = Math.floor(chunk / 2);
              }
            return result.join("");
          }
          function arrayLikeToArrayLike(arrayFrom, arrayTo) {
            for (var i = 0; i < arrayFrom.length; i++)
              arrayTo[i] = arrayFrom[i];
            return arrayTo;
          }
          (exports.string2binary = function (str) {
            for (var result = "", i = 0; i < str.length; i++)
              result += String.fromCharCode(255 & str.charCodeAt(i));
            return result;
          }),
            (exports.arrayBuffer2Blob = function (buffer, mimeType) {
              exports.checkSupport("blob"),
                (mimeType = mimeType || "application/zip");
              try {
                return new Blob([buffer], { type: mimeType });
              } catch (e) {
                try {
                  var Builder,
                    builder = new (window.BlobBuilder ||
                      window.WebKitBlobBuilder ||
                      window.MozBlobBuilder ||
                      window.MSBlobBuilder)();
                  return builder.append(buffer), builder.getBlob(mimeType);
                } catch (e) {
                  throw new Error("Bug : can't construct the Blob.");
                }
              }
            }),
            (exports.applyFromCharCode = arrayLikeToString);
          var transform = {};
          (transform.string = {
            string: identity,
            array: function (input) {
              return stringToArrayLike(input, new Array(input.length));
            },
            arraybuffer: function (input) {
              return transform.string.uint8array(input).buffer;
            },
            uint8array: function (input) {
              return stringToArrayLike(input, new Uint8Array(input.length));
            },
            nodebuffer: function (input) {
              return stringToArrayLike(input, nodeBuffer(input.length));
            },
          }),
            (transform.array = {
              string: arrayLikeToString,
              array: identity,
              arraybuffer: function (input) {
                return new Uint8Array(input).buffer;
              },
              uint8array: function (input) {
                return new Uint8Array(input);
              },
              nodebuffer: function (input) {
                return nodeBuffer(input);
              },
            }),
            (transform.arraybuffer = {
              string: function (input) {
                return arrayLikeToString(new Uint8Array(input));
              },
              array: function (input) {
                return arrayLikeToArrayLike(
                  new Uint8Array(input),
                  new Array(input.byteLength)
                );
              },
              arraybuffer: identity,
              uint8array: function (input) {
                return new Uint8Array(input);
              },
              nodebuffer: function (input) {
                return nodeBuffer(new Uint8Array(input));
              },
            }),
            (transform.uint8array = {
              string: arrayLikeToString,
              array: function (input) {
                return arrayLikeToArrayLike(input, new Array(input.length));
              },
              arraybuffer: function (input) {
                return input.buffer;
              },
              uint8array: identity,
              nodebuffer: function (input) {
                return nodeBuffer(input);
              },
            }),
            (transform.nodebuffer = {
              string: arrayLikeToString,
              array: function (input) {
                return arrayLikeToArrayLike(input, new Array(input.length));
              },
              arraybuffer: function (input) {
                return transform.nodebuffer.uint8array(input).buffer;
              },
              uint8array: function (input) {
                return arrayLikeToArrayLike(
                  input,
                  new Uint8Array(input.length)
                );
              },
              nodebuffer: identity,
            }),
            (exports.transformTo = function (outputType, input) {
              if ((input || (input = ""), !outputType)) return input;
              exports.checkSupport(outputType);
              var inputType = exports.getTypeOf(input),
                result;
              return transform[inputType][outputType](input);
            }),
            (exports.getTypeOf = function (input) {
              return "string" == typeof input
                ? "string"
                : "[object Array]" === Object.prototype.toString.call(input)
                ? "array"
                : support.nodebuffer && nodeBuffer.test(input)
                ? "nodebuffer"
                : support.uint8array && input instanceof Uint8Array
                ? "uint8array"
                : support.arraybuffer && input instanceof ArrayBuffer
                ? "arraybuffer"
                : void 0;
            }),
            (exports.checkSupport = function (type) {
              var supported;
              if (!support[type.toLowerCase()])
                throw new Error(type + " is not supported by this browser");
            }),
            (exports.MAX_VALUE_16BITS = 65535),
            (exports.MAX_VALUE_32BITS = -1),
            (exports.pretty = function (str) {
              var res = "",
                code,
                i;
              for (i = 0; i < (str || "").length; i++)
                res +=
                  "\\x" +
                  ((code = str.charCodeAt(i)) < 16 ? "0" : "") +
                  code.toString(16).toUpperCase();
              return res;
            }),
            (exports.findCompression = function (compressionMethod) {
              for (var method in compressions)
                if (
                  compressions.hasOwnProperty(method) &&
                  compressions[method].magic === compressionMethod
                )
                  return compressions[method];
              return null;
            }),
            (exports.isRegExp = function (object) {
              return (
                "[object RegExp]" === Object.prototype.toString.call(object)
              );
            });
        },
        { "./compressions": 11, "./nodeBuffer": 19, "./support": 25 },
      ],
      30: [
        function (require, module, exports) {
          "use strict";
          var StringReader = require("./stringReader"),
            NodeBufferReader = require("./nodeBufferReader"),
            Uint8ArrayReader = require("./uint8ArrayReader"),
            utils = require("./utils"),
            sig = require("./signature"),
            ZipEntry = require("./zipEntry"),
            support = require("./support"),
            jszipProto = require("./object");
          function ZipEntries(data, loadOptions) {
            (this.files = []),
              (this.loadOptions = loadOptions),
              data && this.load(data);
          }
          (ZipEntries.prototype = {
            checkSignature: function (expectedSignature) {
              var signature = this.reader.readString(4);
              if (signature !== expectedSignature)
                throw new Error(
                  "Corrupted zip or bug : unexpected signature (" +
                    utils.pretty(signature) +
                    ", expected " +
                    utils.pretty(expectedSignature) +
                    ")"
                );
            },
            readBlockEndOfCentral: function () {
              (this.diskNumber = this.reader.readInt(2)),
                (this.diskWithCentralDirStart = this.reader.readInt(2)),
                (this.centralDirRecordsOnThisDisk = this.reader.readInt(2)),
                (this.centralDirRecords = this.reader.readInt(2)),
                (this.centralDirSize = this.reader.readInt(4)),
                (this.centralDirOffset = this.reader.readInt(4)),
                (this.zipCommentLength = this.reader.readInt(2)),
                (this.zipComment = this.reader.readString(
                  this.zipCommentLength
                )),
                (this.zipComment = jszipProto.utf8decode(this.zipComment));
            },
            readBlockZip64EndOfCentral: function () {
              (this.zip64EndOfCentralSize = this.reader.readInt(8)),
                (this.versionMadeBy = this.reader.readString(2)),
                (this.versionNeeded = this.reader.readInt(2)),
                (this.diskNumber = this.reader.readInt(4)),
                (this.diskWithCentralDirStart = this.reader.readInt(4)),
                (this.centralDirRecordsOnThisDisk = this.reader.readInt(8)),
                (this.centralDirRecords = this.reader.readInt(8)),
                (this.centralDirSize = this.reader.readInt(8)),
                (this.centralDirOffset = this.reader.readInt(8)),
                (this.zip64ExtensibleData = {});
              for (
                var extraDataSize = this.zip64EndOfCentralSize - 44,
                  index = 0,
                  extraFieldId,
                  extraFieldLength,
                  extraFieldValue;
                0 < extraDataSize;

              )
                (extraFieldId = this.reader.readInt(2)),
                  (extraFieldLength = this.reader.readInt(4)),
                  (extraFieldValue = this.reader.readString(extraFieldLength)),
                  (this.zip64ExtensibleData[extraFieldId] = {
                    id: extraFieldId,
                    length: extraFieldLength,
                    value: extraFieldValue,
                  });
            },
            readBlockZip64EndOfCentralLocator: function () {
              if (
                ((this.diskWithZip64CentralDirStart = this.reader.readInt(4)),
                (this.relativeOffsetEndOfZip64CentralDir =
                  this.reader.readInt(8)),
                (this.disksCount = this.reader.readInt(4)),
                this.disksCount > 1)
              )
                throw new Error("Multi-volumes zip are not supported");
            },
            readLocalFiles: function () {
              var i, file;
              for (i = 0; i < this.files.length; i++)
                (file = this.files[i]),
                  this.reader.setIndex(file.localHeaderOffset),
                  this.checkSignature(sig.LOCAL_FILE_HEADER),
                  file.readLocalPart(this.reader),
                  file.handleUTF8(),
                  file.processAttributes();
            },
            readCentralDir: function () {
              var file;
              for (
                this.reader.setIndex(this.centralDirOffset);
                this.reader.readString(4) === sig.CENTRAL_FILE_HEADER;

              )
                (file = new ZipEntry(
                  { zip64: this.zip64 },
                  this.loadOptions
                )).readCentralPart(this.reader),
                  this.files.push(file);
            },
            readEndOfCentral: function () {
              var offset = this.reader.lastIndexOfSignature(
                sig.CENTRAL_DIRECTORY_END
              );
              if (-1 === offset) {
                var isGarbage = !0;
                try {
                  this.reader.setIndex(0),
                    this.checkSignature(sig.LOCAL_FILE_HEADER),
                    (isGarbage = !1);
                } catch (e) {}
                throw isGarbage
                  ? new Error(
                      "Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html"
                    )
                  : new Error(
                      "Corrupted zip : can't find end of central directory"
                    );
              }
              if (
                (this.reader.setIndex(offset),
                this.checkSignature(sig.CENTRAL_DIRECTORY_END),
                this.readBlockEndOfCentral(),
                this.diskNumber === utils.MAX_VALUE_16BITS ||
                  this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS ||
                  this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS ||
                  this.centralDirRecords === utils.MAX_VALUE_16BITS ||
                  this.centralDirSize === utils.MAX_VALUE_32BITS ||
                  this.centralDirOffset === utils.MAX_VALUE_32BITS)
              ) {
                if (
                  ((this.zip64 = !0),
                  -1 ===
                    (offset = this.reader.lastIndexOfSignature(
                      sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR
                    )))
                )
                  throw new Error(
                    "Corrupted zip : can't find the ZIP64 end of central directory locator"
                  );
                this.reader.setIndex(offset),
                  this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR),
                  this.readBlockZip64EndOfCentralLocator(),
                  this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),
                  this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END),
                  this.readBlockZip64EndOfCentral();
              }
            },
            prepareReader: function (data) {
              var type = utils.getTypeOf(data);
              "string" !== type || support.uint8array
                ? (this.reader =
                    "nodebuffer" === type
                      ? new NodeBufferReader(data)
                      : new Uint8ArrayReader(
                          utils.transformTo("uint8array", data)
                        ))
                : (this.reader = new StringReader(
                    data,
                    this.loadOptions.optimizedBinaryString
                  ));
            },
            load: function (data) {
              this.prepareReader(data),
                this.readEndOfCentral(),
                this.readCentralDir(),
                this.readLocalFiles();
            },
          }),
            (module.exports = ZipEntries);
        },
        {
          "./nodeBufferReader": 20,
          "./object": 21,
          "./signature": 22,
          "./stringReader": 23,
          "./support": 25,
          "./uint8ArrayReader": 26,
          "./utils": 29,
          "./zipEntry": 31,
        },
      ],
      31: [
        function (require, module, exports) {
          "use strict";
          var StringReader = require("./stringReader"),
            utils = require("./utils"),
            CompressedObject = require("./compressedObject"),
            jszipProto = require("./object"),
            MADE_BY_DOS = 0,
            MADE_BY_UNIX = 3;
          function ZipEntry(options, loadOptions) {
            (this.options = options), (this.loadOptions = loadOptions);
          }
          (ZipEntry.prototype = {
            isEncrypted: function () {
              return 1 == (1 & this.bitFlag);
            },
            useUTF8: function () {
              return 2048 == (2048 & this.bitFlag);
            },
            prepareCompressedContent: function (reader, from, length) {
              return function () {
                var previousIndex = reader.index;
                reader.setIndex(from);
                var compressedFileData = reader.readData(length);
                return reader.setIndex(previousIndex), compressedFileData;
              };
            },
            prepareContent: function (
              reader,
              from,
              length,
              compression,
              uncompressedSize
            ) {
              return function () {
                var compressedFileData = utils.transformTo(
                    compression.uncompressInputType,
                    this.getCompressedContent()
                  ),
                  uncompressedFileData =
                    compression.uncompress(compressedFileData);
                if (uncompressedFileData.length !== uncompressedSize)
                  throw new Error("Bug : uncompressed data size mismatch");
                return uncompressedFileData;
              };
            },
            readLocalPart: function (reader) {
              var compression, localExtraFieldsLength;
              if (
                (reader.skip(22),
                (this.fileNameLength = reader.readInt(2)),
                (localExtraFieldsLength = reader.readInt(2)),
                (this.fileName = reader.readString(this.fileNameLength)),
                reader.skip(localExtraFieldsLength),
                -1 == this.compressedSize || -1 == this.uncompressedSize)
              )
                throw new Error(
                  "Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)"
                );
              if (
                null ===
                (compression = utils.findCompression(this.compressionMethod))
              )
                throw new Error(
                  "Corrupted zip : compression " +
                    utils.pretty(this.compressionMethod) +
                    " unknown (inner file : " +
                    this.fileName +
                    ")"
                );
              if (
                ((this.decompressed = new CompressedObject()),
                (this.decompressed.compressedSize = this.compressedSize),
                (this.decompressed.uncompressedSize = this.uncompressedSize),
                (this.decompressed.crc32 = this.crc32),
                (this.decompressed.compressionMethod = this.compressionMethod),
                (this.decompressed.getCompressedContent =
                  this.prepareCompressedContent(
                    reader,
                    reader.index,
                    this.compressedSize,
                    compression
                  )),
                (this.decompressed.getContent = this.prepareContent(
                  reader,
                  reader.index,
                  this.compressedSize,
                  compression,
                  this.uncompressedSize
                )),
                this.loadOptions.checkCRC32 &&
                  ((this.decompressed = utils.transformTo(
                    "string",
                    this.decompressed.getContent()
                  )),
                  jszipProto.crc32(this.decompressed) !== this.crc32))
              )
                throw new Error("Corrupted zip : CRC32 mismatch");
            },
            readCentralPart: function (reader) {
              if (
                ((this.versionMadeBy = reader.readInt(2)),
                (this.versionNeeded = reader.readInt(2)),
                (this.bitFlag = reader.readInt(2)),
                (this.compressionMethod = reader.readString(2)),
                (this.date = reader.readDate()),
                (this.crc32 = reader.readInt(4)),
                (this.compressedSize = reader.readInt(4)),
                (this.uncompressedSize = reader.readInt(4)),
                (this.fileNameLength = reader.readInt(2)),
                (this.extraFieldsLength = reader.readInt(2)),
                (this.fileCommentLength = reader.readInt(2)),
                (this.diskNumberStart = reader.readInt(2)),
                (this.internalFileAttributes = reader.readInt(2)),
                (this.externalFileAttributes = reader.readInt(4)),
                (this.localHeaderOffset = reader.readInt(4)),
                this.isEncrypted())
              )
                throw new Error("Encrypted zip are not supported");
              (this.fileName = reader.readString(this.fileNameLength)),
                this.readExtraFields(reader),
                this.parseZIP64ExtraField(reader),
                (this.fileComment = reader.readString(this.fileCommentLength));
            },
            processAttributes: function () {
              (this.unixPermissions = null), (this.dosPermissions = null);
              var madeBy = this.versionMadeBy >> 8;
              (this.dir = !!(16 & this.externalFileAttributes)),
                0 === madeBy &&
                  (this.dosPermissions = 63 & this.externalFileAttributes),
                3 === madeBy &&
                  (this.unixPermissions =
                    (this.externalFileAttributes >> 16) & 65535),
                this.dir || "/" !== this.fileName.slice(-1) || (this.dir = !0);
            },
            parseZIP64ExtraField: function (reader) {
              if (this.extraFields[1]) {
                var extraReader = new StringReader(this.extraFields[1].value);
                this.uncompressedSize === utils.MAX_VALUE_32BITS &&
                  (this.uncompressedSize = extraReader.readInt(8)),
                  this.compressedSize === utils.MAX_VALUE_32BITS &&
                    (this.compressedSize = extraReader.readInt(8)),
                  this.localHeaderOffset === utils.MAX_VALUE_32BITS &&
                    (this.localHeaderOffset = extraReader.readInt(8)),
                  this.diskNumberStart === utils.MAX_VALUE_32BITS &&
                    (this.diskNumberStart = extraReader.readInt(4));
              }
            },
            readExtraFields: function (reader) {
              var start = reader.index,
                extraFieldId,
                extraFieldLength,
                extraFieldValue;
              for (
                this.extraFields = this.extraFields || {};
                reader.index < start + this.extraFieldsLength;

              )
                (extraFieldId = reader.readInt(2)),
                  (extraFieldLength = reader.readInt(2)),
                  (extraFieldValue = reader.readString(extraFieldLength)),
                  (this.extraFields[extraFieldId] = {
                    id: extraFieldId,
                    length: extraFieldLength,
                    value: extraFieldValue,
                  });
            },
            handleUTF8: function () {
              if (this.useUTF8())
                (this.fileName = jszipProto.utf8decode(this.fileName)),
                  (this.fileComment = jszipProto.utf8decode(this.fileComment));
              else {
                var upath = this.findExtraFieldUnicodePath();
                null !== upath && (this.fileName = upath);
                var ucomment = this.findExtraFieldUnicodeComment();
                null !== ucomment && (this.fileComment = ucomment);
              }
            },
            findExtraFieldUnicodePath: function () {
              var upathField = this.extraFields[28789];
              if (upathField) {
                var extraReader = new StringReader(upathField.value);
                return 1 !== extraReader.readInt(1)
                  ? null
                  : jszipProto.crc32(this.fileName) !== extraReader.readInt(4)
                  ? null
                  : jszipProto.utf8decode(
                      extraReader.readString(upathField.length - 5)
                    );
              }
              return null;
            },
            findExtraFieldUnicodeComment: function () {
              var ucommentField = this.extraFields[25461];
              if (ucommentField) {
                var extraReader = new StringReader(ucommentField.value);
                return 1 !== extraReader.readInt(1)
                  ? null
                  : jszipProto.crc32(this.fileComment) !==
                    extraReader.readInt(4)
                  ? null
                  : jszipProto.utf8decode(
                      extraReader.readString(ucommentField.length - 5)
                    );
              }
              return null;
            },
          }),
            (module.exports = ZipEntry);
        },
        {
          "./compressedObject": 10,
          "./object": 21,
          "./stringReader": 23,
          "./utils": 29,
        },
      ],
      32: [
        function (require, module, exports) {
          "use strict";
          var assign,
            deflate,
            inflate,
            constants,
            pako = {};
          (0, require("./lib/utils/common").assign)(
            pako,
            require("./lib/deflate"),
            require("./lib/inflate"),
            require("./lib/zlib/constants")
          ),
            (module.exports = pako);
        },
        {
          "./lib/deflate": 33,
          "./lib/inflate": 34,
          "./lib/utils/common": 35,
          "./lib/zlib/constants": 38,
        },
      ],
      33: [
        function (require, module, exports) {
          "use strict";
          var zlib_deflate = require("./zlib/deflate.js"),
            utils = require("./utils/common"),
            strings = require("./utils/strings"),
            msg = require("./zlib/messages"),
            zstream = require("./zlib/zstream"),
            toString = Object.prototype.toString,
            Z_NO_FLUSH = 0,
            Z_FINISH = 4,
            Z_OK = 0,
            Z_STREAM_END = 1,
            Z_SYNC_FLUSH = 2,
            Z_DEFAULT_COMPRESSION = -1,
            Z_DEFAULT_STRATEGY = 0,
            Z_DEFLATED = 8,
            Deflate = function (options) {
              this.options = utils.assign(
                {
                  level: -1,
                  method: 8,
                  chunkSize: 16384,
                  windowBits: 15,
                  memLevel: 8,
                  strategy: 0,
                  to: "",
                },
                options || {}
              );
              var opt = this.options;
              opt.raw && opt.windowBits > 0
                ? (opt.windowBits = -opt.windowBits)
                : opt.gzip &&
                  opt.windowBits > 0 &&
                  opt.windowBits < 16 &&
                  (opt.windowBits += 16),
                (this.err = 0),
                (this.msg = ""),
                (this.ended = !1),
                (this.chunks = []),
                (this.strm = new zstream()),
                (this.strm.avail_out = 0);
              var status = zlib_deflate.deflateInit2(
                this.strm,
                opt.level,
                opt.method,
                opt.windowBits,
                opt.memLevel,
                opt.strategy
              );
              if (0 !== status) throw new Error(msg[status]);
              opt.header &&
                zlib_deflate.deflateSetHeader(this.strm, opt.header);
            };
          function deflate(input, options) {
            var deflator = new Deflate(options);
            if ((deflator.push(input, !0), deflator.err)) throw deflator.msg;
            return deflator.result;
          }
          function deflateRaw(input, options) {
            return (
              ((options = options || {}).raw = !0), deflate(input, options)
            );
          }
          function gzip(input, options) {
            return (
              ((options = options || {}).gzip = !0), deflate(input, options)
            );
          }
          (Deflate.prototype.push = function (data, mode) {
            var strm = this.strm,
              chunkSize = this.options.chunkSize,
              status,
              _mode;
            if (this.ended) return !1;
            (_mode = mode === ~~mode ? mode : !0 === mode ? 4 : 0),
              "string" == typeof data
                ? (strm.input = strings.string2buf(data))
                : "[object ArrayBuffer]" === toString.call(data)
                ? (strm.input = new Uint8Array(data))
                : (strm.input = data),
              (strm.next_in = 0),
              (strm.avail_in = strm.input.length);
            do {
              if (
                (0 === strm.avail_out &&
                  ((strm.output = new utils.Buf8(chunkSize)),
                  (strm.next_out = 0),
                  (strm.avail_out = chunkSize)),
                1 !== (status = zlib_deflate.deflate(strm, _mode)) &&
                  0 !== status)
              )
                return this.onEnd(status), (this.ended = !0), !1;
              (0 !== strm.avail_out &&
                (0 !== strm.avail_in || (4 !== _mode && 2 !== _mode))) ||
                ("string" === this.options.to
                  ? this.onData(
                      strings.buf2binstring(
                        utils.shrinkBuf(strm.output, strm.next_out)
                      )
                    )
                  : this.onData(utils.shrinkBuf(strm.output, strm.next_out)));
            } while (
              (strm.avail_in > 0 || 0 === strm.avail_out) &&
              1 !== status
            );
            return 4 === _mode
              ? ((status = zlib_deflate.deflateEnd(this.strm)),
                this.onEnd(status),
                (this.ended = !0),
                0 === status)
              : 2 !== _mode || (this.onEnd(0), (strm.avail_out = 0), !0);
          }),
            (Deflate.prototype.onData = function (chunk) {
              this.chunks.push(chunk);
            }),
            (Deflate.prototype.onEnd = function (status) {
              0 === status &&
                ("string" === this.options.to
                  ? (this.result = this.chunks.join(""))
                  : (this.result = utils.flattenChunks(this.chunks))),
                (this.chunks = []),
                (this.err = status),
                (this.msg = this.strm.msg);
            }),
            (exports.Deflate = Deflate),
            (exports.deflate = deflate),
            (exports.deflateRaw = deflateRaw),
            (exports.gzip = gzip);
        },
        {
          "./utils/common": 35,
          "./utils/strings": 36,
          "./zlib/deflate.js": 40,
          "./zlib/messages": 45,
          "./zlib/zstream": 47,
        },
      ],
      34: [
        function (require, module, exports) {
          "use strict";
          var zlib_inflate = require("./zlib/inflate.js"),
            utils = require("./utils/common"),
            strings = require("./utils/strings"),
            c = require("./zlib/constants"),
            msg = require("./zlib/messages"),
            zstream = require("./zlib/zstream"),
            gzheader = require("./zlib/gzheader"),
            toString = Object.prototype.toString,
            Inflate = function (options) {
              this.options = utils.assign(
                { chunkSize: 16384, windowBits: 0, to: "" },
                options || {}
              );
              var opt = this.options;
              opt.raw &&
                opt.windowBits >= 0 &&
                opt.windowBits < 16 &&
                ((opt.windowBits = -opt.windowBits),
                0 === opt.windowBits && (opt.windowBits = -15)),
                !(opt.windowBits >= 0 && opt.windowBits < 16) ||
                  (options && options.windowBits) ||
                  (opt.windowBits += 32),
                opt.windowBits > 15 &&
                  opt.windowBits < 48 &&
                  0 == (15 & opt.windowBits) &&
                  (opt.windowBits |= 15),
                (this.err = 0),
                (this.msg = ""),
                (this.ended = !1),
                (this.chunks = []),
                (this.strm = new zstream()),
                (this.strm.avail_out = 0);
              var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
              if (status !== c.Z_OK) throw new Error(msg[status]);
              (this.header = new gzheader()),
                zlib_inflate.inflateGetHeader(this.strm, this.header);
            };
          function inflate(input, options) {
            var inflator = new Inflate(options);
            if ((inflator.push(input, !0), inflator.err)) throw inflator.msg;
            return inflator.result;
          }
          function inflateRaw(input, options) {
            return (
              ((options = options || {}).raw = !0), inflate(input, options)
            );
          }
          (Inflate.prototype.push = function (data, mode) {
            var strm = this.strm,
              chunkSize = this.options.chunkSize,
              status,
              _mode,
              next_out_utf8,
              tail,
              utf8str;
            if (this.ended) return !1;
            (_mode =
              mode === ~~mode ? mode : !0 === mode ? c.Z_FINISH : c.Z_NO_FLUSH),
              "string" == typeof data
                ? (strm.input = strings.binstring2buf(data))
                : "[object ArrayBuffer]" === toString.call(data)
                ? (strm.input = new Uint8Array(data))
                : (strm.input = data),
              (strm.next_in = 0),
              (strm.avail_in = strm.input.length);
            do {
              if (
                (0 === strm.avail_out &&
                  ((strm.output = new utils.Buf8(chunkSize)),
                  (strm.next_out = 0),
                  (strm.avail_out = chunkSize)),
                (status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH)) !==
                  c.Z_STREAM_END && status !== c.Z_OK)
              )
                return this.onEnd(status), (this.ended = !0), !1;
              strm.next_out &&
                ((0 !== strm.avail_out &&
                  status !== c.Z_STREAM_END &&
                  (0 !== strm.avail_in ||
                    (_mode !== c.Z_FINISH && _mode !== c.Z_SYNC_FLUSH))) ||
                  ("string" === this.options.to
                    ? ((next_out_utf8 = strings.utf8border(
                        strm.output,
                        strm.next_out
                      )),
                      (tail = strm.next_out - next_out_utf8),
                      (utf8str = strings.buf2string(
                        strm.output,
                        next_out_utf8
                      )),
                      (strm.next_out = tail),
                      (strm.avail_out = chunkSize - tail),
                      tail &&
                        utils.arraySet(
                          strm.output,
                          strm.output,
                          next_out_utf8,
                          tail,
                          0
                        ),
                      this.onData(utf8str))
                    : this.onData(
                        utils.shrinkBuf(strm.output, strm.next_out)
                      )));
            } while (strm.avail_in > 0 && status !== c.Z_STREAM_END);
            return (
              status === c.Z_STREAM_END && (_mode = c.Z_FINISH),
              _mode === c.Z_FINISH
                ? ((status = zlib_inflate.inflateEnd(this.strm)),
                  this.onEnd(status),
                  (this.ended = !0),
                  status === c.Z_OK)
                : _mode !== c.Z_SYNC_FLUSH ||
                  (this.onEnd(c.Z_OK), (strm.avail_out = 0), !0)
            );
          }),
            (Inflate.prototype.onData = function (chunk) {
              this.chunks.push(chunk);
            }),
            (Inflate.prototype.onEnd = function (status) {
              status === c.Z_OK &&
                ("string" === this.options.to
                  ? (this.result = this.chunks.join(""))
                  : (this.result = utils.flattenChunks(this.chunks))),
                (this.chunks = []),
                (this.err = status),
                (this.msg = this.strm.msg);
            }),
            (exports.Inflate = Inflate),
            (exports.inflate = inflate),
            (exports.inflateRaw = inflateRaw),
            (exports.ungzip = inflate);
        },
        {
          "./utils/common": 35,
          "./utils/strings": 36,
          "./zlib/constants": 38,
          "./zlib/gzheader": 41,
          "./zlib/inflate.js": 43,
          "./zlib/messages": 45,
          "./zlib/zstream": 47,
        },
      ],
      35: [
        function (require, module, exports) {
          "use strict";
          var TYPED_OK =
            "undefined" != typeof Uint8Array &&
            "undefined" != typeof Uint16Array &&
            "undefined" != typeof Int32Array;
          (exports.assign = function (obj) {
            for (
              var sources = Array.prototype.slice.call(arguments, 1);
              sources.length;

            ) {
              var source = sources.shift();
              if (source) {
                if ("object" != typeof source)
                  throw new TypeError(source + "must be non-object");
                for (var p in source)
                  source.hasOwnProperty(p) && (obj[p] = source[p]);
              }
            }
            return obj;
          }),
            (exports.shrinkBuf = function (buf, size) {
              return buf.length === size
                ? buf
                : buf.subarray
                ? buf.subarray(0, size)
                : ((buf.length = size), buf);
            });
          var fnTyped = {
              arraySet: function (dest, src, src_offs, len, dest_offs) {
                if (src.subarray && dest.subarray)
                  dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                else
                  for (var i = 0; i < len; i++)
                    dest[dest_offs + i] = src[src_offs + i];
              },
              flattenChunks: function (chunks) {
                var i, l, len, pos, chunk, result;
                for (len = 0, i = 0, l = chunks.length; i < l; i++)
                  len += chunks[i].length;
                for (
                  result = new Uint8Array(len),
                    pos = 0,
                    i = 0,
                    l = chunks.length;
                  i < l;
                  i++
                )
                  (chunk = chunks[i]),
                    result.set(chunk, pos),
                    (pos += chunk.length);
                return result;
              },
            },
            fnUntyped = {
              arraySet: function (dest, src, src_offs, len, dest_offs) {
                for (var i = 0; i < len; i++)
                  dest[dest_offs + i] = src[src_offs + i];
              },
              flattenChunks: function (chunks) {
                return [].concat.apply([], chunks);
              },
            };
          (exports.setTyped = function (on) {
            on
              ? ((exports.Buf8 = Uint8Array),
                (exports.Buf16 = Uint16Array),
                (exports.Buf32 = Int32Array),
                exports.assign(exports, fnTyped))
              : ((exports.Buf8 = Array),
                (exports.Buf16 = Array),
                (exports.Buf32 = Array),
                exports.assign(exports, fnUntyped));
          }),
            exports.setTyped(TYPED_OK);
        },
        {},
      ],
      36: [
        function (require, module, exports) {
          "use strict";
          var utils = require("./common"),
            STR_APPLY_OK = !0,
            STR_APPLY_UIA_OK = !0;
          try {
            String.fromCharCode.apply(null, [0]);
          } catch (__) {
            STR_APPLY_OK = !1;
          }
          try {
            String.fromCharCode.apply(null, new Uint8Array(1));
          } catch (__) {
            STR_APPLY_UIA_OK = !1;
          }
          for (var _utf8len = new utils.Buf8(256), q = 0; q < 256; q++)
            _utf8len[q] =
              q >= 252
                ? 6
                : q >= 248
                ? 5
                : q >= 240
                ? 4
                : q >= 224
                ? 3
                : q >= 192
                ? 2
                : 1;
          function buf2binstring(buf, len) {
            if (
              len < 65537 &&
              ((buf.subarray && STR_APPLY_UIA_OK) ||
                (!buf.subarray && STR_APPLY_OK))
            )
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            for (var result = "", i = 0; i < len; i++)
              result += String.fromCharCode(buf[i]);
            return result;
          }
          (_utf8len[254] = _utf8len[254] = 1),
            (exports.string2buf = function (str) {
              var buf,
                c,
                c2,
                m_pos,
                i,
                str_len = str.length,
                buf_len = 0;
              for (m_pos = 0; m_pos < str_len; m_pos++)
                55296 == (64512 & (c = str.charCodeAt(m_pos))) &&
                  m_pos + 1 < str_len &&
                  56320 == (64512 & (c2 = str.charCodeAt(m_pos + 1))) &&
                  ((c = 65536 + ((c - 55296) << 10) + (c2 - 56320)), m_pos++),
                  (buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4);
              for (
                buf = new utils.Buf8(buf_len), i = 0, m_pos = 0;
                i < buf_len;
                m_pos++
              )
                55296 == (64512 & (c = str.charCodeAt(m_pos))) &&
                  m_pos + 1 < str_len &&
                  56320 == (64512 & (c2 = str.charCodeAt(m_pos + 1))) &&
                  ((c = 65536 + ((c - 55296) << 10) + (c2 - 56320)), m_pos++),
                  c < 128
                    ? (buf[i++] = c)
                    : c < 2048
                    ? ((buf[i++] = 192 | (c >>> 6)),
                      (buf[i++] = 128 | (63 & c)))
                    : c < 65536
                    ? ((buf[i++] = 224 | (c >>> 12)),
                      (buf[i++] = 128 | ((c >>> 6) & 63)),
                      (buf[i++] = 128 | (63 & c)))
                    : ((buf[i++] = 240 | (c >>> 18)),
                      (buf[i++] = 128 | ((c >>> 12) & 63)),
                      (buf[i++] = 128 | ((c >>> 6) & 63)),
                      (buf[i++] = 128 | (63 & c)));
              return buf;
            }),
            (exports.buf2binstring = function (buf) {
              return buf2binstring(buf, buf.length);
            }),
            (exports.binstring2buf = function (str) {
              for (
                var buf = new utils.Buf8(str.length), i = 0, len = buf.length;
                i < len;
                i++
              )
                buf[i] = str.charCodeAt(i);
              return buf;
            }),
            (exports.buf2string = function (buf, max) {
              var i,
                out,
                c,
                c_len,
                len = max || buf.length,
                utf16buf = new Array(2 * len);
              for (out = 0, i = 0; i < len; )
                if ((c = buf[i++]) < 128) utf16buf[out++] = c;
                else if ((c_len = _utf8len[c]) > 4)
                  (utf16buf[out++] = 65533), (i += c_len - 1);
                else {
                  for (
                    c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7;
                    c_len > 1 && i < len;

                  )
                    (c = (c << 6) | (63 & buf[i++])), c_len--;
                  c_len > 1
                    ? (utf16buf[out++] = 65533)
                    : c < 65536
                    ? (utf16buf[out++] = c)
                    : ((c -= 65536),
                      (utf16buf[out++] = 55296 | ((c >> 10) & 1023)),
                      (utf16buf[out++] = 56320 | (1023 & c)));
                }
              return buf2binstring(utf16buf, out);
            }),
            (exports.utf8border = function (buf, max) {
              var pos;
              for (
                (max = max || buf.length) > buf.length && (max = buf.length),
                  pos = max - 1;
                pos >= 0 && 128 == (192 & buf[pos]);

              )
                pos--;
              return pos < 0
                ? max
                : 0 === pos
                ? max
                : pos + _utf8len[buf[pos]] > max
                ? pos
                : max;
            });
        },
        { "./common": 35 },
      ],
      37: [
        function (require, module, exports) {
          "use strict";
          function adler32(adler, buf, len, pos) {
            for (
              var s1 = (65535 & adler) | 0,
                s2 = ((adler >>> 16) & 65535) | 0,
                n = 0;
              0 !== len;

            ) {
              len -= n = len > 2e3 ? 2e3 : len;
              do {
                s2 = (s2 + (s1 = (s1 + buf[pos++]) | 0)) | 0;
              } while (--n);
              (s1 %= 65521), (s2 %= 65521);
            }
            return s1 | (s2 << 16) | 0;
          }
          module.exports = adler32;
        },
        {},
      ],
      38: [
        function (require, module, exports) {
          module.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8,
          };
        },
        {},
      ],
      39: [
        function (require, module, exports) {
          "use strict";
          function makeTable() {
            for (var c, table = [], n = 0; n < 256; n++) {
              c = n;
              for (var k = 0; k < 8; k++)
                c = 1 & c ? 3988292384 ^ (c >>> 1) : c >>> 1;
              table[n] = c;
            }
            return table;
          }
          var crcTable = makeTable();
          function crc32(crc, buf, len, pos) {
            var t = crcTable,
              end = pos + len;
            crc ^= -1;
            for (var i = pos; i < end; i++)
              crc = (crc >>> 8) ^ t[255 & (crc ^ buf[i])];
            return -1 ^ crc;
          }
          module.exports = crc32;
        },
        {},
      ],
      40: [
        function (require, module, exports) {
          "use strict";
          var utils = require("../utils/common"),
            trees = require("./trees"),
            adler32 = require("./adler32"),
            crc32 = require("./crc32"),
            msg = require("./messages"),
            Z_NO_FLUSH = 0,
            Z_PARTIAL_FLUSH = 1,
            Z_FULL_FLUSH = 3,
            Z_FINISH = 4,
            Z_BLOCK = 5,
            Z_OK = 0,
            Z_STREAM_END = 1,
            Z_STREAM_ERROR = -2,
            Z_DATA_ERROR = -3,
            Z_BUF_ERROR = -5,
            Z_DEFAULT_COMPRESSION = -1,
            Z_FILTERED = 1,
            Z_HUFFMAN_ONLY = 2,
            Z_RLE = 3,
            Z_FIXED = 4,
            Z_DEFAULT_STRATEGY = 0,
            Z_UNKNOWN = 2,
            Z_DEFLATED = 8,
            MAX_MEM_LEVEL = 9,
            MAX_WBITS = 15,
            DEF_MEM_LEVEL = 8,
            LENGTH_CODES = 29,
            LITERALS = 256,
            L_CODES = 286,
            D_CODES = 30,
            BL_CODES = 19,
            HEAP_SIZE = 2 * L_CODES + 1,
            MAX_BITS = 15,
            MIN_MATCH = 3,
            MAX_MATCH = 258,
            MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
            PRESET_DICT = 32,
            INIT_STATE = 42,
            EXTRA_STATE = 69,
            NAME_STATE = 73,
            COMMENT_STATE = 91,
            HCRC_STATE = 103,
            BUSY_STATE = 113,
            FINISH_STATE = 666,
            BS_NEED_MORE = 1,
            BS_BLOCK_DONE = 2,
            BS_FINISH_STARTED = 3,
            BS_FINISH_DONE = 4,
            OS_CODE = 3;
          function err(strm, errorCode) {
            return (strm.msg = msg[errorCode]), errorCode;
          }
          function rank(f) {
            return (f << 1) - (f > 4 ? 9 : 0);
          }
          function zero(buf) {
            for (var len = buf.length; --len >= 0; ) buf[len] = 0;
          }
          function flush_pending(strm) {
            var s = strm.state,
              len = s.pending;
            len > strm.avail_out && (len = strm.avail_out),
              0 !== len &&
                (utils.arraySet(
                  strm.output,
                  s.pending_buf,
                  s.pending_out,
                  len,
                  strm.next_out
                ),
                (strm.next_out += len),
                (s.pending_out += len),
                (strm.total_out += len),
                (strm.avail_out -= len),
                (s.pending -= len),
                0 === s.pending && (s.pending_out = 0));
          }
          function flush_block_only(s, last) {
            trees._tr_flush_block(
              s,
              s.block_start >= 0 ? s.block_start : -1,
              s.strstart - s.block_start,
              last
            ),
              (s.block_start = s.strstart),
              flush_pending(s.strm);
          }
          function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
          }
          function putShortMSB(s, b) {
            (s.pending_buf[s.pending++] = (b >>> 8) & 255),
              (s.pending_buf[s.pending++] = 255 & b);
          }
          function read_buf(strm, buf, start, size) {
            var len = strm.avail_in;
            return (
              len > size && (len = size),
              0 === len
                ? 0
                : ((strm.avail_in -= len),
                  utils.arraySet(buf, strm.input, strm.next_in, len, start),
                  1 === strm.state.wrap
                    ? (strm.adler = adler32(strm.adler, buf, len, start))
                    : 2 === strm.state.wrap &&
                      (strm.adler = crc32(strm.adler, buf, len, start)),
                  (strm.next_in += len),
                  (strm.total_in += len),
                  len)
            );
          }
          function longest_match(s, cur_match) {
            var chain_length = s.max_chain_length,
              scan = s.strstart,
              match,
              len,
              best_len = s.prev_length,
              nice_match = s.nice_match,
              limit =
                s.strstart > s.w_size - MIN_LOOKAHEAD
                  ? s.strstart - (s.w_size - MIN_LOOKAHEAD)
                  : 0,
              _win = s.window,
              wmask = s.w_mask,
              prev = s.prev,
              strend = s.strstart + MAX_MATCH,
              scan_end1 = _win[scan + best_len - 1],
              scan_end = _win[scan + best_len];
            s.prev_length >= s.good_match && (chain_length >>= 2),
              nice_match > s.lookahead && (nice_match = s.lookahead);
            do {
              if (
                _win[(match = cur_match) + best_len] === scan_end &&
                _win[match + best_len - 1] === scan_end1 &&
                _win[match] === _win[scan] &&
                _win[++match] === _win[scan + 1]
              ) {
                (scan += 2), match++;
                do {} while (
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  _win[++scan] === _win[++match] &&
                  scan < strend
                );
                if (
                  ((len = MAX_MATCH - (strend - scan)),
                  (scan = strend - MAX_MATCH),
                  len > best_len)
                ) {
                  if (
                    ((s.match_start = cur_match),
                    (best_len = len),
                    len >= nice_match)
                  )
                    break;
                  (scan_end1 = _win[scan + best_len - 1]),
                    (scan_end = _win[scan + best_len]);
                }
              }
            } while (
              (cur_match = prev[cur_match & wmask]) > limit &&
              0 != --chain_length
            );
            return best_len <= s.lookahead ? best_len : s.lookahead;
          }
          function fill_window(s) {
            var _w_size = s.w_size,
              p,
              n,
              m,
              more,
              str;
            do {
              if (
                ((more = s.window_size - s.lookahead - s.strstart),
                s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD))
              ) {
                utils.arraySet(s.window, s.window, _w_size, _w_size, 0),
                  (s.match_start -= _w_size),
                  (s.strstart -= _w_size),
                  (s.block_start -= _w_size),
                  (p = n = s.hash_size);
                do {
                  (m = s.head[--p]),
                    (s.head[p] = m >= _w_size ? m - _w_size : 0);
                } while (--n);
                p = n = _w_size;
                do {
                  (m = s.prev[--p]),
                    (s.prev[p] = m >= _w_size ? m - _w_size : 0);
                } while (--n);
                more += _w_size;
              }
              if (0 === s.strm.avail_in) break;
              if (
                ((n = read_buf(
                  s.strm,
                  s.window,
                  s.strstart + s.lookahead,
                  more
                )),
                (s.lookahead += n),
                s.lookahead + s.insert >= MIN_MATCH)
              )
                for (
                  str = s.strstart - s.insert,
                    s.ins_h = s.window[str],
                    s.ins_h =
                      ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) &
                      s.hash_mask;
                  s.insert &&
                  ((s.ins_h =
                    ((s.ins_h << s.hash_shift) ^
                      s.window[str + MIN_MATCH - 1]) &
                    s.hash_mask),
                  (s.prev[str & s.w_mask] = s.head[s.ins_h]),
                  (s.head[s.ins_h] = str),
                  str++,
                  s.insert--,
                  !(s.lookahead + s.insert < MIN_MATCH));

                );
            } while (s.lookahead < MIN_LOOKAHEAD && 0 !== s.strm.avail_in);
          }
          function deflate_stored(s, flush) {
            var max_block_size = 65535;
            for (
              max_block_size > s.pending_buf_size - 5 &&
              (max_block_size = s.pending_buf_size - 5);
              ;

            ) {
              if (s.lookahead <= 1) {
                if ((fill_window(s), 0 === s.lookahead && flush === Z_NO_FLUSH))
                  return BS_NEED_MORE;
                if (0 === s.lookahead) break;
              }
              (s.strstart += s.lookahead), (s.lookahead = 0);
              var max_start = s.block_start + max_block_size;
              if (
                (0 === s.strstart || s.strstart >= max_start) &&
                ((s.lookahead = s.strstart - max_start),
                (s.strstart = max_start),
                flush_block_only(s, !1),
                0 === s.strm.avail_out)
              )
                return BS_NEED_MORE;
              if (
                s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD &&
                (flush_block_only(s, !1), 0 === s.strm.avail_out)
              )
                return BS_NEED_MORE;
            }
            return (
              (s.insert = 0),
              flush === Z_FINISH
                ? (flush_block_only(s, !0),
                  0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE)
                : (s.strstart > s.block_start &&
                    (flush_block_only(s, !1), s.strm.avail_out),
                  BS_NEED_MORE)
            );
          }
          function deflate_fast(s, flush) {
            for (var hash_head, bflush; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                if (
                  (fill_window(s),
                  s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
                )
                  return BS_NEED_MORE;
                if (0 === s.lookahead) break;
              }
              if (
                ((hash_head = 0),
                s.lookahead >= MIN_MATCH &&
                  ((s.ins_h =
                    ((s.ins_h << s.hash_shift) ^
                      s.window[s.strstart + MIN_MATCH - 1]) &
                    s.hash_mask),
                  (hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]),
                  (s.head[s.ins_h] = s.strstart)),
                0 !== hash_head &&
                  s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD &&
                  (s.match_length = longest_match(s, hash_head)),
                s.match_length >= MIN_MATCH)
              )
                if (
                  ((bflush = trees._tr_tally(
                    s,
                    s.strstart - s.match_start,
                    s.match_length - MIN_MATCH
                  )),
                  (s.lookahead -= s.match_length),
                  s.match_length <= s.max_lazy_match &&
                    s.lookahead >= MIN_MATCH)
                ) {
                  s.match_length--;
                  do {
                    s.strstart++,
                      (s.ins_h =
                        ((s.ins_h << s.hash_shift) ^
                          s.window[s.strstart + MIN_MATCH - 1]) &
                        s.hash_mask),
                      (hash_head = s.prev[s.strstart & s.w_mask] =
                        s.head[s.ins_h]),
                      (s.head[s.ins_h] = s.strstart);
                  } while (0 != --s.match_length);
                  s.strstart++;
                } else
                  (s.strstart += s.match_length),
                    (s.match_length = 0),
                    (s.ins_h = s.window[s.strstart]),
                    (s.ins_h =
                      ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) &
                      s.hash_mask);
              else
                (bflush = trees._tr_tally(s, 0, s.window[s.strstart])),
                  s.lookahead--,
                  s.strstart++;
              if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out))
                return BS_NEED_MORE;
            }
            return (
              (s.insert =
                s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1),
              flush === Z_FINISH
                ? (flush_block_only(s, !0),
                  0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE)
                : s.last_lit &&
                  (flush_block_only(s, !1), 0 === s.strm.avail_out)
                ? BS_NEED_MORE
                : BS_BLOCK_DONE
            );
          }
          function deflate_slow(s, flush) {
            for (var hash_head, bflush, max_insert; ; ) {
              if (s.lookahead < MIN_LOOKAHEAD) {
                if (
                  (fill_window(s),
                  s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)
                )
                  return BS_NEED_MORE;
                if (0 === s.lookahead) break;
              }
              if (
                ((hash_head = 0),
                s.lookahead >= MIN_MATCH &&
                  ((s.ins_h =
                    ((s.ins_h << s.hash_shift) ^
                      s.window[s.strstart + MIN_MATCH - 1]) &
                    s.hash_mask),
                  (hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]),
                  (s.head[s.ins_h] = s.strstart)),
                (s.prev_length = s.match_length),
                (s.prev_match = s.match_start),
                (s.match_length = MIN_MATCH - 1),
                0 !== hash_head &&
                  s.prev_length < s.max_lazy_match &&
                  s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD &&
                  ((s.match_length = longest_match(s, hash_head)),
                  s.match_length <= 5 &&
                    (s.strategy === Z_FILTERED ||
                      (s.match_length === MIN_MATCH &&
                        s.strstart - s.match_start > 4096)) &&
                    (s.match_length = MIN_MATCH - 1)),
                s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length)
              ) {
                (max_insert = s.strstart + s.lookahead - MIN_MATCH),
                  (bflush = trees._tr_tally(
                    s,
                    s.strstart - 1 - s.prev_match,
                    s.prev_length - MIN_MATCH
                  )),
                  (s.lookahead -= s.prev_length - 1),
                  (s.prev_length -= 2);
                do {
                  ++s.strstart <= max_insert &&
                    ((s.ins_h =
                      ((s.ins_h << s.hash_shift) ^
                        s.window[s.strstart + MIN_MATCH - 1]) &
                      s.hash_mask),
                    (hash_head = s.prev[s.strstart & s.w_mask] =
                      s.head[s.ins_h]),
                    (s.head[s.ins_h] = s.strstart));
                } while (0 != --s.prev_length);
                if (
                  ((s.match_available = 0),
                  (s.match_length = MIN_MATCH - 1),
                  s.strstart++,
                  bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out))
                )
                  return BS_NEED_MORE;
              } else if (s.match_available) {
                if (
                  ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])) &&
                    flush_block_only(s, !1),
                  s.strstart++,
                  s.lookahead--,
                  0 === s.strm.avail_out)
                )
                  return BS_NEED_MORE;
              } else (s.match_available = 1), s.strstart++, s.lookahead--;
            }
            return (
              s.match_available &&
                ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])),
                (s.match_available = 0)),
              (s.insert =
                s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1),
              flush === Z_FINISH
                ? (flush_block_only(s, !0),
                  0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE)
                : s.last_lit &&
                  (flush_block_only(s, !1), 0 === s.strm.avail_out)
                ? BS_NEED_MORE
                : BS_BLOCK_DONE
            );
          }
          function deflate_rle(s, flush) {
            for (var bflush, prev, scan, strend, _win = s.window; ; ) {
              if (s.lookahead <= MAX_MATCH) {
                if (
                  (fill_window(s),
                  s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)
                )
                  return BS_NEED_MORE;
                if (0 === s.lookahead) break;
              }
              if (
                ((s.match_length = 0),
                s.lookahead >= MIN_MATCH &&
                  s.strstart > 0 &&
                  (prev = _win[(scan = s.strstart - 1)]) === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan])
              ) {
                strend = s.strstart + MAX_MATCH;
                do {} while (
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  prev === _win[++scan] &&
                  scan < strend
                );
                (s.match_length = MAX_MATCH - (strend - scan)),
                  s.match_length > s.lookahead &&
                    (s.match_length = s.lookahead);
              }
              if (
                (s.match_length >= MIN_MATCH
                  ? ((bflush = trees._tr_tally(
                      s,
                      1,
                      s.match_length - MIN_MATCH
                    )),
                    (s.lookahead -= s.match_length),
                    (s.strstart += s.match_length),
                    (s.match_length = 0))
                  : ((bflush = trees._tr_tally(s, 0, s.window[s.strstart])),
                    s.lookahead--,
                    s.strstart++),
                bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out))
              )
                return BS_NEED_MORE;
            }
            return (
              (s.insert = 0),
              flush === Z_FINISH
                ? (flush_block_only(s, !0),
                  0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE)
                : s.last_lit &&
                  (flush_block_only(s, !1), 0 === s.strm.avail_out)
                ? BS_NEED_MORE
                : BS_BLOCK_DONE
            );
          }
          function deflate_huff(s, flush) {
            for (var bflush; ; ) {
              if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                if (flush === Z_NO_FLUSH) return BS_NEED_MORE;
                break;
              }
              if (
                ((s.match_length = 0),
                (bflush = trees._tr_tally(s, 0, s.window[s.strstart])),
                s.lookahead--,
                s.strstart++,
                bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out))
              )
                return BS_NEED_MORE;
            }
            return (
              (s.insert = 0),
              flush === Z_FINISH
                ? (flush_block_only(s, !0),
                  0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE)
                : s.last_lit &&
                  (flush_block_only(s, !1), 0 === s.strm.avail_out)
                ? BS_NEED_MORE
                : BS_BLOCK_DONE
            );
          }
          var Config = function (
              good_length,
              max_lazy,
              nice_length,
              max_chain,
              func
            ) {
              (this.good_length = good_length),
                (this.max_lazy = max_lazy),
                (this.nice_length = nice_length),
                (this.max_chain = max_chain),
                (this.func = func);
            },
            configuration_table;
          function lm_init(s) {
            (s.window_size = 2 * s.w_size),
              zero(s.head),
              (s.max_lazy_match = configuration_table[s.level].max_lazy),
              (s.good_match = configuration_table[s.level].good_length),
              (s.nice_match = configuration_table[s.level].nice_length),
              (s.max_chain_length = configuration_table[s.level].max_chain),
              (s.strstart = 0),
              (s.block_start = 0),
              (s.lookahead = 0),
              (s.insert = 0),
              (s.match_length = s.prev_length = MIN_MATCH - 1),
              (s.match_available = 0),
              (s.ins_h = 0);
          }
          function DeflateState() {
            (this.strm = null),
              (this.status = 0),
              (this.pending_buf = null),
              (this.pending_buf_size = 0),
              (this.pending_out = 0),
              (this.pending = 0),
              (this.wrap = 0),
              (this.gzhead = null),
              (this.gzindex = 0),
              (this.method = Z_DEFLATED),
              (this.last_flush = -1),
              (this.w_size = 0),
              (this.w_bits = 0),
              (this.w_mask = 0),
              (this.window = null),
              (this.window_size = 0),
              (this.prev = null),
              (this.head = null),
              (this.ins_h = 0),
              (this.hash_size = 0),
              (this.hash_bits = 0),
              (this.hash_mask = 0),
              (this.hash_shift = 0),
              (this.block_start = 0),
              (this.match_length = 0),
              (this.prev_match = 0),
              (this.match_available = 0),
              (this.strstart = 0),
              (this.match_start = 0),
              (this.lookahead = 0),
              (this.prev_length = 0),
              (this.max_chain_length = 0),
              (this.max_lazy_match = 0),
              (this.level = 0),
              (this.strategy = 0),
              (this.good_match = 0),
              (this.nice_match = 0),
              (this.dyn_ltree = new utils.Buf16(2 * HEAP_SIZE)),
              (this.dyn_dtree = new utils.Buf16(2 * (2 * D_CODES + 1))),
              (this.bl_tree = new utils.Buf16(2 * (2 * BL_CODES + 1))),
              zero(this.dyn_ltree),
              zero(this.dyn_dtree),
              zero(this.bl_tree),
              (this.l_desc = null),
              (this.d_desc = null),
              (this.bl_desc = null),
              (this.bl_count = new utils.Buf16(MAX_BITS + 1)),
              (this.heap = new utils.Buf16(2 * L_CODES + 1)),
              zero(this.heap),
              (this.heap_len = 0),
              (this.heap_max = 0),
              (this.depth = new utils.Buf16(2 * L_CODES + 1)),
              zero(this.depth),
              (this.l_buf = 0),
              (this.lit_bufsize = 0),
              (this.last_lit = 0),
              (this.d_buf = 0),
              (this.opt_len = 0),
              (this.static_len = 0),
              (this.matches = 0),
              (this.insert = 0),
              (this.bi_buf = 0),
              (this.bi_valid = 0);
          }
          function deflateResetKeep(strm) {
            var s;
            return strm && strm.state
              ? ((strm.total_in = strm.total_out = 0),
                (strm.data_type = Z_UNKNOWN),
                ((s = strm.state).pending = 0),
                (s.pending_out = 0),
                s.wrap < 0 && (s.wrap = -s.wrap),
                (s.status = s.wrap ? INIT_STATE : BUSY_STATE),
                (strm.adler = 2 === s.wrap ? 0 : 1),
                (s.last_flush = Z_NO_FLUSH),
                trees._tr_init(s),
                Z_OK)
              : err(strm, Z_STREAM_ERROR);
          }
          function deflateReset(strm) {
            var ret = deflateResetKeep(strm);
            return ret === Z_OK && lm_init(strm.state), ret;
          }
          function deflateSetHeader(strm, head) {
            return strm && strm.state
              ? 2 !== strm.state.wrap
                ? Z_STREAM_ERROR
                : ((strm.state.gzhead = head), Z_OK)
              : Z_STREAM_ERROR;
          }
          function deflateInit2(
            strm,
            level,
            method,
            windowBits,
            memLevel,
            strategy
          ) {
            if (!strm) return Z_STREAM_ERROR;
            var wrap = 1;
            if (
              (level === Z_DEFAULT_COMPRESSION && (level = 6),
              windowBits < 0
                ? ((wrap = 0), (windowBits = -windowBits))
                : windowBits > 15 && ((wrap = 2), (windowBits -= 16)),
              memLevel < 1 ||
                memLevel > MAX_MEM_LEVEL ||
                method !== Z_DEFLATED ||
                windowBits < 8 ||
                windowBits > 15 ||
                level < 0 ||
                level > 9 ||
                strategy < 0 ||
                strategy > Z_FIXED)
            )
              return err(strm, Z_STREAM_ERROR);
            8 === windowBits && (windowBits = 9);
            var s = new DeflateState();
            return (
              (strm.state = s),
              (s.strm = strm),
              (s.wrap = wrap),
              (s.gzhead = null),
              (s.w_bits = windowBits),
              (s.w_size = 1 << s.w_bits),
              (s.w_mask = s.w_size - 1),
              (s.hash_bits = memLevel + 7),
              (s.hash_size = 1 << s.hash_bits),
              (s.hash_mask = s.hash_size - 1),
              (s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH)),
              (s.window = new utils.Buf8(2 * s.w_size)),
              (s.head = new utils.Buf16(s.hash_size)),
              (s.prev = new utils.Buf16(s.w_size)),
              (s.lit_bufsize = 1 << (memLevel + 6)),
              (s.pending_buf_size = 4 * s.lit_bufsize),
              (s.pending_buf = new utils.Buf8(s.pending_buf_size)),
              (s.d_buf = s.lit_bufsize >> 1),
              (s.l_buf = 3 * s.lit_bufsize),
              (s.level = level),
              (s.strategy = strategy),
              (s.method = method),
              deflateReset(strm)
            );
          }
          function deflateInit(strm, level) {
            return deflateInit2(
              strm,
              level,
              Z_DEFLATED,
              MAX_WBITS,
              DEF_MEM_LEVEL,
              Z_DEFAULT_STRATEGY
            );
          }
          function deflate(strm, flush) {
            var old_flush, s, beg, val;
            if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)
              return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            if (
              ((s = strm.state),
              !strm.output ||
                (!strm.input && 0 !== strm.avail_in) ||
                (s.status === FINISH_STATE && flush !== Z_FINISH))
            )
              return err(
                strm,
                0 === strm.avail_out ? Z_BUF_ERROR : Z_STREAM_ERROR
              );
            if (
              ((s.strm = strm),
              (old_flush = s.last_flush),
              (s.last_flush = flush),
              s.status === INIT_STATE)
            )
              if (2 === s.wrap)
                (strm.adler = 0),
                  put_byte(s, 31),
                  put_byte(s, 139),
                  put_byte(s, 8),
                  s.gzhead
                    ? (put_byte(
                        s,
                        (s.gzhead.text ? 1 : 0) +
                          (s.gzhead.hcrc ? 2 : 0) +
                          (s.gzhead.extra ? 4 : 0) +
                          (s.gzhead.name ? 8 : 0) +
                          (s.gzhead.comment ? 16 : 0)
                      ),
                      put_byte(s, 255 & s.gzhead.time),
                      put_byte(s, (s.gzhead.time >> 8) & 255),
                      put_byte(s, (s.gzhead.time >> 16) & 255),
                      put_byte(s, (s.gzhead.time >> 24) & 255),
                      put_byte(
                        s,
                        9 === s.level
                          ? 2
                          : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                          ? 4
                          : 0
                      ),
                      put_byte(s, 255 & s.gzhead.os),
                      s.gzhead.extra &&
                        s.gzhead.extra.length &&
                        (put_byte(s, 255 & s.gzhead.extra.length),
                        put_byte(s, (s.gzhead.extra.length >> 8) & 255)),
                      s.gzhead.hcrc &&
                        (strm.adler = crc32(
                          strm.adler,
                          s.pending_buf,
                          s.pending,
                          0
                        )),
                      (s.gzindex = 0),
                      (s.status = EXTRA_STATE))
                    : (put_byte(s, 0),
                      put_byte(s, 0),
                      put_byte(s, 0),
                      put_byte(s, 0),
                      put_byte(s, 0),
                      put_byte(
                        s,
                        9 === s.level
                          ? 2
                          : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                          ? 4
                          : 0
                      ),
                      put_byte(s, OS_CODE),
                      (s.status = BUSY_STATE));
              else {
                var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8,
                  level_flags = -1;
                (header |=
                  (level_flags =
                    s.strategy >= Z_HUFFMAN_ONLY || s.level < 2
                      ? 0
                      : s.level < 6
                      ? 1
                      : 6 === s.level
                      ? 2
                      : 3) << 6),
                  0 !== s.strstart && (header |= PRESET_DICT),
                  (header += 31 - (header % 31)),
                  (s.status = BUSY_STATE),
                  putShortMSB(s, header),
                  0 !== s.strstart &&
                    (putShortMSB(s, strm.adler >>> 16),
                    putShortMSB(s, 65535 & strm.adler)),
                  (strm.adler = 1);
              }
            if (s.status === EXTRA_STATE)
              if (s.gzhead.extra) {
                for (
                  beg = s.pending;
                  s.gzindex < (65535 & s.gzhead.extra.length) &&
                  (s.pending !== s.pending_buf_size ||
                    (s.gzhead.hcrc &&
                      s.pending > beg &&
                      (strm.adler = crc32(
                        strm.adler,
                        s.pending_buf,
                        s.pending - beg,
                        beg
                      )),
                    flush_pending(strm),
                    (beg = s.pending),
                    s.pending !== s.pending_buf_size));

                )
                  put_byte(s, 255 & s.gzhead.extra[s.gzindex]), s.gzindex++;
                s.gzhead.hcrc &&
                  s.pending > beg &&
                  (strm.adler = crc32(
                    strm.adler,
                    s.pending_buf,
                    s.pending - beg,
                    beg
                  )),
                  s.gzindex === s.gzhead.extra.length &&
                    ((s.gzindex = 0), (s.status = NAME_STATE));
              } else s.status = NAME_STATE;
            if (s.status === NAME_STATE)
              if (s.gzhead.name) {
                beg = s.pending;
                do {
                  if (
                    s.pending === s.pending_buf_size &&
                    (s.gzhead.hcrc &&
                      s.pending > beg &&
                      (strm.adler = crc32(
                        strm.adler,
                        s.pending_buf,
                        s.pending - beg,
                        beg
                      )),
                    flush_pending(strm),
                    (beg = s.pending),
                    s.pending === s.pending_buf_size)
                  ) {
                    val = 1;
                    break;
                  }
                  (val =
                    s.gzindex < s.gzhead.name.length
                      ? 255 & s.gzhead.name.charCodeAt(s.gzindex++)
                      : 0),
                    put_byte(s, val);
                } while (0 !== val);
                s.gzhead.hcrc &&
                  s.pending > beg &&
                  (strm.adler = crc32(
                    strm.adler,
                    s.pending_buf,
                    s.pending - beg,
                    beg
                  )),
                  0 === val && ((s.gzindex = 0), (s.status = COMMENT_STATE));
              } else s.status = COMMENT_STATE;
            if (s.status === COMMENT_STATE)
              if (s.gzhead.comment) {
                beg = s.pending;
                do {
                  if (
                    s.pending === s.pending_buf_size &&
                    (s.gzhead.hcrc &&
                      s.pending > beg &&
                      (strm.adler = crc32(
                        strm.adler,
                        s.pending_buf,
                        s.pending - beg,
                        beg
                      )),
                    flush_pending(strm),
                    (beg = s.pending),
                    s.pending === s.pending_buf_size)
                  ) {
                    val = 1;
                    break;
                  }
                  (val =
                    s.gzindex < s.gzhead.comment.length
                      ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++)
                      : 0),
                    put_byte(s, val);
                } while (0 !== val);
                s.gzhead.hcrc &&
                  s.pending > beg &&
                  (strm.adler = crc32(
                    strm.adler,
                    s.pending_buf,
                    s.pending - beg,
                    beg
                  )),
                  0 === val && (s.status = HCRC_STATE);
              } else s.status = HCRC_STATE;
            if (
              (s.status === HCRC_STATE &&
                (s.gzhead.hcrc
                  ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm),
                    s.pending + 2 <= s.pending_buf_size &&
                      (put_byte(s, 255 & strm.adler),
                      put_byte(s, (strm.adler >> 8) & 255),
                      (strm.adler = 0),
                      (s.status = BUSY_STATE)))
                  : (s.status = BUSY_STATE)),
              0 !== s.pending)
            ) {
              if ((flush_pending(strm), 0 === strm.avail_out))
                return (s.last_flush = -1), Z_OK;
            } else if (
              0 === strm.avail_in &&
              rank(flush) <= rank(old_flush) &&
              flush !== Z_FINISH
            )
              return err(strm, Z_BUF_ERROR);
            if (s.status === FINISH_STATE && 0 !== strm.avail_in)
              return err(strm, Z_BUF_ERROR);
            if (
              0 !== strm.avail_in ||
              0 !== s.lookahead ||
              (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)
            ) {
              var bstate =
                s.strategy === Z_HUFFMAN_ONLY
                  ? deflate_huff(s, flush)
                  : s.strategy === Z_RLE
                  ? deflate_rle(s, flush)
                  : configuration_table[s.level].func(s, flush);
              if (
                ((bstate !== BS_FINISH_STARTED && bstate !== BS_FINISH_DONE) ||
                  (s.status = FINISH_STATE),
                bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED)
              )
                return 0 === strm.avail_out && (s.last_flush = -1), Z_OK;
              if (
                bstate === BS_BLOCK_DONE &&
                (flush === Z_PARTIAL_FLUSH
                  ? trees._tr_align(s)
                  : flush !== Z_BLOCK &&
                    (trees._tr_stored_block(s, 0, 0, !1),
                    flush === Z_FULL_FLUSH &&
                      (zero(s.head),
                      0 === s.lookahead &&
                        ((s.strstart = 0),
                        (s.block_start = 0),
                        (s.insert = 0)))),
                flush_pending(strm),
                0 === strm.avail_out)
              )
                return (s.last_flush = -1), Z_OK;
            }
            return flush !== Z_FINISH
              ? Z_OK
              : s.wrap <= 0
              ? Z_STREAM_END
              : (2 === s.wrap
                  ? (put_byte(s, 255 & strm.adler),
                    put_byte(s, (strm.adler >> 8) & 255),
                    put_byte(s, (strm.adler >> 16) & 255),
                    put_byte(s, (strm.adler >> 24) & 255),
                    put_byte(s, 255 & strm.total_in),
                    put_byte(s, (strm.total_in >> 8) & 255),
                    put_byte(s, (strm.total_in >> 16) & 255),
                    put_byte(s, (strm.total_in >> 24) & 255))
                  : (putShortMSB(s, strm.adler >>> 16),
                    putShortMSB(s, 65535 & strm.adler)),
                flush_pending(strm),
                s.wrap > 0 && (s.wrap = -s.wrap),
                0 !== s.pending ? Z_OK : Z_STREAM_END);
          }
          function deflateEnd(strm) {
            var status;
            return strm && strm.state
              ? (status = strm.state.status) !== INIT_STATE &&
                status !== EXTRA_STATE &&
                status !== NAME_STATE &&
                status !== COMMENT_STATE &&
                status !== HCRC_STATE &&
                status !== BUSY_STATE &&
                status !== FINISH_STATE
                ? err(strm, Z_STREAM_ERROR)
                : ((strm.state = null),
                  status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK)
              : Z_STREAM_ERROR;
          }
          (configuration_table = [
            new Config(0, 0, 0, 0, deflate_stored),
            new Config(4, 4, 8, 4, deflate_fast),
            new Config(4, 5, 16, 8, deflate_fast),
            new Config(4, 6, 32, 32, deflate_fast),
            new Config(4, 4, 16, 16, deflate_slow),
            new Config(8, 16, 32, 32, deflate_slow),
            new Config(8, 16, 128, 128, deflate_slow),
            new Config(8, 32, 128, 256, deflate_slow),
            new Config(32, 128, 258, 1024, deflate_slow),
            new Config(32, 258, 258, 4096, deflate_slow),
          ]),
            (exports.deflateInit = deflateInit),
            (exports.deflateInit2 = deflateInit2),
            (exports.deflateReset = deflateReset),
            (exports.deflateResetKeep = deflateResetKeep),
            (exports.deflateSetHeader = deflateSetHeader),
            (exports.deflate = deflate),
            (exports.deflateEnd = deflateEnd),
            (exports.deflateInfo = "pako deflate (from Nodeca project)");
        },
        {
          "../utils/common": 35,
          "./adler32": 37,
          "./crc32": 39,
          "./messages": 45,
          "./trees": 46,
        },
      ],
      41: [
        function (require, module, exports) {
          "use strict";
          function GZheader() {
            (this.text = 0),
              (this.time = 0),
              (this.xflags = 0),
              (this.os = 0),
              (this.extra = null),
              (this.extra_len = 0),
              (this.name = ""),
              (this.comment = ""),
              (this.hcrc = 0),
              (this.done = !1);
          }
          module.exports = GZheader;
        },
        {},
      ],
      42: [
        function (require, module, exports) {
          "use strict";
          var BAD = 30,
            TYPE = 12;
          module.exports = function inflate_fast(strm, start) {
            var state,
              _in,
              last,
              _out,
              beg,
              end,
              dmax,
              wsize,
              whave,
              wnext,
              window,
              hold,
              bits,
              lcode,
              dcode,
              lmask,
              dmask,
              here,
              op,
              len,
              dist,
              from,
              from_source,
              input,
              output;
            (state = strm.state),
              (_in = strm.next_in),
              (input = strm.input),
              (last = _in + (strm.avail_in - 5)),
              (_out = strm.next_out),
              (output = strm.output),
              (beg = _out - (start - strm.avail_out)),
              (end = _out + (strm.avail_out - 257)),
              (dmax = state.dmax),
              (wsize = state.wsize),
              (whave = state.whave),
              (wnext = state.wnext),
              (window = state.window),
              (hold = state.hold),
              (bits = state.bits),
              (lcode = state.lencode),
              (dcode = state.distcode),
              (lmask = (1 << state.lenbits) - 1),
              (dmask = (1 << state.distbits) - 1);
            top: do {
              bits < 15 &&
                ((hold += input[_in++] << bits),
                (bits += 8),
                (hold += input[_in++] << bits),
                (bits += 8)),
                (here = lcode[hold & lmask]);
              dolen: for (;;) {
                if (
                  ((hold >>>= op = here >>> 24),
                  (bits -= op),
                  0 === (op = (here >>> 16) & 255))
                )
                  output[_out++] = 65535 & here;
                else {
                  if (!(16 & op)) {
                    if (0 == (64 & op)) {
                      here = lcode[(65535 & here) + (hold & ((1 << op) - 1))];
                      continue dolen;
                    }
                    if (32 & op) {
                      state.mode = 12;
                      break top;
                    }
                    (strm.msg = "invalid literal/length code"),
                      (state.mode = 30);
                    break top;
                  }
                  (len = 65535 & here),
                    (op &= 15) &&
                      (bits < op &&
                        ((hold += input[_in++] << bits), (bits += 8)),
                      (len += hold & ((1 << op) - 1)),
                      (hold >>>= op),
                      (bits -= op)),
                    bits < 15 &&
                      ((hold += input[_in++] << bits),
                      (bits += 8),
                      (hold += input[_in++] << bits),
                      (bits += 8)),
                    (here = dcode[hold & dmask]);
                  dodist: for (;;) {
                    if (
                      ((hold >>>= op = here >>> 24),
                      (bits -= op),
                      !(16 & (op = (here >>> 16) & 255)))
                    ) {
                      if (0 == (64 & op)) {
                        here = dcode[(65535 & here) + (hold & ((1 << op) - 1))];
                        continue dodist;
                      }
                      (strm.msg = "invalid distance code"), (state.mode = 30);
                      break top;
                    }
                    if (
                      ((dist = 65535 & here),
                      bits < (op &= 15) &&
                        ((hold += input[_in++] << bits),
                        (bits += 8) < op &&
                          ((hold += input[_in++] << bits), (bits += 8))),
                      (dist += hold & ((1 << op) - 1)) > dmax)
                    ) {
                      (strm.msg = "invalid distance too far back"),
                        (state.mode = 30);
                      break top;
                    }
                    if (
                      ((hold >>>= op), (bits -= op), dist > (op = _out - beg))
                    ) {
                      if ((op = dist - op) > whave && state.sane) {
                        (strm.msg = "invalid distance too far back"),
                          (state.mode = 30);
                        break top;
                      }
                      if (((from = 0), (from_source = window), 0 === wnext)) {
                        if (((from += wsize - op), op < len)) {
                          len -= op;
                          do {
                            output[_out++] = window[from++];
                          } while (--op);
                          (from = _out - dist), (from_source = output);
                        }
                      } else if (wnext < op) {
                        if (
                          ((from += wsize + wnext - op), (op -= wnext) < len)
                        ) {
                          len -= op;
                          do {
                            output[_out++] = window[from++];
                          } while (--op);
                          if (((from = 0), wnext < len)) {
                            len -= op = wnext;
                            do {
                              output[_out++] = window[from++];
                            } while (--op);
                            (from = _out - dist), (from_source = output);
                          }
                        }
                      } else if (((from += wnext - op), op < len)) {
                        len -= op;
                        do {
                          output[_out++] = window[from++];
                        } while (--op);
                        (from = _out - dist), (from_source = output);
                      }
                      for (; len > 2; )
                        (output[_out++] = from_source[from++]),
                          (output[_out++] = from_source[from++]),
                          (output[_out++] = from_source[from++]),
                          (len -= 3);
                      len &&
                        ((output[_out++] = from_source[from++]),
                        len > 1 && (output[_out++] = from_source[from++]));
                    } else {
                      from = _out - dist;
                      do {
                        (output[_out++] = output[from++]),
                          (output[_out++] = output[from++]),
                          (output[_out++] = output[from++]),
                          (len -= 3);
                      } while (len > 2);
                      len &&
                        ((output[_out++] = output[from++]),
                        len > 1 && (output[_out++] = output[from++]));
                    }
                    break;
                  }
                }
                break;
              }
            } while (_in < last && _out < end);
            (_in -= len = bits >> 3),
              (hold &= (1 << (bits -= len << 3)) - 1),
              (strm.next_in = _in),
              (strm.next_out = _out),
              (strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last)),
              (strm.avail_out =
                _out < end ? end - _out + 257 : 257 - (_out - end)),
              (state.hold = hold),
              (state.bits = bits);
          };
        },
        {},
      ],
      43: [
        function (require, module, exports) {
          "use strict";
          var utils = require("../utils/common"),
            adler32 = require("./adler32"),
            crc32 = require("./crc32"),
            inflate_fast = require("./inffast"),
            inflate_table = require("./inftrees"),
            CODES = 0,
            LENS = 1,
            DISTS = 2,
            Z_FINISH = 4,
            Z_BLOCK = 5,
            Z_TREES = 6,
            Z_OK = 0,
            Z_STREAM_END = 1,
            Z_NEED_DICT = 2,
            Z_STREAM_ERROR = -2,
            Z_DATA_ERROR = -3,
            Z_MEM_ERROR = -4,
            Z_BUF_ERROR = -5,
            Z_DEFLATED = 8,
            HEAD = 1,
            FLAGS = 2,
            TIME = 3,
            OS = 4,
            EXLEN = 5,
            EXTRA = 6,
            NAME = 7,
            COMMENT = 8,
            HCRC = 9,
            DICTID = 10,
            DICT = 11,
            TYPE = 12,
            TYPEDO = 13,
            STORED = 14,
            COPY_ = 15,
            COPY = 16,
            TABLE = 17,
            LENLENS = 18,
            CODELENS = 19,
            LEN_ = 20,
            LEN = 21,
            LENEXT = 22,
            DIST = 23,
            DISTEXT = 24,
            MATCH = 25,
            LIT = 26,
            CHECK = 27,
            LENGTH = 28,
            DONE = 29,
            BAD = 30,
            MEM = 31,
            SYNC = 32,
            ENOUGH_LENS = 852,
            ENOUGH_DISTS = 592,
            MAX_WBITS = 15,
            DEF_WBITS = 15;
          function ZSWAP32(q) {
            return (
              ((q >>> 24) & 255) +
              ((q >>> 8) & 65280) +
              ((65280 & q) << 8) +
              ((255 & q) << 24)
            );
          }
          function InflateState() {
            (this.mode = 0),
              (this.last = !1),
              (this.wrap = 0),
              (this.havedict = !1),
              (this.flags = 0),
              (this.dmax = 0),
              (this.check = 0),
              (this.total = 0),
              (this.head = null),
              (this.wbits = 0),
              (this.wsize = 0),
              (this.whave = 0),
              (this.wnext = 0),
              (this.window = null),
              (this.hold = 0),
              (this.bits = 0),
              (this.length = 0),
              (this.offset = 0),
              (this.extra = 0),
              (this.lencode = null),
              (this.distcode = null),
              (this.lenbits = 0),
              (this.distbits = 0),
              (this.ncode = 0),
              (this.nlen = 0),
              (this.ndist = 0),
              (this.have = 0),
              (this.next = null),
              (this.lens = new utils.Buf16(320)),
              (this.work = new utils.Buf16(288)),
              (this.lendyn = null),
              (this.distdyn = null),
              (this.sane = 0),
              (this.back = 0),
              (this.was = 0);
          }
          function inflateResetKeep(strm) {
            var state;
            return strm && strm.state
              ? ((state = strm.state),
                (strm.total_in = strm.total_out = state.total = 0),
                (strm.msg = ""),
                state.wrap && (strm.adler = 1 & state.wrap),
                (state.mode = HEAD),
                (state.last = 0),
                (state.havedict = 0),
                (state.dmax = 32768),
                (state.head = null),
                (state.hold = 0),
                (state.bits = 0),
                (state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS)),
                (state.distcode = state.distdyn =
                  new utils.Buf32(ENOUGH_DISTS)),
                (state.sane = 1),
                (state.back = -1),
                Z_OK)
              : Z_STREAM_ERROR;
          }
          function inflateReset(strm) {
            var state;
            return strm && strm.state
              ? (((state = strm.state).wsize = 0),
                (state.whave = 0),
                (state.wnext = 0),
                inflateResetKeep(strm))
              : Z_STREAM_ERROR;
          }
          function inflateReset2(strm, windowBits) {
            var wrap, state;
            return strm && strm.state
              ? ((state = strm.state),
                windowBits < 0
                  ? ((wrap = 0), (windowBits = -windowBits))
                  : ((wrap = 1 + (windowBits >> 4)),
                    windowBits < 48 && (windowBits &= 15)),
                windowBits && (windowBits < 8 || windowBits > 15)
                  ? Z_STREAM_ERROR
                  : (null !== state.window &&
                      state.wbits !== windowBits &&
                      (state.window = null),
                    (state.wrap = wrap),
                    (state.wbits = windowBits),
                    inflateReset(strm)))
              : Z_STREAM_ERROR;
          }
          function inflateInit2(strm, windowBits) {
            var ret, state;
            return strm
              ? ((state = new InflateState()),
                (strm.state = state),
                (state.window = null),
                (ret = inflateReset2(strm, windowBits)) !== Z_OK &&
                  (strm.state = null),
                ret)
              : Z_STREAM_ERROR;
          }
          function inflateInit(strm) {
            return inflateInit2(strm, DEF_WBITS);
          }
          var virgin = !0,
            lenfix,
            distfix;
          function fixedtables(state) {
            if (virgin) {
              var sym;
              for (
                lenfix = new utils.Buf32(512),
                  distfix = new utils.Buf32(32),
                  sym = 0;
                sym < 144;

              )
                state.lens[sym++] = 8;
              for (; sym < 256; ) state.lens[sym++] = 9;
              for (; sym < 280; ) state.lens[sym++] = 7;
              for (; sym < 288; ) state.lens[sym++] = 8;
              for (
                inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                  bits: 9,
                }),
                  sym = 0;
                sym < 32;

              )
                state.lens[sym++] = 5;
              inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                bits: 5,
              }),
                (virgin = !1);
            }
            (state.lencode = lenfix),
              (state.lenbits = 9),
              (state.distcode = distfix),
              (state.distbits = 5);
          }
          function updatewindow(strm, src, end, copy) {
            var dist,
              state = strm.state;
            return (
              null === state.window &&
                ((state.wsize = 1 << state.wbits),
                (state.wnext = 0),
                (state.whave = 0),
                (state.window = new utils.Buf8(state.wsize))),
              copy >= state.wsize
                ? (utils.arraySet(
                    state.window,
                    src,
                    end - state.wsize,
                    state.wsize,
                    0
                  ),
                  (state.wnext = 0),
                  (state.whave = state.wsize))
                : ((dist = state.wsize - state.wnext) > copy && (dist = copy),
                  utils.arraySet(
                    state.window,
                    src,
                    end - copy,
                    dist,
                    state.wnext
                  ),
                  (copy -= dist)
                    ? (utils.arraySet(state.window, src, end - copy, copy, 0),
                      (state.wnext = copy),
                      (state.whave = state.wsize))
                    : ((state.wnext += dist),
                      state.wnext === state.wsize && (state.wnext = 0),
                      state.whave < state.wsize && (state.whave += dist))),
              0
            );
          }
          function inflate(strm, flush) {
            var state,
              input,
              output,
              next,
              put,
              have,
              left,
              hold,
              bits,
              _in,
              _out,
              copy,
              from,
              from_source,
              here = 0,
              here_bits,
              here_op,
              here_val,
              last_bits,
              last_op,
              last_val,
              len,
              ret,
              hbuf = new utils.Buf8(4),
              opts,
              n,
              order = [
                16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                15,
              ];
            if (
              !strm ||
              !strm.state ||
              !strm.output ||
              (!strm.input && 0 !== strm.avail_in)
            )
              return Z_STREAM_ERROR;
            (state = strm.state).mode === TYPE && (state.mode = TYPEDO),
              (put = strm.next_out),
              (output = strm.output),
              (left = strm.avail_out),
              (next = strm.next_in),
              (input = strm.input),
              (have = strm.avail_in),
              (hold = state.hold),
              (bits = state.bits),
              (_in = have),
              (_out = left),
              (ret = Z_OK);
            inf_leave: for (;;)
              switch (state.mode) {
                case HEAD:
                  if (0 === state.wrap) {
                    state.mode = TYPEDO;
                    break;
                  }
                  for (; bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if (2 & state.wrap && 35615 === hold) {
                    (state.check = 0),
                      (hbuf[0] = 255 & hold),
                      (hbuf[1] = (hold >>> 8) & 255),
                      (state.check = crc32(state.check, hbuf, 2, 0)),
                      (hold = 0),
                      (bits = 0),
                      (state.mode = FLAGS);
                    break;
                  }
                  if (
                    ((state.flags = 0),
                    state.head && (state.head.done = !1),
                    !(1 & state.wrap) ||
                      (((255 & hold) << 8) + (hold >> 8)) % 31)
                  ) {
                    (strm.msg = "incorrect header check"), (state.mode = BAD);
                    break;
                  }
                  if ((15 & hold) !== Z_DEFLATED) {
                    (strm.msg = "unknown compression method"),
                      (state.mode = BAD);
                    break;
                  }
                  if (
                    ((bits -= 4),
                    (len = 8 + (15 & (hold >>>= 4))),
                    0 === state.wbits)
                  )
                    state.wbits = len;
                  else if (len > state.wbits) {
                    (strm.msg = "invalid window size"), (state.mode = BAD);
                    break;
                  }
                  (state.dmax = 1 << len),
                    (strm.adler = state.check = 1),
                    (state.mode = 512 & hold ? DICTID : TYPE),
                    (hold = 0),
                    (bits = 0);
                  break;
                case FLAGS:
                  for (; bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if (
                    ((state.flags = hold), (255 & state.flags) !== Z_DEFLATED)
                  ) {
                    (strm.msg = "unknown compression method"),
                      (state.mode = BAD);
                    break;
                  }
                  if (57344 & state.flags) {
                    (strm.msg = "unknown header flags set"), (state.mode = BAD);
                    break;
                  }
                  state.head && (state.head.text = (hold >> 8) & 1),
                    512 & state.flags &&
                      ((hbuf[0] = 255 & hold),
                      (hbuf[1] = (hold >>> 8) & 255),
                      (state.check = crc32(state.check, hbuf, 2, 0))),
                    (hold = 0),
                    (bits = 0),
                    (state.mode = TIME);
                case TIME:
                  for (; bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  state.head && (state.head.time = hold),
                    512 & state.flags &&
                      ((hbuf[0] = 255 & hold),
                      (hbuf[1] = (hold >>> 8) & 255),
                      (hbuf[2] = (hold >>> 16) & 255),
                      (hbuf[3] = (hold >>> 24) & 255),
                      (state.check = crc32(state.check, hbuf, 4, 0))),
                    (hold = 0),
                    (bits = 0),
                    (state.mode = OS);
                case OS:
                  for (; bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  state.head &&
                    ((state.head.xflags = 255 & hold),
                    (state.head.os = hold >> 8)),
                    512 & state.flags &&
                      ((hbuf[0] = 255 & hold),
                      (hbuf[1] = (hold >>> 8) & 255),
                      (state.check = crc32(state.check, hbuf, 2, 0))),
                    (hold = 0),
                    (bits = 0),
                    (state.mode = EXLEN);
                case EXLEN:
                  if (1024 & state.flags) {
                    for (; bits < 16; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (state.length = hold),
                      state.head && (state.head.extra_len = hold),
                      512 & state.flags &&
                        ((hbuf[0] = 255 & hold),
                        (hbuf[1] = (hold >>> 8) & 255),
                        (state.check = crc32(state.check, hbuf, 2, 0))),
                      (hold = 0),
                      (bits = 0);
                  } else state.head && (state.head.extra = null);
                  state.mode = EXTRA;
                case EXTRA:
                  if (
                    1024 & state.flags &&
                    ((copy = state.length) > have && (copy = have),
                    copy &&
                      (state.head &&
                        ((len = state.head.extra_len - state.length),
                        state.head.extra ||
                          (state.head.extra = new Array(state.head.extra_len)),
                        utils.arraySet(
                          state.head.extra,
                          input,
                          next,
                          copy,
                          len
                        )),
                      512 & state.flags &&
                        (state.check = crc32(state.check, input, copy, next)),
                      (have -= copy),
                      (next += copy),
                      (state.length -= copy)),
                    state.length)
                  )
                    break inf_leave;
                  (state.length = 0), (state.mode = NAME);
                case NAME:
                  if (2048 & state.flags) {
                    if (0 === have) break inf_leave;
                    copy = 0;
                    do {
                      (len = input[next + copy++]),
                        state.head &&
                          len &&
                          state.length < 65536 &&
                          (state.head.name += String.fromCharCode(len));
                    } while (len && copy < have);
                    if (
                      (512 & state.flags &&
                        (state.check = crc32(state.check, input, copy, next)),
                      (have -= copy),
                      (next += copy),
                      len)
                    )
                      break inf_leave;
                  } else state.head && (state.head.name = null);
                  (state.length = 0), (state.mode = COMMENT);
                case COMMENT:
                  if (4096 & state.flags) {
                    if (0 === have) break inf_leave;
                    copy = 0;
                    do {
                      (len = input[next + copy++]),
                        state.head &&
                          len &&
                          state.length < 65536 &&
                          (state.head.comment += String.fromCharCode(len));
                    } while (len && copy < have);
                    if (
                      (512 & state.flags &&
                        (state.check = crc32(state.check, input, copy, next)),
                      (have -= copy),
                      (next += copy),
                      len)
                    )
                      break inf_leave;
                  } else state.head && (state.head.comment = null);
                  state.mode = HCRC;
                case HCRC:
                  if (512 & state.flags) {
                    for (; bits < 16; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    if (hold !== (65535 & state.check)) {
                      (strm.msg = "header crc mismatch"), (state.mode = BAD);
                      break;
                    }
                    (hold = 0), (bits = 0);
                  }
                  state.head &&
                    ((state.head.hcrc = (state.flags >> 9) & 1),
                    (state.head.done = !0)),
                    (strm.adler = state.check = 0),
                    (state.mode = TYPE);
                  break;
                case DICTID:
                  for (; bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  (strm.adler = state.check = ZSWAP32(hold)),
                    (hold = 0),
                    (bits = 0),
                    (state.mode = DICT);
                case DICT:
                  if (0 === state.havedict)
                    return (
                      (strm.next_out = put),
                      (strm.avail_out = left),
                      (strm.next_in = next),
                      (strm.avail_in = have),
                      (state.hold = hold),
                      (state.bits = bits),
                      Z_NEED_DICT
                    );
                  (strm.adler = state.check = 1), (state.mode = TYPE);
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
                case TYPEDO:
                  if (state.last) {
                    (hold >>>= 7 & bits),
                      (bits -= 7 & bits),
                      (state.mode = CHECK);
                    break;
                  }
                  for (; bits < 3; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  switch (
                    ((state.last = 1 & hold), (bits -= 1), 3 & (hold >>>= 1))
                  ) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      if (
                        (fixedtables(state),
                        (state.mode = LEN_),
                        flush === Z_TREES)
                      ) {
                        (hold >>>= 2), (bits -= 2);
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      (strm.msg = "invalid block type"), (state.mode = BAD);
                  }
                  (hold >>>= 2), (bits -= 2);
                  break;
                case STORED:
                  for (hold >>>= 7 & bits, bits -= 7 & bits; bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if ((65535 & hold) != ((hold >>> 16) ^ 65535)) {
                    (strm.msg = "invalid stored block lengths"),
                      (state.mode = BAD);
                    break;
                  }
                  if (
                    ((state.length = 65535 & hold),
                    (hold = 0),
                    (bits = 0),
                    (state.mode = COPY_),
                    flush === Z_TREES)
                  )
                    break inf_leave;
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  if ((copy = state.length)) {
                    if (
                      (copy > have && (copy = have),
                      copy > left && (copy = left),
                      0 === copy)
                    )
                      break inf_leave;
                    utils.arraySet(output, input, next, copy, put),
                      (have -= copy),
                      (next += copy),
                      (left -= copy),
                      (put += copy),
                      (state.length -= copy);
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  for (; bits < 14; ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if (
                    ((state.nlen = 257 + (31 & hold)),
                    (hold >>>= 5),
                    (bits -= 5),
                    (state.ndist = 1 + (31 & hold)),
                    (hold >>>= 5),
                    (bits -= 5),
                    (state.ncode = 4 + (15 & hold)),
                    (hold >>>= 4),
                    (bits -= 4),
                    state.nlen > 286 || state.ndist > 30)
                  ) {
                    (strm.msg = "too many length or distance symbols"),
                      (state.mode = BAD);
                    break;
                  }
                  (state.have = 0), (state.mode = LENLENS);
                case LENLENS:
                  for (; state.have < state.ncode; ) {
                    for (; bits < 3; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (state.lens[order[state.have++]] = 7 & hold),
                      (hold >>>= 3),
                      (bits -= 3);
                  }
                  for (; state.have < 19; ) state.lens[order[state.have++]] = 0;
                  if (
                    ((state.lencode = state.lendyn),
                    (state.lenbits = 7),
                    (opts = { bits: state.lenbits }),
                    (ret = inflate_table(
                      CODES,
                      state.lens,
                      0,
                      19,
                      state.lencode,
                      0,
                      state.work,
                      opts
                    )),
                    (state.lenbits = opts.bits),
                    ret)
                  ) {
                    (strm.msg = "invalid code lengths set"), (state.mode = BAD);
                    break;
                  }
                  (state.have = 0), (state.mode = CODELENS);
                case CODELENS:
                  for (; state.have < state.nlen + state.ndist; ) {
                    for (
                      ;
                      (here_op =
                        ((here =
                          state.lencode[hold & ((1 << state.lenbits) - 1)]) >>>
                          16) &
                        255),
                        (here_val = 65535 & here),
                        !((here_bits = here >>> 24) <= bits);

                    ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    if (here_val < 16)
                      (hold >>>= here_bits),
                        (bits -= here_bits),
                        (state.lens[state.have++] = here_val);
                    else {
                      if (16 === here_val) {
                        for (n = here_bits + 2; bits < n; ) {
                          if (0 === have) break inf_leave;
                          have--, (hold += input[next++] << bits), (bits += 8);
                        }
                        if (
                          ((hold >>>= here_bits),
                          (bits -= here_bits),
                          0 === state.have)
                        ) {
                          (strm.msg = "invalid bit length repeat"),
                            (state.mode = BAD);
                          break;
                        }
                        (len = state.lens[state.have - 1]),
                          (copy = 3 + (3 & hold)),
                          (hold >>>= 2),
                          (bits -= 2);
                      } else if (17 === here_val) {
                        for (n = here_bits + 3; bits < n; ) {
                          if (0 === have) break inf_leave;
                          have--, (hold += input[next++] << bits), (bits += 8);
                        }
                        (bits -= here_bits),
                          (len = 0),
                          (copy = 3 + (7 & (hold >>>= here_bits))),
                          (hold >>>= 3),
                          (bits -= 3);
                      } else {
                        for (n = here_bits + 7; bits < n; ) {
                          if (0 === have) break inf_leave;
                          have--, (hold += input[next++] << bits), (bits += 8);
                        }
                        (bits -= here_bits),
                          (len = 0),
                          (copy = 11 + (127 & (hold >>>= here_bits))),
                          (hold >>>= 7),
                          (bits -= 7);
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        (strm.msg = "invalid bit length repeat"),
                          (state.mode = BAD);
                        break;
                      }
                      for (; copy--; ) state.lens[state.have++] = len;
                    }
                  }
                  if (state.mode === BAD) break;
                  if (0 === state.lens[256]) {
                    (strm.msg = "invalid code -- missing end-of-block"),
                      (state.mode = BAD);
                    break;
                  }
                  if (
                    ((state.lenbits = 9),
                    (opts = { bits: state.lenbits }),
                    (ret = inflate_table(
                      LENS,
                      state.lens,
                      0,
                      state.nlen,
                      state.lencode,
                      0,
                      state.work,
                      opts
                    )),
                    (state.lenbits = opts.bits),
                    ret)
                  ) {
                    (strm.msg = "invalid literal/lengths set"),
                      (state.mode = BAD);
                    break;
                  }
                  if (
                    ((state.distbits = 6),
                    (state.distcode = state.distdyn),
                    (opts = { bits: state.distbits }),
                    (ret = inflate_table(
                      DISTS,
                      state.lens,
                      state.nlen,
                      state.ndist,
                      state.distcode,
                      0,
                      state.work,
                      opts
                    )),
                    (state.distbits = opts.bits),
                    ret)
                  ) {
                    (strm.msg = "invalid distances set"), (state.mode = BAD);
                    break;
                  }
                  if (((state.mode = LEN_), flush === Z_TREES)) break inf_leave;
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    (strm.next_out = put),
                      (strm.avail_out = left),
                      (strm.next_in = next),
                      (strm.avail_in = have),
                      (state.hold = hold),
                      (state.bits = bits),
                      inflate_fast(strm, _out),
                      (put = strm.next_out),
                      (output = strm.output),
                      (left = strm.avail_out),
                      (next = strm.next_in),
                      (input = strm.input),
                      (have = strm.avail_in),
                      (hold = state.hold),
                      (bits = state.bits),
                      state.mode === TYPE && (state.back = -1);
                    break;
                  }
                  for (
                    state.back = 0;
                    (here_op =
                      ((here =
                        state.lencode[hold & ((1 << state.lenbits) - 1)]) >>>
                        16) &
                      255),
                      (here_val = 65535 & here),
                      !((here_bits = here >>> 24) <= bits);

                  ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if (here_op && 0 == (240 & here_op)) {
                    for (
                      last_bits = here_bits,
                        last_op = here_op,
                        last_val = here_val;
                      (here_op =
                        ((here =
                          state.lencode[
                            last_val +
                              ((hold & ((1 << (last_bits + last_op)) - 1)) >>
                                last_bits)
                          ]) >>>
                          16) &
                        255),
                        (here_val = 65535 & here),
                        !(last_bits + (here_bits = here >>> 24) <= bits);

                    ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (hold >>>= last_bits),
                      (bits -= last_bits),
                      (state.back += last_bits);
                  }
                  if (
                    ((hold >>>= here_bits),
                    (bits -= here_bits),
                    (state.back += here_bits),
                    (state.length = here_val),
                    0 === here_op)
                  ) {
                    state.mode = LIT;
                    break;
                  }
                  if (32 & here_op) {
                    (state.back = -1), (state.mode = TYPE);
                    break;
                  }
                  if (64 & here_op) {
                    (strm.msg = "invalid literal/length code"),
                      (state.mode = BAD);
                    break;
                  }
                  (state.extra = 15 & here_op), (state.mode = LENEXT);
                case LENEXT:
                  if (state.extra) {
                    for (n = state.extra; bits < n; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (state.length += hold & ((1 << state.extra) - 1)),
                      (hold >>>= state.extra),
                      (bits -= state.extra),
                      (state.back += state.extra);
                  }
                  (state.was = state.length), (state.mode = DIST);
                case DIST:
                  for (
                    ;
                    (here_op =
                      ((here =
                        state.distcode[hold & ((1 << state.distbits) - 1)]) >>>
                        16) &
                      255),
                      (here_val = 65535 & here),
                      !((here_bits = here >>> 24) <= bits);

                  ) {
                    if (0 === have) break inf_leave;
                    have--, (hold += input[next++] << bits), (bits += 8);
                  }
                  if (0 == (240 & here_op)) {
                    for (
                      last_bits = here_bits,
                        last_op = here_op,
                        last_val = here_val;
                      (here_op =
                        ((here =
                          state.distcode[
                            last_val +
                              ((hold & ((1 << (last_bits + last_op)) - 1)) >>
                                last_bits)
                          ]) >>>
                          16) &
                        255),
                        (here_val = 65535 & here),
                        !(last_bits + (here_bits = here >>> 24) <= bits);

                    ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (hold >>>= last_bits),
                      (bits -= last_bits),
                      (state.back += last_bits);
                  }
                  if (
                    ((hold >>>= here_bits),
                    (bits -= here_bits),
                    (state.back += here_bits),
                    64 & here_op)
                  ) {
                    (strm.msg = "invalid distance code"), (state.mode = BAD);
                    break;
                  }
                  (state.offset = here_val),
                    (state.extra = 15 & here_op),
                    (state.mode = DISTEXT);
                case DISTEXT:
                  if (state.extra) {
                    for (n = state.extra; bits < n; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    (state.offset += hold & ((1 << state.extra) - 1)),
                      (hold >>>= state.extra),
                      (bits -= state.extra),
                      (state.back += state.extra);
                  }
                  if (state.offset > state.dmax) {
                    (strm.msg = "invalid distance too far back"),
                      (state.mode = BAD);
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (0 === left) break inf_leave;
                  if (((copy = _out - left), state.offset > copy)) {
                    if (
                      (copy = state.offset - copy) > state.whave &&
                      state.sane
                    ) {
                      (strm.msg = "invalid distance too far back"),
                        (state.mode = BAD);
                      break;
                    }
                    copy > state.wnext
                      ? ((copy -= state.wnext), (from = state.wsize - copy))
                      : (from = state.wnext - copy),
                      copy > state.length && (copy = state.length),
                      (from_source = state.window);
                  } else
                    (from_source = output),
                      (from = put - state.offset),
                      (copy = state.length);
                  copy > left && (copy = left),
                    (left -= copy),
                    (state.length -= copy);
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  0 === state.length && (state.mode = LEN);
                  break;
                case LIT:
                  if (0 === left) break inf_leave;
                  (output[put++] = state.length), left--, (state.mode = LEN);
                  break;
                case CHECK:
                  if (state.wrap) {
                    for (; bits < 32; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold |= input[next++] << bits), (bits += 8);
                    }
                    if (
                      ((_out -= left),
                      (strm.total_out += _out),
                      (state.total += _out),
                      _out &&
                        (strm.adler = state.check =
                          state.flags
                            ? crc32(state.check, output, _out, put - _out)
                            : adler32(state.check, output, _out, put - _out)),
                      (_out = left),
                      (state.flags ? hold : ZSWAP32(hold)) !== state.check)
                    ) {
                      (strm.msg = "incorrect data check"), (state.mode = BAD);
                      break;
                    }
                    (hold = 0), (bits = 0);
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    for (; bits < 32; ) {
                      if (0 === have) break inf_leave;
                      have--, (hold += input[next++] << bits), (bits += 8);
                    }
                    if (hold !== (4294967295 & state.total)) {
                      (strm.msg = "incorrect length check"), (state.mode = BAD);
                      break;
                    }
                    (hold = 0), (bits = 0);
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            return (
              (strm.next_out = put),
              (strm.avail_out = left),
              (strm.next_in = next),
              (strm.avail_in = have),
              (state.hold = hold),
              (state.bits = bits),
              (state.wsize ||
                (_out !== strm.avail_out &&
                  state.mode < BAD &&
                  (state.mode < CHECK || flush !== Z_FINISH))) &&
              updatewindow(
                strm,
                strm.output,
                strm.next_out,
                _out - strm.avail_out
              )
                ? ((state.mode = MEM), Z_MEM_ERROR)
                : ((_in -= strm.avail_in),
                  (_out -= strm.avail_out),
                  (strm.total_in += _in),
                  (strm.total_out += _out),
                  (state.total += _out),
                  state.wrap &&
                    _out &&
                    (strm.adler = state.check =
                      state.flags
                        ? crc32(state.check, output, _out, strm.next_out - _out)
                        : adler32(
                            state.check,
                            output,
                            _out,
                            strm.next_out - _out
                          )),
                  (strm.data_type =
                    state.bits +
                    (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0)),
                  ((0 === _in && 0 === _out) || flush === Z_FINISH) &&
                    ret === Z_OK &&
                    (ret = Z_BUF_ERROR),
                  ret)
            );
          }
          function inflateEnd(strm) {
            if (!strm || !strm.state) return Z_STREAM_ERROR;
            var state = strm.state;
            return (
              state.window && (state.window = null), (strm.state = null), Z_OK
            );
          }
          function inflateGetHeader(strm, head) {
            var state;
            return strm && strm.state
              ? 0 == (2 & (state = strm.state).wrap)
                ? Z_STREAM_ERROR
                : ((state.head = head), (head.done = !1), Z_OK)
              : Z_STREAM_ERROR;
          }
          (exports.inflateReset = inflateReset),
            (exports.inflateReset2 = inflateReset2),
            (exports.inflateResetKeep = inflateResetKeep),
            (exports.inflateInit = inflateInit),
            (exports.inflateInit2 = inflateInit2),
            (exports.inflate = inflate),
            (exports.inflateEnd = inflateEnd),
            (exports.inflateGetHeader = inflateGetHeader),
            (exports.inflateInfo = "pako inflate (from Nodeca project)");
        },
        {
          "../utils/common": 35,
          "./adler32": 37,
          "./crc32": 39,
          "./inffast": 42,
          "./inftrees": 44,
        },
      ],
      44: [
        function (require, module, exports) {
          "use strict";
          var utils = require("../utils/common"),
            MAXBITS = 15,
            ENOUGH_LENS = 852,
            ENOUGH_DISTS = 592,
            CODES = 0,
            LENS = 1,
            DISTS = 2,
            lbase = [
              3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43,
              51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
            ],
            lext = [
              16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
              19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
            ],
            dbase = [
              1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257,
              385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289,
              16385, 24577, 0, 0,
            ],
            dext = [
              16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
              23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
            ];
          module.exports = function inflate_table(
            type,
            lens,
            lens_index,
            codes,
            table,
            table_index,
            work,
            opts
          ) {
            var bits = opts.bits,
              len = 0,
              sym = 0,
              min = 0,
              max = 0,
              root = 0,
              curr = 0,
              drop = 0,
              left = 0,
              used = 0,
              huff = 0,
              incr,
              fill,
              low,
              mask,
              next,
              base = null,
              base_index = 0,
              end,
              count = new utils.Buf16(16),
              offs = new utils.Buf16(16),
              extra = null,
              extra_index = 0,
              here_bits,
              here_op,
              here_val;
            for (len = 0; len <= 15; len++) count[len] = 0;
            for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
            for (root = bits, max = 15; max >= 1 && 0 === count[max]; max--);
            if ((root > max && (root = max), 0 === max))
              return (
                (table[table_index++] = 20971520),
                (table[table_index++] = 20971520),
                (opts.bits = 1),
                0
              );
            for (min = 1; min < max && 0 === count[min]; min++);
            for (
              root < min && (root = min), left = 1, len = 1;
              len <= 15;
              len++
            )
              if (((left <<= 1), (left -= count[len]) < 0)) return -1;
            if (left > 0 && (0 === type || 1 !== max)) return -1;
            for (offs[1] = 0, len = 1; len < 15; len++)
              offs[len + 1] = offs[len] + count[len];
            for (sym = 0; sym < codes; sym++)
              0 !== lens[lens_index + sym] &&
                (work[offs[lens[lens_index + sym]]++] = sym);
            if (
              (0 === type
                ? ((base = extra = work), (end = 19))
                : 1 === type
                ? ((base = lbase),
                  (base_index -= 257),
                  (extra = lext),
                  (extra_index -= 257),
                  (end = 256))
                : ((base = dbase), (extra = dext), (end = -1)),
              (huff = 0),
              (sym = 0),
              (len = min),
              (next = table_index),
              (curr = root),
              (drop = 0),
              (low = -1),
              (mask = (used = 1 << root) - 1),
              (1 === type && used > 852) || (2 === type && used > 592))
            )
              return 1;
            for (var i = 0; ; ) {
              i++,
                (here_bits = len - drop),
                work[sym] < end
                  ? ((here_op = 0), (here_val = work[sym]))
                  : work[sym] > end
                  ? ((here_op = extra[extra_index + work[sym]]),
                    (here_val = base[base_index + work[sym]]))
                  : ((here_op = 96), (here_val = 0)),
                (incr = 1 << (len - drop)),
                (min = fill = 1 << curr);
              do {
                table[next + (huff >> drop) + (fill -= incr)] =
                  (here_bits << 24) | (here_op << 16) | here_val | 0;
              } while (0 !== fill);
              for (incr = 1 << (len - 1); huff & incr; ) incr >>= 1;
              if (
                (0 !== incr ? ((huff &= incr - 1), (huff += incr)) : (huff = 0),
                sym++,
                0 == --count[len])
              ) {
                if (len === max) break;
                len = lens[lens_index + work[sym]];
              }
              if (len > root && (huff & mask) !== low) {
                for (
                  0 === drop && (drop = root),
                    next += min,
                    left = 1 << (curr = len - drop);
                  curr + drop < max && !((left -= count[curr + drop]) <= 0);

                )
                  curr++, (left <<= 1);
                if (
                  ((used += 1 << curr),
                  (1 === type && used > 852) || (2 === type && used > 592))
                )
                  return 1;
                table[(low = huff & mask)] =
                  (root << 24) | (curr << 16) | (next - table_index) | 0;
              }
            }
            return (
              0 !== huff &&
                (table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0),
              (opts.bits = root),
              0
            );
          };
        },
        { "../utils/common": 35 },
      ],
      45: [
        function (require, module, exports) {
          "use strict";
          module.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version",
          };
        },
        {},
      ],
      46: [
        function (require, module, exports) {
          "use strict";
          var utils = require("../utils/common"),
            Z_FIXED = 4,
            Z_BINARY = 0,
            Z_TEXT = 1,
            Z_UNKNOWN = 2;
          function zero(buf) {
            for (var len = buf.length; --len >= 0; ) buf[len] = 0;
          }
          var STORED_BLOCK = 0,
            STATIC_TREES = 1,
            DYN_TREES = 2,
            MIN_MATCH = 3,
            MAX_MATCH = 258,
            LENGTH_CODES = 29,
            LITERALS = 256,
            L_CODES = LITERALS + 1 + LENGTH_CODES,
            D_CODES = 30,
            BL_CODES = 19,
            HEAP_SIZE = 2 * L_CODES + 1,
            MAX_BITS = 15,
            Buf_size = 16,
            MAX_BL_BITS = 7,
            END_BLOCK = 256,
            REP_3_6 = 16,
            REPZ_3_10 = 17,
            REPZ_11_138 = 18,
            extra_lbits = [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
              4, 4, 5, 5, 5, 5, 0,
            ],
            extra_dbits = [
              0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
              10, 10, 11, 11, 12, 12, 13, 13,
            ],
            extra_blbits = [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,
            ],
            bl_order = [
              16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
            ],
            DIST_CODE_LEN = 512,
            static_ltree = new Array(2 * (L_CODES + 2));
          zero(static_ltree);
          var static_dtree = new Array(2 * D_CODES);
          zero(static_dtree);
          var _dist_code = new Array(512);
          zero(_dist_code);
          var _length_code = new Array(256);
          zero(_length_code);
          var base_length = new Array(LENGTH_CODES);
          zero(base_length);
          var base_dist = new Array(D_CODES);
          zero(base_dist);
          var StaticTreeDesc = function (
              static_tree,
              extra_bits,
              extra_base,
              elems,
              max_length
            ) {
              (this.static_tree = static_tree),
                (this.extra_bits = extra_bits),
                (this.extra_base = extra_base),
                (this.elems = elems),
                (this.max_length = max_length),
                (this.has_stree = static_tree && static_tree.length);
            },
            static_l_desc,
            static_d_desc,
            static_bl_desc,
            TreeDesc = function (dyn_tree, stat_desc) {
              (this.dyn_tree = dyn_tree),
                (this.max_code = 0),
                (this.stat_desc = stat_desc);
            };
          function d_code(dist) {
            return dist < 256
              ? _dist_code[dist]
              : _dist_code[256 + (dist >>> 7)];
          }
          function put_short(s, w) {
            (s.pending_buf[s.pending++] = 255 & w),
              (s.pending_buf[s.pending++] = (w >>> 8) & 255);
          }
          function send_bits(s, value, length) {
            s.bi_valid > Buf_size - length
              ? ((s.bi_buf |= (value << s.bi_valid) & 65535),
                put_short(s, s.bi_buf),
                (s.bi_buf = value >> (Buf_size - s.bi_valid)),
                (s.bi_valid += length - Buf_size))
              : ((s.bi_buf |= (value << s.bi_valid) & 65535),
                (s.bi_valid += length));
          }
          function send_code(s, c, tree) {
            send_bits(s, tree[2 * c], tree[2 * c + 1]);
          }
          function bi_reverse(code, len) {
            var res = 0;
            do {
              (res |= 1 & code), (code >>>= 1), (res <<= 1);
            } while (--len > 0);
            return res >>> 1;
          }
          function bi_flush(s) {
            16 === s.bi_valid
              ? (put_short(s, s.bi_buf), (s.bi_buf = 0), (s.bi_valid = 0))
              : s.bi_valid >= 8 &&
                ((s.pending_buf[s.pending++] = 255 & s.bi_buf),
                (s.bi_buf >>= 8),
                (s.bi_valid -= 8));
          }
          function gen_bitlen(s, desc) {
            var tree = desc.dyn_tree,
              max_code = desc.max_code,
              stree = desc.stat_desc.static_tree,
              has_stree = desc.stat_desc.has_stree,
              extra = desc.stat_desc.extra_bits,
              base = desc.stat_desc.extra_base,
              max_length = desc.stat_desc.max_length,
              h,
              n,
              m,
              bits,
              xbits,
              f,
              overflow = 0;
            for (bits = 0; bits <= MAX_BITS; bits++) s.bl_count[bits] = 0;
            for (
              tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1;
              h < HEAP_SIZE;
              h++
            )
              (bits = tree[2 * tree[2 * (n = s.heap[h]) + 1] + 1] + 1) >
                max_length && ((bits = max_length), overflow++),
                (tree[2 * n + 1] = bits),
                n > max_code ||
                  (s.bl_count[bits]++,
                  (xbits = 0),
                  n >= base && (xbits = extra[n - base]),
                  (f = tree[2 * n]),
                  (s.opt_len += f * (bits + xbits)),
                  has_stree &&
                    (s.static_len += f * (stree[2 * n + 1] + xbits)));
            if (0 !== overflow) {
              do {
                for (bits = max_length - 1; 0 === s.bl_count[bits]; ) bits--;
                s.bl_count[bits]--,
                  (s.bl_count[bits + 1] += 2),
                  s.bl_count[max_length]--,
                  (overflow -= 2);
              } while (overflow > 0);
              for (bits = max_length; 0 !== bits; bits--)
                for (n = s.bl_count[bits]; 0 !== n; )
                  (m = s.heap[--h]) > max_code ||
                    (tree[2 * m + 1] !== bits &&
                      ((s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m]),
                      (tree[2 * m + 1] = bits)),
                    n--);
            }
          }
          function gen_codes(tree, max_code, bl_count) {
            var next_code = new Array(MAX_BITS + 1),
              code = 0,
              bits,
              n;
            for (bits = 1; bits <= MAX_BITS; bits++)
              next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
            for (n = 0; n <= max_code; n++) {
              var len = tree[2 * n + 1];
              0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len));
            }
          }
          function tr_static_init() {
            var n,
              bits,
              length,
              code,
              dist,
              bl_count = new Array(MAX_BITS + 1);
            for (length = 0, code = 0; code < LENGTH_CODES - 1; code++)
              for (
                base_length[code] = length, n = 0;
                n < 1 << extra_lbits[code];
                n++
              )
                _length_code[length++] = code;
            for (
              _length_code[length - 1] = code, dist = 0, code = 0;
              code < 16;
              code++
            )
              for (
                base_dist[code] = dist, n = 0;
                n < 1 << extra_dbits[code];
                n++
              )
                _dist_code[dist++] = code;
            for (dist >>= 7; code < D_CODES; code++)
              for (
                base_dist[code] = dist << 7, n = 0;
                n < 1 << (extra_dbits[code] - 7);
                n++
              )
                _dist_code[256 + dist++] = code;
            for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
            for (n = 0; n <= 143; )
              (static_ltree[2 * n + 1] = 8), n++, bl_count[8]++;
            for (; n <= 255; )
              (static_ltree[2 * n + 1] = 9), n++, bl_count[9]++;
            for (; n <= 279; )
              (static_ltree[2 * n + 1] = 7), n++, bl_count[7]++;
            for (; n <= 287; )
              (static_ltree[2 * n + 1] = 8), n++, bl_count[8]++;
            for (
              gen_codes(static_ltree, L_CODES + 1, bl_count), n = 0;
              n < D_CODES;
              n++
            )
              (static_dtree[2 * n + 1] = 5),
                (static_dtree[2 * n] = bi_reverse(n, 5));
            (static_l_desc = new StaticTreeDesc(
              static_ltree,
              extra_lbits,
              LITERALS + 1,
              L_CODES,
              MAX_BITS
            )),
              (static_d_desc = new StaticTreeDesc(
                static_dtree,
                extra_dbits,
                0,
                D_CODES,
                MAX_BITS
              )),
              (static_bl_desc = new StaticTreeDesc(
                new Array(0),
                extra_blbits,
                0,
                BL_CODES,
                MAX_BL_BITS
              ));
          }
          function init_block(s) {
            var n;
            for (n = 0; n < L_CODES; n++) s.dyn_ltree[2 * n] = 0;
            for (n = 0; n < D_CODES; n++) s.dyn_dtree[2 * n] = 0;
            for (n = 0; n < BL_CODES; n++) s.bl_tree[2 * n] = 0;
            (s.dyn_ltree[2 * END_BLOCK] = 1),
              (s.opt_len = s.static_len = 0),
              (s.last_lit = s.matches = 0);
          }
          function bi_windup(s) {
            s.bi_valid > 8
              ? put_short(s, s.bi_buf)
              : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf),
              (s.bi_buf = 0),
              (s.bi_valid = 0);
          }
          function copy_block(s, buf, len, header) {
            bi_windup(s),
              header && (put_short(s, len), put_short(s, ~len)),
              utils.arraySet(s.pending_buf, s.window, buf, len, s.pending),
              (s.pending += len);
          }
          function smaller(tree, n, m, depth) {
            var _n2 = 2 * n,
              _m2 = 2 * m;
            return (
              tree[_n2] < tree[_m2] ||
              (tree[_n2] === tree[_m2] && depth[n] <= depth[m])
            );
          }
          function pqdownheap(s, tree, k) {
            for (
              var v = s.heap[k], j = k << 1;
              j <= s.heap_len &&
              (j < s.heap_len &&
                smaller(tree, s.heap[j + 1], s.heap[j], s.depth) &&
                j++,
              !smaller(tree, v, s.heap[j], s.depth));

            )
              (s.heap[k] = s.heap[j]), (k = j), (j <<= 1);
            s.heap[k] = v;
          }
          function compress_block(s, ltree, dtree) {
            var dist,
              lc,
              lx = 0,
              code,
              extra;
            if (0 !== s.last_lit)
              do {
                (dist =
                  (s.pending_buf[s.d_buf + 2 * lx] << 8) |
                  s.pending_buf[s.d_buf + 2 * lx + 1]),
                  (lc = s.pending_buf[s.l_buf + lx]),
                  lx++,
                  0 === dist
                    ? send_code(s, lc, ltree)
                    : (send_code(
                        s,
                        (code = _length_code[lc]) + LITERALS + 1,
                        ltree
                      ),
                      0 !== (extra = extra_lbits[code]) &&
                        send_bits(s, (lc -= base_length[code]), extra),
                      send_code(s, (code = d_code(--dist)), dtree),
                      0 !== (extra = extra_dbits[code]) &&
                        send_bits(s, (dist -= base_dist[code]), extra));
              } while (lx < s.last_lit);
            send_code(s, END_BLOCK, ltree);
          }
          function build_tree(s, desc) {
            var tree = desc.dyn_tree,
              stree = desc.stat_desc.static_tree,
              has_stree = desc.stat_desc.has_stree,
              elems = desc.stat_desc.elems,
              n,
              m,
              max_code = -1,
              node;
            for (s.heap_len = 0, s.heap_max = HEAP_SIZE, n = 0; n < elems; n++)
              0 !== tree[2 * n]
                ? ((s.heap[++s.heap_len] = max_code = n), (s.depth[n] = 0))
                : (tree[2 * n + 1] = 0);
            for (; s.heap_len < 2; )
              (tree[
                2 *
                  (node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0)
              ] = 1),
                (s.depth[node] = 0),
                s.opt_len--,
                has_stree && (s.static_len -= stree[2 * node + 1]);
            for (desc.max_code = max_code, n = s.heap_len >> 1; n >= 1; n--)
              pqdownheap(s, tree, n);
            node = elems;
            do {
              (n = s.heap[1]),
                (s.heap[1] = s.heap[s.heap_len--]),
                pqdownheap(s, tree, 1),
                (m = s.heap[1]),
                (s.heap[--s.heap_max] = n),
                (s.heap[--s.heap_max] = m),
                (tree[2 * node] = tree[2 * n] + tree[2 * m]),
                (s.depth[node] =
                  (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1),
                (tree[2 * n + 1] = tree[2 * m + 1] = node),
                (s.heap[1] = node++),
                pqdownheap(s, tree, 1);
            } while (s.heap_len >= 2);
            (s.heap[--s.heap_max] = s.heap[1]),
              gen_bitlen(s, desc),
              gen_codes(tree, max_code, s.bl_count);
          }
          function scan_tree(s, tree, max_code) {
            var n,
              prevlen = -1,
              curlen,
              nextlen = tree[1],
              count = 0,
              max_count = 7,
              min_count = 4;
            for (
              0 === nextlen && ((max_count = 138), (min_count = 3)),
                tree[2 * (max_code + 1) + 1] = 65535,
                n = 0;
              n <= max_code;
              n++
            )
              (curlen = nextlen),
                (nextlen = tree[2 * (n + 1) + 1]),
                (++count < max_count && curlen === nextlen) ||
                  (count < min_count
                    ? (s.bl_tree[2 * curlen] += count)
                    : 0 !== curlen
                    ? (curlen !== prevlen && s.bl_tree[2 * curlen]++,
                      s.bl_tree[2 * REP_3_6]++)
                    : count <= 10
                    ? s.bl_tree[2 * REPZ_3_10]++
                    : s.bl_tree[2 * REPZ_11_138]++,
                  (count = 0),
                  (prevlen = curlen),
                  0 === nextlen
                    ? ((max_count = 138), (min_count = 3))
                    : curlen === nextlen
                    ? ((max_count = 6), (min_count = 3))
                    : ((max_count = 7), (min_count = 4)));
          }
          function send_tree(s, tree, max_code) {
            var n,
              prevlen = -1,
              curlen,
              nextlen = tree[1],
              count = 0,
              max_count = 7,
              min_count = 4;
            for (
              0 === nextlen && ((max_count = 138), (min_count = 3)), n = 0;
              n <= max_code;
              n++
            )
              if (
                ((curlen = nextlen),
                (nextlen = tree[2 * (n + 1) + 1]),
                !(++count < max_count && curlen === nextlen))
              ) {
                if (count < min_count)
                  do {
                    send_code(s, curlen, s.bl_tree);
                  } while (0 != --count);
                else
                  0 !== curlen
                    ? (curlen !== prevlen &&
                        (send_code(s, curlen, s.bl_tree), count--),
                      send_code(s, REP_3_6, s.bl_tree),
                      send_bits(s, count - 3, 2))
                    : count <= 10
                    ? (send_code(s, REPZ_3_10, s.bl_tree),
                      send_bits(s, count - 3, 3))
                    : (send_code(s, REPZ_11_138, s.bl_tree),
                      send_bits(s, count - 11, 7));
                (count = 0),
                  (prevlen = curlen),
                  0 === nextlen
                    ? ((max_count = 138), (min_count = 3))
                    : curlen === nextlen
                    ? ((max_count = 6), (min_count = 3))
                    : ((max_count = 7), (min_count = 4));
              }
          }
          function build_bl_tree(s) {
            var max_blindex;
            for (
              scan_tree(s, s.dyn_ltree, s.l_desc.max_code),
                scan_tree(s, s.dyn_dtree, s.d_desc.max_code),
                build_tree(s, s.bl_desc),
                max_blindex = BL_CODES - 1;
              max_blindex >= 3 &&
              0 === s.bl_tree[2 * bl_order[max_blindex] + 1];
              max_blindex--
            );
            return (
              (s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4), max_blindex
            );
          }
          function send_all_trees(s, lcodes, dcodes, blcodes) {
            var rank;
            for (
              send_bits(s, lcodes - 257, 5),
                send_bits(s, dcodes - 1, 5),
                send_bits(s, blcodes - 4, 4),
                rank = 0;
              rank < blcodes;
              rank++
            )
              send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
            send_tree(s, s.dyn_ltree, lcodes - 1),
              send_tree(s, s.dyn_dtree, dcodes - 1);
          }
          function detect_data_type(s) {
            var black_mask = 4093624447,
              n;
            for (n = 0; n <= 31; n++, black_mask >>>= 1)
              if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return Z_BINARY;
            if (
              0 !== s.dyn_ltree[18] ||
              0 !== s.dyn_ltree[20] ||
              0 !== s.dyn_ltree[26]
            )
              return Z_TEXT;
            for (n = 32; n < LITERALS; n++)
              if (0 !== s.dyn_ltree[2 * n]) return Z_TEXT;
            return Z_BINARY;
          }
          var static_init_done = !1;
          function _tr_init(s) {
            static_init_done || (tr_static_init(), (static_init_done = !0)),
              (s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)),
              (s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)),
              (s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)),
              (s.bi_buf = 0),
              (s.bi_valid = 0),
              init_block(s);
          }
          function _tr_stored_block(s, buf, stored_len, last) {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3),
              copy_block(s, buf, stored_len, !0);
          }
          function _tr_align(s) {
            send_bits(s, STATIC_TREES << 1, 3),
              send_code(s, END_BLOCK, static_ltree),
              bi_flush(s);
          }
          function _tr_flush_block(s, buf, stored_len, last) {
            var opt_lenb,
              static_lenb,
              max_blindex = 0;
            s.level > 0
              ? (s.strm.data_type === Z_UNKNOWN &&
                  (s.strm.data_type = detect_data_type(s)),
                build_tree(s, s.l_desc),
                build_tree(s, s.d_desc),
                (max_blindex = build_bl_tree(s)),
                (opt_lenb = (s.opt_len + 3 + 7) >>> 3),
                (static_lenb = (s.static_len + 3 + 7) >>> 3) <= opt_lenb &&
                  (opt_lenb = static_lenb))
              : (opt_lenb = static_lenb = stored_len + 5),
              stored_len + 4 <= opt_lenb && -1 !== buf
                ? _tr_stored_block(s, buf, stored_len, last)
                : s.strategy === Z_FIXED || static_lenb === opt_lenb
                ? (send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3),
                  compress_block(s, static_ltree, static_dtree))
                : (send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3),
                  send_all_trees(
                    s,
                    s.l_desc.max_code + 1,
                    s.d_desc.max_code + 1,
                    max_blindex + 1
                  ),
                  compress_block(s, s.dyn_ltree, s.dyn_dtree)),
              init_block(s),
              last && bi_windup(s);
          }
          function _tr_tally(s, dist, lc) {
            return (
              (s.pending_buf[s.d_buf + 2 * s.last_lit] = (dist >>> 8) & 255),
              (s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 255 & dist),
              (s.pending_buf[s.l_buf + s.last_lit] = 255 & lc),
              s.last_lit++,
              0 === dist
                ? s.dyn_ltree[2 * lc]++
                : (s.matches++,
                  dist--,
                  s.dyn_ltree[2 * (_length_code[lc] + LITERALS + 1)]++,
                  s.dyn_dtree[2 * d_code(dist)]++),
              s.last_lit === s.lit_bufsize - 1
            );
          }
          (exports._tr_init = _tr_init),
            (exports._tr_stored_block = _tr_stored_block),
            (exports._tr_flush_block = _tr_flush_block),
            (exports._tr_tally = _tr_tally),
            (exports._tr_align = _tr_align);
        },
        { "../utils/common": 35 },
      ],
      47: [
        function (require, module, exports) {
          "use strict";
          function ZStream() {
            (this.input = null),
              (this.next_in = 0),
              (this.avail_in = 0),
              (this.total_in = 0),
              (this.output = null),
              (this.next_out = 0),
              (this.avail_out = 0),
              (this.total_out = 0),
              (this.msg = ""),
              (this.state = null),
              (this.data_type = 2),
              (this.adler = 0);
          }
          module.exports = ZStream;
        },
        {},
      ],
      48: [
        function (require, module, exports) {
          "use strict";
          function INTERNAL() {}
          module.exports = INTERNAL;
        },
        {},
      ],
      49: [
        function (require, module, exports) {
          "use strict";
          var Promise = require("./promise"),
            reject = require("./reject"),
            resolve = require("./resolve"),
            INTERNAL = require("./INTERNAL"),
            handlers = require("./handlers");
          function all(iterable) {
            if ("[object Array]" !== Object.prototype.toString.call(iterable))
              return reject(new TypeError("must be an array"));
            var len = iterable.length,
              called = !1;
            if (!len) return resolve([]);
            for (
              var values = new Array(len),
                resolved = 0,
                i = -1,
                promise = new Promise(INTERNAL);
              ++i < len;

            )
              allResolver(iterable[i], i);
            return promise;
            function allResolver(value, i) {
              function resolveFromAll(outValue) {
                (values[i] = outValue),
                  (++resolved === len) & !called &&
                    ((called = !0), handlers.resolve(promise, values));
              }
              resolve(value).then(resolveFromAll, function (error) {
                called || ((called = !0), handlers.reject(promise, error));
              });
            }
          }
          module.exports = all;
        },
        {
          "./INTERNAL": 48,
          "./handlers": 50,
          "./promise": 52,
          "./reject": 55,
          "./resolve": 56,
        },
      ],
      50: [
        function (require, module, exports) {
          "use strict";
          var tryCatch = require("./tryCatch"),
            resolveThenable = require("./resolveThenable"),
            states = require("./states");
          function getThen(obj) {
            var then = obj && obj.then;
            if (obj && "object" == typeof obj && "function" == typeof then)
              return function appyThen() {
                then.apply(obj, arguments);
              };
          }
          (exports.resolve = function (self, value) {
            var result = tryCatch(getThen, value);
            if ("error" === result.status)
              return exports.reject(self, result.value);
            var thenable = result.value;
            if (thenable) resolveThenable.safely(self, thenable);
            else {
              (self.state = states.FULFILLED), (self.outcome = value);
              for (var i = -1, len = self.queue.length; ++i < len; )
                self.queue[i].callFulfilled(value);
            }
            return self;
          }),
            (exports.reject = function (self, error) {
              (self.state = states.REJECTED), (self.outcome = error);
              for (var i = -1, len = self.queue.length; ++i < len; )
                self.queue[i].callRejected(error);
              return self;
            });
        },
        { "./resolveThenable": 57, "./states": 58, "./tryCatch": 59 },
      ],
      51: [
        function (require, module, exports) {
          (module.exports = exports = require("./promise")),
            (exports.resolve = require("./resolve")),
            (exports.reject = require("./reject")),
            (exports.all = require("./all")),
            (exports.race = require("./race"));
        },
        {
          "./all": 49,
          "./promise": 52,
          "./race": 54,
          "./reject": 55,
          "./resolve": 56,
        },
      ],
      52: [
        function (require, module, exports) {
          "use strict";
          var unwrap = require("./unwrap"),
            INTERNAL = require("./INTERNAL"),
            resolveThenable = require("./resolveThenable"),
            states = require("./states"),
            QueueItem = require("./queueItem");
          function Promise(resolver) {
            if (!(this instanceof Promise)) return new Promise(resolver);
            if ("function" != typeof resolver)
              throw new TypeError("resolver must be a function");
            (this.state = states.PENDING),
              (this.queue = []),
              (this.outcome = void 0),
              resolver !== INTERNAL && resolveThenable.safely(this, resolver);
          }
          (module.exports = Promise),
            (Promise.prototype.catch = function (onRejected) {
              return this.then(null, onRejected);
            }),
            (Promise.prototype.then = function (onFulfilled, onRejected) {
              if (
                ("function" != typeof onFulfilled &&
                  this.state === states.FULFILLED) ||
                ("function" != typeof onRejected &&
                  this.state === states.REJECTED)
              )
                return this;
              var promise = new Promise(INTERNAL);
              if (this.state !== states.PENDING) {
                var resolver =
                  this.state === states.FULFILLED ? onFulfilled : onRejected;
                unwrap(promise, resolver, this.outcome);
              } else
                this.queue.push(
                  new QueueItem(promise, onFulfilled, onRejected)
                );
              return promise;
            });
        },
        {
          "./INTERNAL": 48,
          "./queueItem": 53,
          "./resolveThenable": 57,
          "./states": 58,
          "./unwrap": 60,
        },
      ],
      53: [
        function (require, module, exports) {
          "use strict";
          var handlers = require("./handlers"),
            unwrap = require("./unwrap");
          function QueueItem(promise, onFulfilled, onRejected) {
            (this.promise = promise),
              "function" == typeof onFulfilled &&
                ((this.onFulfilled = onFulfilled),
                (this.callFulfilled = this.otherCallFulfilled)),
              "function" == typeof onRejected &&
                ((this.onRejected = onRejected),
                (this.callRejected = this.otherCallRejected));
          }
          (module.exports = QueueItem),
            (QueueItem.prototype.callFulfilled = function (value) {
              handlers.resolve(this.promise, value);
            }),
            (QueueItem.prototype.otherCallFulfilled = function (value) {
              unwrap(this.promise, this.onFulfilled, value);
            }),
            (QueueItem.prototype.callRejected = function (value) {
              handlers.reject(this.promise, value);
            }),
            (QueueItem.prototype.otherCallRejected = function (value) {
              unwrap(this.promise, this.onRejected, value);
            });
        },
        { "./handlers": 50, "./unwrap": 60 },
      ],
      54: [
        function (require, module, exports) {
          "use strict";
          var Promise = require("./promise"),
            reject = require("./reject"),
            resolve = require("./resolve"),
            INTERNAL = require("./INTERNAL"),
            handlers = require("./handlers");
          function race(iterable) {
            if ("[object Array]" !== Object.prototype.toString.call(iterable))
              return reject(new TypeError("must be an array"));
            var len = iterable.length,
              called = !1;
            if (!len) return resolve([]);
            for (var i = -1, promise = new Promise(INTERNAL); ++i < len; )
              resolver(iterable[i]);
            return promise;
            function resolver(value) {
              resolve(value).then(
                function (response) {
                  called ||
                    ((called = !0), handlers.resolve(promise, response));
                },
                function (error) {
                  called || ((called = !0), handlers.reject(promise, error));
                }
              );
            }
          }
          module.exports = race;
        },
        {
          "./INTERNAL": 48,
          "./handlers": 50,
          "./promise": 52,
          "./reject": 55,
          "./resolve": 56,
        },
      ],
      55: [
        function (require, module, exports) {
          "use strict";
          var Promise = require("./promise"),
            INTERNAL = require("./INTERNAL"),
            handlers = require("./handlers");
          function reject(reason) {
            var promise = new Promise(INTERNAL);
            return handlers.reject(promise, reason);
          }
          module.exports = reject;
        },
        { "./INTERNAL": 48, "./handlers": 50, "./promise": 52 },
      ],
      56: [
        function (require, module, exports) {
          "use strict";
          var Promise = require("./promise"),
            INTERNAL = require("./INTERNAL"),
            handlers = require("./handlers");
          module.exports = resolve;
          var FALSE = handlers.resolve(new Promise(INTERNAL), !1),
            NULL = handlers.resolve(new Promise(INTERNAL), null),
            UNDEFINED = handlers.resolve(new Promise(INTERNAL), void 0),
            ZERO = handlers.resolve(new Promise(INTERNAL), 0),
            EMPTYSTRING = handlers.resolve(new Promise(INTERNAL), "");
          function resolve(value) {
            if (value)
              return value instanceof Promise
                ? value
                : handlers.resolve(new Promise(INTERNAL), value);
            var valueType;
            switch (typeof value) {
              case "boolean":
                return FALSE;
              case "undefined":
                return UNDEFINED;
              case "object":
                return NULL;
              case "number":
                return ZERO;
              case "string":
                return EMPTYSTRING;
            }
          }
        },
        { "./INTERNAL": 48, "./handlers": 50, "./promise": 52 },
      ],
      57: [
        function (require, module, exports) {
          "use strict";
          var handlers = require("./handlers"),
            tryCatch = require("./tryCatch");
          function safelyResolveThenable(self, thenable) {
            var called = !1;
            function onError(value) {
              called || ((called = !0), handlers.reject(self, value));
            }
            function onSuccess(value) {
              called || ((called = !0), handlers.resolve(self, value));
            }
            function tryToUnwrap() {
              thenable(onSuccess, onError);
            }
            var result = tryCatch(tryToUnwrap);
            "error" === result.status && onError(result.value);
          }
          exports.safely = safelyResolveThenable;
        },
        { "./handlers": 50, "./tryCatch": 59 },
      ],
      58: [
        function (require, module, exports) {
          (exports.REJECTED = ["REJECTED"]),
            (exports.FULFILLED = ["FULFILLED"]),
            (exports.PENDING = ["PENDING"]);
        },
        {},
      ],
      59: [
        function (require, module, exports) {
          "use strict";
          function tryCatch(func, value) {
            var out = {};
            try {
              (out.value = func(value)), (out.status = "success");
            } catch (e) {
              (out.status = "error"), (out.value = e);
            }
            return out;
          }
          module.exports = tryCatch;
        },
        {},
      ],
      60: [
        function (require, module, exports) {
          "use strict";
          var immediate = require("immediate"),
            handlers = require("./handlers");
          function unwrap(promise, func, value) {
            immediate(function () {
              var returnValue;
              try {
                returnValue = func(value);
              } catch (e) {
                return handlers.reject(promise, e);
              }
              returnValue === promise
                ? handlers.reject(
                    promise,
                    new TypeError("Cannot resolve promise with itself")
                  )
                : handlers.resolve(promise, returnValue);
            });
          }
          module.exports = unwrap;
        },
        { "./handlers": 50, immediate: 61 },
      ],
      61: [
        function (require, module, exports) {
          (function (global) {
            "use strict";
            var Mutation =
                global.MutationObserver || global.WebKitMutationObserver,
              scheduleDrain,
              draining;
            if (Mutation) {
              var called = 0,
                observer = new Mutation(nextTick),
                element = global.document.createTextNode("");
              observer.observe(element, { characterData: !0 }),
                (scheduleDrain = function () {
                  element.data = called = ++called % 2;
                });
            } else if (global.setImmediate || void 0 === global.MessageChannel)
              scheduleDrain =
                "document" in global &&
                "onreadystatechange" in global.document.createElement("script")
                  ? function () {
                      var scriptEl = global.document.createElement("script");
                      (scriptEl.onreadystatechange = function () {
                        nextTick(),
                          (scriptEl.onreadystatechange = null),
                          scriptEl.parentNode.removeChild(scriptEl),
                          (scriptEl = null);
                      }),
                        global.document.documentElement.appendChild(scriptEl);
                    }
                  : function () {
                      setTimeout(nextTick, 0);
                    };
            else {
              var channel = new global.MessageChannel();
              (channel.port1.onmessage = nextTick),
                (scheduleDrain = function () {
                  channel.port2.postMessage(0);
                });
            }
            var queue = [];
            function nextTick() {
              var i, oldQueue;
              draining = !0;
              for (var len = queue.length; len; ) {
                for (oldQueue = queue, queue = [], i = -1; ++i < len; )
                  oldQueue[i]();
                len = queue.length;
              }
              draining = !1;
            }
            function immediate(task) {
              1 !== queue.push(task) || draining || scheduleDrain();
            }
            module.exports = immediate;
          }).call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
              ? self
              : "undefined" != typeof window
              ? window
              : {}
          );
        },
        {},
      ],
      62: [
        function (require, module, exports) {
          !(function () {
            function hOP(obj, key) {
              return Object.prototype.hasOwnProperty.call(obj, key);
            }
            function naiveLength() {
              return 1;
            }
            function LRUCache(options) {
              if (!(this instanceof LRUCache)) return new LRUCache(options);
              "number" == typeof options && (options = { max: options }),
                options || (options = {}),
                (this._max = options.max),
                (!this._max ||
                  "number" != typeof this._max ||
                  this._max <= 0) &&
                  (this._max = 1 / 0),
                (this._lengthCalculator = options.length || naiveLength),
                "function" != typeof this._lengthCalculator &&
                  (this._lengthCalculator = naiveLength),
                (this._allowStale = options.stale || !1),
                (this._maxAge = options.maxAge || null),
                (this._dispose = options.dispose),
                this.reset();
            }
            function get(self, key, doUse) {
              var hit = self._cache[key];
              return (
                hit &&
                  (isStale(self, hit)
                    ? (del(self, hit), self._allowStale || (hit = void 0))
                    : doUse && use(self, hit),
                  hit && (hit = hit.value)),
                hit
              );
            }
            function isStale(self, hit) {
              if (!hit || (!hit.maxAge && !self._maxAge)) return !1;
              var stale = !1,
                diff = Date.now() - hit.now;
              return (stale = hit.maxAge
                ? diff > hit.maxAge
                : self._maxAge && diff > self._maxAge);
            }
            function use(self, hit) {
              shiftLU(self, hit),
                (hit.lu = self._mru++),
                (self._lruList[hit.lu] = hit);
            }
            function trim(self) {
              for (; self._lru < self._mru && self._length > self._max; )
                del(self, self._lruList[self._lru]);
            }
            function shiftLU(self, hit) {
              for (
                delete self._lruList[hit.lu];
                self._lru < self._mru && !self._lruList[self._lru];

              )
                self._lru++;
            }
            function del(self, hit) {
              hit &&
                (self._dispose && self._dispose(hit.key, hit.value),
                (self._length -= hit.length),
                self._itemCount--,
                delete self._cache[hit.key],
                shiftLU(self, hit));
            }
            function Entry(key, value, lu, length, now, maxAge) {
              (this.key = key),
                (this.value = value),
                (this.lu = lu),
                (this.length = length),
                (this.now = now),
                maxAge && (this.maxAge = maxAge);
            }
            "object" == typeof module && module.exports
              ? (module.exports = LRUCache)
              : (this.LRUCache = LRUCache),
              Object.defineProperty(LRUCache.prototype, "max", {
                set: function (mL) {
                  (!mL || "number" != typeof mL || mL <= 0) && (mL = 1 / 0),
                    (this._max = mL),
                    this._length > this._max && trim(this);
                },
                get: function () {
                  return this._max;
                },
                enumerable: !0,
              }),
              Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
                set: function (lC) {
                  if ("function" != typeof lC)
                    for (var key in ((this._lengthCalculator = naiveLength),
                    (this._length = this._itemCount),
                    this._cache))
                      this._cache[key].length = 1;
                  else
                    for (var key in ((this._lengthCalculator = lC),
                    (this._length = 0),
                    this._cache))
                      (this._cache[key].length = this._lengthCalculator(
                        this._cache[key].value
                      )),
                        (this._length += this._cache[key].length);
                  this._length > this._max && trim(this);
                },
                get: function () {
                  return this._lengthCalculator;
                },
                enumerable: !0,
              }),
              Object.defineProperty(LRUCache.prototype, "length", {
                get: function () {
                  return this._length;
                },
                enumerable: !0,
              }),
              Object.defineProperty(LRUCache.prototype, "itemCount", {
                get: function () {
                  return this._itemCount;
                },
                enumerable: !0,
              }),
              (LRUCache.prototype.forEach = function (fn, thisp) {
                thisp = thisp || this;
                for (
                  var i = 0, itemCount = this._itemCount, k = this._mru - 1;
                  k >= 0 && i < itemCount;
                  k--
                )
                  if (this._lruList[k]) {
                    i++;
                    var hit = this._lruList[k];
                    isStale(this, hit) &&
                      (del(this, hit), this._allowStale || (hit = void 0)),
                      hit && fn.call(thisp, hit.value, hit.key, this);
                  }
              }),
              (LRUCache.prototype.keys = function () {
                for (
                  var keys = new Array(this._itemCount),
                    i = 0,
                    k = this._mru - 1;
                  k >= 0 && i < this._itemCount;
                  k--
                )
                  if (this._lruList[k]) {
                    var hit = this._lruList[k];
                    keys[i++] = hit.key;
                  }
                return keys;
              }),
              (LRUCache.prototype.values = function () {
                for (
                  var values = new Array(this._itemCount),
                    i = 0,
                    k = this._mru - 1;
                  k >= 0 && i < this._itemCount;
                  k--
                )
                  if (this._lruList[k]) {
                    var hit = this._lruList[k];
                    values[i++] = hit.value;
                  }
                return values;
              }),
              (LRUCache.prototype.reset = function () {
                if (this._dispose && this._cache)
                  for (var k in this._cache)
                    this._dispose(k, this._cache[k].value);
                (this._cache = Object.create(null)),
                  (this._lruList = Object.create(null)),
                  (this._mru = 0),
                  (this._lru = 0),
                  (this._length = 0),
                  (this._itemCount = 0);
              }),
              (LRUCache.prototype.dump = function () {
                return this._cache;
              }),
              (LRUCache.prototype.dumpLru = function () {
                return this._lruList;
              }),
              (LRUCache.prototype.set = function (key, value, maxAge) {
                var now = (maxAge = maxAge || this._maxAge) ? Date.now() : 0;
                if (hOP(this._cache, key))
                  return (
                    this._dispose && this._dispose(key, this._cache[key].value),
                    (this._cache[key].now = now),
                    (this._cache[key].maxAge = maxAge),
                    (this._cache[key].value = value),
                    this.get(key),
                    !0
                  );
                var len = this._lengthCalculator(value),
                  hit = new Entry(key, value, this._mru++, len, now, maxAge);
                return hit.length > this._max
                  ? (this._dispose && this._dispose(key, value), !1)
                  : ((this._length += hit.length),
                    (this._lruList[hit.lu] = this._cache[key] = hit),
                    this._itemCount++,
                    this._length > this._max && trim(this),
                    !0);
              }),
              (LRUCache.prototype.has = function (key) {
                return (
                  !!hOP(this._cache, key) && !isStale(this, this._cache[key])
                );
                var hit;
              }),
              (LRUCache.prototype.get = function (key) {
                return get(this, key, !0);
              }),
              (LRUCache.prototype.peek = function (key) {
                return get(this, key, !1);
              }),
              (LRUCache.prototype.pop = function () {
                var hit = this._lruList[this._lru];
                return del(this, hit), hit || null;
              }),
              (LRUCache.prototype.del = function (key) {
                del(this, this._cache[key]);
              });
          })();
        },
        {},
      ],
      63: [
        function (require, module, exports) {
          function dbfHeader(buffer) {
            var data = new DataView(buffer),
              out = {};
            return (
              (out.lastUpdated = new Date(
                data.getUint8(1, !0) + 1900,
                data.getUint8(2, !0),
                data.getUint8(3, !0)
              )),
              (out.records = data.getUint32(4, !0)),
              (out.headerLen = data.getUint16(8, !0)),
              (out.recLen = data.getUint16(10, !0)),
              out
            );
          }
          function dbfRowHeader(buffer) {
            for (
              var data = new DataView(buffer), out = [], offset = 32;
              out.push({
                name: String.fromCharCode
                  .apply(this, new Uint8Array(buffer, offset, 10))
                  .replace(/\0|\s+$/g, ""),
                dataType: String.fromCharCode(data.getUint8(offset + 11)),
                len: data.getUint8(offset + 16),
                decimal: data.getUint8(offset + 17),
              }),
                13 !== data.getUint8(offset + 32);

            )
              offset += 32;
            return out;
          }
          function rowFuncs(buffer, offset, len, type) {
            var data = new Uint8Array(buffer, offset, len),
              textData = String.fromCharCode
                .apply(this, data)
                .replace(/\0|\s+$/g, "");
            switch (type) {
              case "N":
              case "F":
              case "O":
                return parseFloat(textData, 10);
              case "D":
                return new Date(
                  textData.slice(0, 4),
                  parseInt(textData.slice(4, 6), 10) - 1,
                  textData.slice(6, 8)
                );
              case "L":
                return (
                  "y" === textData.toLowerCase() ||
                  "t" === textData.toLowerCase()
                );
              default:
                return textData;
            }
          }
          function parseRow(buffer, offset, rowHeaders) {
            for (
              var out = {}, i = 0, len = rowHeaders.length, field, header;
              i < len;

            )
              (field = rowFuncs(
                buffer,
                offset,
                (header = rowHeaders[i]).len,
                header.dataType
              )),
                (offset += header.len),
                void 0 !== field && (out[header.name] = field),
                i++;
            return out;
          }
          module.exports = function (buffer) {
            for (
              var rowHeaders = dbfRowHeader(buffer),
                header = dbfHeader(buffer),
                offset = 2 + ((rowHeaders.length + 1) << 5),
                recLen = header.recLen,
                records = header.records,
                out = [];
              records;

            )
              out.push(parseRow(buffer, offset, rowHeaders)),
                (offset += recLen),
                records--;
            return out;
          };
        },
        {},
      ],
      64: [
        function (require, module, exports) {
          var mgrs = require("mgrs");
          function Point(x, y, z) {
            if (!(this instanceof Point)) return new Point(x, y, z);
            if (Array.isArray(x))
              (this.x = x[0]), (this.y = x[1]), (this.z = x[2] || 0);
            else if ("object" == typeof x)
              (this.x = x.x), (this.y = x.y), (this.z = x.z || 0);
            else if ("string" == typeof x && void 0 === y) {
              var coords = x.split(",");
              (this.x = parseFloat(coords[0], 10)),
                (this.y = parseFloat(coords[1], 10)),
                (this.z = parseFloat(coords[2], 10) || 0);
            } else (this.x = x), (this.y = y), (this.z = z || 0);
            console.warn(
              "proj4.Point will be removed in version 3, use proj4.toPoint"
            );
          }
          (Point.fromMGRS = function (mgrsStr) {
            return new Point(mgrs.toPoint(mgrsStr));
          }),
            (Point.prototype.toMGRS = function (accuracy) {
              return mgrs.forward([this.x, this.y], accuracy);
            }),
            (module.exports = Point);
        },
        { mgrs: 131 },
      ],
      65: [
        function (require, module, exports) {
          var parseCode = require("./parseCode"),
            extend = require("./extend"),
            projections = require("./projections"),
            deriveConstants = require("./deriveConstants");
          function Projection(srsCode, callback) {
            if (!(this instanceof Projection)) return new Projection(srsCode);
            callback =
              callback ||
              function (error) {
                if (error) throw error;
              };
            var json = parseCode(srsCode);
            if ("object" == typeof json) {
              var modifiedJSON = deriveConstants(json),
                ourProj = Projection.projections.get(modifiedJSON.projName);
              ourProj
                ? (extend(this, modifiedJSON),
                  extend(this, ourProj),
                  this.init(),
                  callback(null, this))
                : callback(srsCode);
            } else callback(srsCode);
          }
          (Projection.projections = projections),
            Projection.projections.start(),
            (module.exports = Projection);
        },
        {
          "./deriveConstants": 96,
          "./extend": 97,
          "./parseCode": 101,
          "./projections": 103,
        },
      ],
      66: [
        function (require, module, exports) {
          module.exports = function (crs, denorm, point) {
            var xin = point.x,
              yin = point.y,
              zin = point.z || 0,
              v,
              t,
              i;
            for (i = 0; i < 3; i++)
              if (!denorm || 2 !== i || void 0 !== point.z)
                switch (
                  (0 === i
                    ? ((v = xin), (t = "x"))
                    : 1 === i
                    ? ((v = yin), (t = "y"))
                    : ((v = zin), (t = "z")),
                  crs.axis[i])
                ) {
                  case "e":
                    point[t] = v;
                    break;
                  case "w":
                    point[t] = -v;
                    break;
                  case "n":
                    point[t] = v;
                    break;
                  case "s":
                    point[t] = -v;
                    break;
                  case "u":
                    void 0 !== point[t] && (point.z = v);
                    break;
                  case "d":
                    void 0 !== point[t] && (point.z = -v);
                    break;
                  default:
                    return null;
                }
            return point;
          };
        },
        {},
      ],
      67: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2,
            sign = require("./sign");
          module.exports = function (x) {
            return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
          };
        },
        { "./sign": 84 },
      ],
      68: [
        function (require, module, exports) {
          var TWO_PI = 2 * Math.PI,
            SPI = 3.14159265359,
            sign = require("./sign");
          module.exports = function (x) {
            return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
          };
        },
        { "./sign": 84 },
      ],
      69: [
        function (require, module, exports) {
          module.exports = function (x) {
            return Math.abs(x) > 1 && (x = x > 1 ? 1 : -1), Math.asin(x);
          };
        },
        {},
      ],
      70: [
        function (require, module, exports) {
          module.exports = function (x) {
            return 1 - 0.25 * x * (1 + (x / 16) * (3 + 1.25 * x));
          };
        },
        {},
      ],
      71: [
        function (require, module, exports) {
          module.exports = function (x) {
            return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
          };
        },
        {},
      ],
      72: [
        function (require, module, exports) {
          module.exports = function (x) {
            return 0.05859375 * x * x * (1 + 0.75 * x);
          };
        },
        {},
      ],
      73: [
        function (require, module, exports) {
          module.exports = function (x) {
            return x * x * x * (35 / 3072);
          };
        },
        {},
      ],
      74: [
        function (require, module, exports) {
          module.exports = function (a, e, sinphi) {
            var temp = e * sinphi;
            return a / Math.sqrt(1 - temp * temp);
          };
        },
        {},
      ],
      75: [
        function (require, module, exports) {
          module.exports = function (ml, e0, e1, e2, e3) {
            var phi, dphi;
            phi = ml / e0;
            for (var i = 0; i < 15; i++)
              if (
                ((phi += dphi =
                  (ml -
                    (e0 * phi -
                      e1 * Math.sin(2 * phi) +
                      e2 * Math.sin(4 * phi) -
                      e3 * Math.sin(6 * phi))) /
                  (e0 -
                    2 * e1 * Math.cos(2 * phi) +
                    4 * e2 * Math.cos(4 * phi) -
                    6 * e3 * Math.cos(6 * phi))),
                Math.abs(dphi) <= 1e-10)
              )
                return phi;
            return NaN;
          };
        },
        {},
      ],
      76: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2;
          module.exports = function (eccent, q) {
            var temp =
              1 -
              ((1 - eccent * eccent) / (2 * eccent)) *
                Math.log((1 - eccent) / (1 + eccent));
            if (Math.abs(Math.abs(q) - temp) < 1e-6)
              return q < 0 ? -1 * HALF_PI : HALF_PI;
            for (
              var phi = Math.asin(0.5 * q), dphi, sin_phi, cos_phi, con, i = 0;
              i < 30;
              i++
            )
              if (
                ((sin_phi = Math.sin(phi)),
                (cos_phi = Math.cos(phi)),
                (con = eccent * sin_phi),
                (phi += dphi =
                  (Math.pow(1 - con * con, 2) / (2 * cos_phi)) *
                  (q / (1 - eccent * eccent) -
                    sin_phi / (1 - con * con) +
                    (0.5 / eccent) * Math.log((1 - con) / (1 + con)))),
                Math.abs(dphi) <= 1e-10)
              )
                return phi;
            return NaN;
          };
        },
        {},
      ],
      77: [
        function (require, module, exports) {
          module.exports = function (e0, e1, e2, e3, phi) {
            return (
              e0 * phi -
              e1 * Math.sin(2 * phi) +
              e2 * Math.sin(4 * phi) -
              e3 * Math.sin(6 * phi)
            );
          };
        },
        {},
      ],
      78: [
        function (require, module, exports) {
          module.exports = function (eccent, sinphi, cosphi) {
            var con = eccent * sinphi;
            return cosphi / Math.sqrt(1 - con * con);
          };
        },
        {},
      ],
      79: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2;
          module.exports = function (eccent, ts) {
            for (
              var eccnth = 0.5 * eccent,
                con,
                dphi,
                phi = HALF_PI - 2 * Math.atan(ts),
                i = 0;
              i <= 15;
              i++
            )
              if (
                ((con = eccent * Math.sin(phi)),
                (phi += dphi =
                  HALF_PI -
                  2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) -
                  phi),
                Math.abs(dphi) <= 1e-10)
              )
                return phi;
            return -9999;
          };
        },
        {},
      ],
      80: [
        function (require, module, exports) {
          var C00 = 1,
            C02 = 0.25,
            C04 = 0.046875,
            C06 = 0.01953125,
            C08 = 0.01068115234375,
            C22 = 0.75,
            C44 = 0.46875,
            C46 = 0.013020833333333334,
            C48 = 0.007120768229166667,
            C66 = 0.3645833333333333,
            C68 = 0.005696614583333333,
            C88 = 0.3076171875;
          module.exports = function (es) {
            var en = [];
            (en[0] = 1 - es * (0.25 + es * (C04 + es * (C06 + es * C08)))),
              (en[1] = es * (0.75 - es * (C04 + es * (C06 + es * C08))));
            var t = es * es;
            return (
              (en[2] = t * (C44 - es * (C46 + es * C48))),
              (t *= es),
              (en[3] = t * (C66 - es * C68)),
              (en[4] = t * es * C88),
              en
            );
          };
        },
        {},
      ],
      81: [
        function (require, module, exports) {
          var pj_mlfn = require("./pj_mlfn"),
            EPSLN = 1e-10,
            MAX_ITER = 20;
          module.exports = function (arg, es, en) {
            for (var k = 1 / (1 - es), phi = arg, i = 20; i; --i) {
              var s = Math.sin(phi),
                t = 1 - es * s * s;
              if (
                ((phi -= t =
                  (pj_mlfn(phi, s, Math.cos(phi), en) - arg) *
                  (t * Math.sqrt(t)) *
                  k),
                Math.abs(t) < 1e-10)
              )
                return phi;
            }
            return phi;
          };
        },
        { "./pj_mlfn": 82 },
      ],
      82: [
        function (require, module, exports) {
          module.exports = function (phi, sphi, cphi, en) {
            return (
              (cphi *= sphi),
              (sphi *= sphi),
              en[0] * phi -
                cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])))
            );
          };
        },
        {},
      ],
      83: [
        function (require, module, exports) {
          module.exports = function (eccent, sinphi) {
            var con;
            return eccent > 1e-7
              ? (1 - eccent * eccent) *
                  (sinphi / (1 - (con = eccent * sinphi) * con) -
                    (0.5 / eccent) * Math.log((1 - con) / (1 + con)))
              : 2 * sinphi;
          };
        },
        {},
      ],
      84: [
        function (require, module, exports) {
          module.exports = function (x) {
            return x < 0 ? -1 : 1;
          };
        },
        {},
      ],
      85: [
        function (require, module, exports) {
          module.exports = function (esinp, exp) {
            return Math.pow((1 - esinp) / (1 + esinp), exp);
          };
        },
        {},
      ],
      86: [
        function (require, module, exports) {
          module.exports = function (array) {
            var out = { x: array[0], y: array[1] };
            return (
              array.length > 2 && (out.z = array[2]),
              array.length > 3 && (out.m = array[3]),
              out
            );
          };
        },
        {},
      ],
      87: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2;
          module.exports = function (eccent, phi, sinphi) {
            var con = eccent * sinphi,
              com = 0.5 * eccent;
            return (
              (con = Math.pow((1 - con) / (1 + con), com)),
              Math.tan(0.5 * (HALF_PI - phi)) / con
            );
          };
        },
        {},
      ],
      88: [
        function (require, module, exports) {
          (exports.wgs84 = {
            towgs84: "0,0,0",
            ellipse: "WGS84",
            datumName: "WGS84",
          }),
            (exports.ch1903 = {
              towgs84: "674.374,15.056,405.346",
              ellipse: "bessel",
              datumName: "swiss",
            }),
            (exports.ggrs87 = {
              towgs84: "-199.87,74.79,246.62",
              ellipse: "GRS80",
              datumName: "Greek_Geodetic_Reference_System_1987",
            }),
            (exports.nad83 = {
              towgs84: "0,0,0",
              ellipse: "GRS80",
              datumName: "North_American_Datum_1983",
            }),
            (exports.nad27 = {
              nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
              ellipse: "clrk66",
              datumName: "North_American_Datum_1927",
            }),
            (exports.potsdam = {
              towgs84: "606.0,23.0,413.0",
              ellipse: "bessel",
              datumName: "Potsdam Rauenberg 1950 DHDN",
            }),
            (exports.carthage = {
              towgs84: "-263.0,6.0,431.0",
              ellipse: "clark80",
              datumName: "Carthage 1934 Tunisia",
            }),
            (exports.hermannskogel = {
              towgs84: "653.0,-212.0,449.0",
              ellipse: "bessel",
              datumName: "Hermannskogel",
            }),
            (exports.ire65 = {
              towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
              ellipse: "mod_airy",
              datumName: "Ireland 1965",
            }),
            (exports.rassadiran = {
              towgs84: "-133.63,-157.5,-158.62",
              ellipse: "intl",
              datumName: "Rassadiran",
            }),
            (exports.nzgd49 = {
              towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
              ellipse: "intl",
              datumName: "New Zealand Geodetic Datum 1949",
            }),
            (exports.osgb36 = {
              towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
              ellipse: "airy",
              datumName: "Airy 1830",
            }),
            (exports.s_jtsk = {
              towgs84: "589,76,480",
              ellipse: "bessel",
              datumName: "S-JTSK (Ferro)",
            }),
            (exports.beduaram = {
              towgs84: "-106,-87,188",
              ellipse: "clrk80",
              datumName: "Beduaram",
            }),
            (exports.gunung_segara = {
              towgs84: "-403,684,41",
              ellipse: "bessel",
              datumName: "Gunung Segara Jakarta",
            }),
            (exports.rnb72 = {
              towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
              ellipse: "intl",
              datumName: "Reseau National Belge 1972",
            });
        },
        {},
      ],
      89: [
        function (require, module, exports) {
          (exports.MERIT = {
            a: 6378137,
            rf: 298.257,
            ellipseName: "MERIT 1983",
          }),
            (exports.SGS85 = {
              a: 6378136,
              rf: 298.257,
              ellipseName: "Soviet Geodetic System 85",
            }),
            (exports.GRS80 = {
              a: 6378137,
              rf: 298.257222101,
              ellipseName: "GRS 1980(IUGG, 1980)",
            }),
            (exports.IAU76 = {
              a: 6378140,
              rf: 298.257,
              ellipseName: "IAU 1976",
            }),
            (exports.airy = {
              a: 6377563.396,
              b: 6356256.91,
              ellipseName: "Airy 1830",
            }),
            (exports.APL4 = {
              a: 6378137,
              rf: 298.25,
              ellipseName: "Appl. Physics. 1965",
            }),
            (exports.NWL9D = {
              a: 6378145,
              rf: 298.25,
              ellipseName: "Naval Weapons Lab., 1965",
            }),
            (exports.mod_airy = {
              a: 6377340.189,
              b: 6356034.446,
              ellipseName: "Modified Airy",
            }),
            (exports.andrae = {
              a: 6377104.43,
              rf: 300,
              ellipseName: "Andrae 1876 (Den., Iclnd.)",
            }),
            (exports.aust_SA = {
              a: 6378160,
              rf: 298.25,
              ellipseName: "Australian Natl & S. Amer. 1969",
            }),
            (exports.GRS67 = {
              a: 6378160,
              rf: 298.247167427,
              ellipseName: "GRS 67(IUGG 1967)",
            }),
            (exports.bessel = {
              a: 6377397.155,
              rf: 299.1528128,
              ellipseName: "Bessel 1841",
            }),
            (exports.bess_nam = {
              a: 6377483.865,
              rf: 299.1528128,
              ellipseName: "Bessel 1841 (Namibia)",
            }),
            (exports.clrk66 = {
              a: 6378206.4,
              b: 6356583.8,
              ellipseName: "Clarke 1866",
            }),
            (exports.clrk80 = {
              a: 6378249.145,
              rf: 293.4663,
              ellipseName: "Clarke 1880 mod.",
            }),
            (exports.clrk58 = {
              a: 6378293.645208759,
              rf: 294.2606763692654,
              ellipseName: "Clarke 1858",
            }),
            (exports.CPM = {
              a: 6375738.7,
              rf: 334.29,
              ellipseName: "Comm. des Poids et Mesures 1799",
            }),
            (exports.delmbr = {
              a: 6376428,
              rf: 311.5,
              ellipseName: "Delambre 1810 (Belgium)",
            }),
            (exports.engelis = {
              a: 6378136.05,
              rf: 298.2566,
              ellipseName: "Engelis 1985",
            }),
            (exports.evrst30 = {
              a: 6377276.345,
              rf: 300.8017,
              ellipseName: "Everest 1830",
            }),
            (exports.evrst48 = {
              a: 6377304.063,
              rf: 300.8017,
              ellipseName: "Everest 1948",
            }),
            (exports.evrst56 = {
              a: 6377301.243,
              rf: 300.8017,
              ellipseName: "Everest 1956",
            }),
            (exports.evrst69 = {
              a: 6377295.664,
              rf: 300.8017,
              ellipseName: "Everest 1969",
            }),
            (exports.evrstSS = {
              a: 6377298.556,
              rf: 300.8017,
              ellipseName: "Everest (Sabah & Sarawak)",
            }),
            (exports.fschr60 = {
              a: 6378166,
              rf: 298.3,
              ellipseName: "Fischer (Mercury Datum) 1960",
            }),
            (exports.fschr60m = {
              a: 6378155,
              rf: 298.3,
              ellipseName: "Fischer 1960",
            }),
            (exports.fschr68 = {
              a: 6378150,
              rf: 298.3,
              ellipseName: "Fischer 1968",
            }),
            (exports.helmert = {
              a: 6378200,
              rf: 298.3,
              ellipseName: "Helmert 1906",
            }),
            (exports.hough = { a: 6378270, rf: 297, ellipseName: "Hough" }),
            (exports.intl = {
              a: 6378388,
              rf: 297,
              ellipseName: "International 1909 (Hayford)",
            }),
            (exports.kaula = {
              a: 6378163,
              rf: 298.24,
              ellipseName: "Kaula 1961",
            }),
            (exports.lerch = {
              a: 6378139,
              rf: 298.257,
              ellipseName: "Lerch 1979",
            }),
            (exports.mprts = {
              a: 6397300,
              rf: 191,
              ellipseName: "Maupertius 1738",
            }),
            (exports.new_intl = {
              a: 6378157.5,
              b: 6356772.2,
              ellipseName: "New International 1967",
            }),
            (exports.plessis = {
              a: 6376523,
              rf: 6355863,
              ellipseName: "Plessis 1817 (France)",
            }),
            (exports.krass = {
              a: 6378245,
              rf: 298.3,
              ellipseName: "Krassovsky, 1942",
            }),
            (exports.SEasia = {
              a: 6378155,
              b: 6356773.3205,
              ellipseName: "Southeast Asia",
            }),
            (exports.walbeck = {
              a: 6376896,
              b: 6355834.8467,
              ellipseName: "Walbeck",
            }),
            (exports.WGS60 = { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }),
            (exports.WGS66 = { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }),
            (exports.WGS7 = { a: 6378135, rf: 298.26, ellipseName: "WGS 72" }),
            (exports.WGS84 = {
              a: 6378137,
              rf: 298.257223563,
              ellipseName: "WGS 84",
            }),
            (exports.sphere = {
              a: 6370997,
              b: 6370997,
              ellipseName: "Normal Sphere (r=6370997)",
            });
        },
        {},
      ],
      90: [
        function (require, module, exports) {
          (exports.greenwich = 0),
            (exports.lisbon = -9.131906111111),
            (exports.paris = 2.337229166667),
            (exports.bogota = -74.080916666667),
            (exports.madrid = -3.687938888889),
            (exports.rome = 12.452333333333),
            (exports.bern = 7.439583333333),
            (exports.jakarta = 106.807719444444),
            (exports.ferro = -17.666666666667),
            (exports.brussels = 4.367975),
            (exports.stockholm = 18.058277777778),
            (exports.athens = 23.7163375),
            (exports.oslo = 10.722916666667);
        },
        {},
      ],
      91: [
        function (require, module, exports) {
          (exports.ft = { to_meter: 0.3048 }),
            (exports["us-ft"] = { to_meter: 1200 / 3937 });
        },
        {},
      ],
      92: [
        function (require, module, exports) {
          var proj = require("./Proj"),
            transform = require("./transform"),
            wgs84 = proj("WGS84");
          function transformer(from, to, coords) {
            var transformedArray;
            return Array.isArray(coords)
              ? ((transformedArray = transform(from, to, coords)),
                3 === coords.length
                  ? [transformedArray.x, transformedArray.y, transformedArray.z]
                  : [transformedArray.x, transformedArray.y])
              : transform(from, to, coords);
          }
          function checkProj(item) {
            return item instanceof proj
              ? item
              : item.oProj
              ? item.oProj
              : proj(item);
          }
          function proj4(fromProj, toProj, coord) {
            fromProj = checkProj(fromProj);
            var single = !1,
              obj;
            return (
              void 0 === toProj
                ? ((toProj = fromProj), (fromProj = wgs84), (single = !0))
                : (void 0 !== toProj.x || Array.isArray(toProj)) &&
                  ((coord = toProj),
                  (toProj = fromProj),
                  (fromProj = wgs84),
                  (single = !0)),
              (toProj = checkProj(toProj)),
              coord
                ? transformer(fromProj, toProj, coord)
                : ((obj = {
                    forward: function (coords) {
                      return transformer(fromProj, toProj, coords);
                    },
                    inverse: function (coords) {
                      return transformer(toProj, fromProj, coords);
                    },
                  }),
                  single && (obj.oProj = toProj),
                  obj)
            );
          }
          module.exports = proj4;
        },
        { "./Proj": 65, "./transform": 129 },
      ],
      93: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2,
            PJD_3PARAM = 1,
            PJD_7PARAM = 2,
            PJD_GRIDSHIFT = 3,
            PJD_WGS84 = 4,
            PJD_NODATUM = 5,
            SEC_TO_RAD = 484813681109536e-20,
            AD_C = 1.0026,
            COS_67P5 = 0.3826834323650898,
            datum = function (proj) {
              if (!(this instanceof datum)) return new datum(proj);
              if (((this.datum_type = 4), proj)) {
                if (
                  (proj.datumCode &&
                    "none" === proj.datumCode &&
                    (this.datum_type = 5),
                  proj.datum_params)
                ) {
                  for (var i = 0; i < proj.datum_params.length; i++)
                    proj.datum_params[i] = parseFloat(proj.datum_params[i]);
                  (0 === proj.datum_params[0] &&
                    0 === proj.datum_params[1] &&
                    0 === proj.datum_params[2]) ||
                    (this.datum_type = 1),
                    proj.datum_params.length > 3 &&
                      ((0 === proj.datum_params[3] &&
                        0 === proj.datum_params[4] &&
                        0 === proj.datum_params[5] &&
                        0 === proj.datum_params[6]) ||
                        ((this.datum_type = 2),
                        (proj.datum_params[3] *= SEC_TO_RAD),
                        (proj.datum_params[4] *= SEC_TO_RAD),
                        (proj.datum_params[5] *= SEC_TO_RAD),
                        (proj.datum_params[6] =
                          proj.datum_params[6] / 1e6 + 1)));
                }
                (this.datum_type = proj.grids ? 3 : this.datum_type),
                  (this.a = proj.a),
                  (this.b = proj.b),
                  (this.es = proj.es),
                  (this.ep2 = proj.ep2),
                  (this.datum_params = proj.datum_params),
                  3 === this.datum_type && (this.grids = proj.grids);
              }
            };
          (datum.prototype = {
            compare_datums: function (dest) {
              return (
                this.datum_type === dest.datum_type &&
                !(this.a !== dest.a || Math.abs(this.es - dest.es) > 5e-11) &&
                (1 === this.datum_type
                  ? this.datum_params[0] === dest.datum_params[0] &&
                    this.datum_params[1] === dest.datum_params[1] &&
                    this.datum_params[2] === dest.datum_params[2]
                  : 2 === this.datum_type
                  ? this.datum_params[0] === dest.datum_params[0] &&
                    this.datum_params[1] === dest.datum_params[1] &&
                    this.datum_params[2] === dest.datum_params[2] &&
                    this.datum_params[3] === dest.datum_params[3] &&
                    this.datum_params[4] === dest.datum_params[4] &&
                    this.datum_params[5] === dest.datum_params[5] &&
                    this.datum_params[6] === dest.datum_params[6]
                  : (3 !== this.datum_type && 3 !== dest.datum_type) ||
                    this.nadgrids === dest.nadgrids)
              );
            },
            geodetic_to_geocentric: function (p) {
              var Longitude = p.x,
                Latitude = p.y,
                Height = p.z ? p.z : 0,
                X,
                Y,
                Z,
                Error_Code = 0,
                Rn,
                Sin_Lat,
                Sin2_Lat,
                Cos_Lat;
              if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI)
                Latitude = -HALF_PI;
              else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI)
                Latitude = HALF_PI;
              else if (Latitude < -HALF_PI || Latitude > HALF_PI) return null;
              return (
                Longitude > Math.PI && (Longitude -= 2 * Math.PI),
                (Sin_Lat = Math.sin(Latitude)),
                (Cos_Lat = Math.cos(Latitude)),
                (Sin2_Lat = Sin_Lat * Sin_Lat),
                (X =
                  ((Rn = this.a / Math.sqrt(1 - this.es * Sin2_Lat)) + Height) *
                  Cos_Lat *
                  Math.cos(Longitude)),
                (Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude)),
                (Z = (Rn * (1 - this.es) + Height) * Sin_Lat),
                (p.x = X),
                (p.y = Y),
                (p.z = Z),
                0
              );
            },
            geocentric_to_geodetic: function (p) {
              var genau = 1e-12,
                genau2 = 1e-24,
                maxiter = 30,
                P,
                RR,
                CT,
                ST,
                RX,
                RK,
                RN,
                CPHI0,
                SPHI0,
                CPHI,
                SPHI,
                SDPHI,
                At_Pole,
                iter,
                X = p.x,
                Y = p.y,
                Z = p.z ? p.z : 0,
                Longitude,
                Latitude,
                Height;
              if (
                ((At_Pole = !1),
                (P = Math.sqrt(X * X + Y * Y)),
                (RR = Math.sqrt(X * X + Y * Y + Z * Z)),
                P / this.a < 1e-12)
              ) {
                if (((At_Pole = !0), (Longitude = 0), RR / this.a < 1e-12))
                  return (Latitude = HALF_PI), void (Height = -this.b);
              } else Longitude = Math.atan2(Y, X);
              (CT = Z / RR),
                (ST = P / RR),
                (RX = 1 / Math.sqrt(1 - this.es * (2 - this.es) * ST * ST)),
                (CPHI0 = ST * (1 - this.es) * RX),
                (SPHI0 = CT * RX),
                (iter = 0);
              do {
                iter++,
                  (Height =
                    P * CPHI0 +
                    Z * SPHI0 -
                    (RN = this.a / Math.sqrt(1 - this.es * SPHI0 * SPHI0)) *
                      (1 - this.es * SPHI0 * SPHI0)),
                  (RK = (this.es * RN) / (RN + Height)),
                  (SDPHI =
                    (SPHI =
                      CT * (RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST))) *
                      CPHI0 -
                    (CPHI = ST * (1 - RK) * RX) * SPHI0),
                  (CPHI0 = CPHI),
                  (SPHI0 = SPHI);
              } while (SDPHI * SDPHI > 1e-24 && iter < 30);
              return (
                (Latitude = Math.atan(SPHI / Math.abs(CPHI))),
                (p.x = Longitude),
                (p.y = Latitude),
                (p.z = Height),
                p
              );
            },
            geocentric_to_geodetic_noniter: function (p) {
              var X = p.x,
                Y = p.y,
                Z = p.z ? p.z : 0,
                Longitude,
                Latitude,
                Height,
                W,
                W2,
                T0,
                T1,
                S0,
                S1,
                Sin_B0,
                Sin3_B0,
                Cos_B0,
                Sin_p1,
                Cos_p1,
                Rn,
                Sum,
                At_Pole;
              if (
                ((X = parseFloat(X)),
                (Y = parseFloat(Y)),
                (Z = parseFloat(Z)),
                (At_Pole = !1),
                0 !== X)
              )
                Longitude = Math.atan2(Y, X);
              else if (Y > 0) Longitude = HALF_PI;
              else if (Y < 0) Longitude = -HALF_PI;
              else if (((At_Pole = !0), (Longitude = 0), Z > 0))
                Latitude = HALF_PI;
              else {
                if (!(Z < 0))
                  return (Latitude = HALF_PI), void (Height = -this.b);
                Latitude = -HALF_PI;
              }
              return (
                (W2 = X * X + Y * Y),
                (W = Math.sqrt(W2)),
                (T0 = Z * AD_C),
                (Cos_B0 = W / (S0 = Math.sqrt(T0 * T0 + W2))),
                (Sin3_B0 = (Sin_B0 = T0 / S0) * Sin_B0 * Sin_B0),
                (T1 = Z + this.b * this.ep2 * Sin3_B0),
                (Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0),
                (Sin_p1 = T1 / (S1 = Math.sqrt(T1 * T1 + Sum * Sum))),
                (Cos_p1 = Sum / S1),
                (Rn = this.a / Math.sqrt(1 - this.es * Sin_p1 * Sin_p1)),
                (Height =
                  Cos_p1 >= COS_67P5
                    ? W / Cos_p1 - Rn
                    : Cos_p1 <= -COS_67P5
                    ? W / -Cos_p1 - Rn
                    : Z / Sin_p1 + Rn * (this.es - 1)),
                !1 === At_Pole && (Latitude = Math.atan(Sin_p1 / Cos_p1)),
                (p.x = Longitude),
                (p.y = Latitude),
                (p.z = Height),
                p
              );
            },
            geocentric_to_wgs84: function (p) {
              if (1 === this.datum_type)
                (p.x += this.datum_params[0]),
                  (p.y += this.datum_params[1]),
                  (p.z += this.datum_params[2]);
              else if (2 === this.datum_type) {
                var Dx_BF = this.datum_params[0],
                  Dy_BF = this.datum_params[1],
                  Dz_BF = this.datum_params[2],
                  Rx_BF = this.datum_params[3],
                  Ry_BF = this.datum_params[4],
                  Rz_BF = this.datum_params[5],
                  M_BF = this.datum_params[6],
                  x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
                  y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
                  z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
                (p.x = x_out), (p.y = y_out), (p.z = z_out);
              }
            },
            geocentric_from_wgs84: function (p) {
              if (1 === this.datum_type)
                (p.x -= this.datum_params[0]),
                  (p.y -= this.datum_params[1]),
                  (p.z -= this.datum_params[2]);
              else if (2 === this.datum_type) {
                var Dx_BF = this.datum_params[0],
                  Dy_BF = this.datum_params[1],
                  Dz_BF = this.datum_params[2],
                  Rx_BF = this.datum_params[3],
                  Ry_BF = this.datum_params[4],
                  Rz_BF = this.datum_params[5],
                  M_BF = this.datum_params[6],
                  x_tmp = (p.x - Dx_BF) / M_BF,
                  y_tmp = (p.y - Dy_BF) / M_BF,
                  z_tmp = (p.z - Dz_BF) / M_BF;
                (p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp),
                  (p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp),
                  (p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp);
              }
            },
          }),
            (module.exports = datum);
        },
        {},
      ],
      94: [
        function (require, module, exports) {
          var PJD_3PARAM = 1,
            PJD_7PARAM = 2,
            PJD_GRIDSHIFT = 3,
            PJD_NODATUM = 5,
            SRS_WGS84_SEMIMAJOR = 6378137,
            SRS_WGS84_ESQUARED = 0.006694379990141316;
          module.exports = function (source, dest, point) {
            var wp, i, l;
            function checkParams(fallback) {
              return fallback === PJD_3PARAM || fallback === PJD_7PARAM;
            }
            if (source.compare_datums(dest)) return point;
            if (5 === source.datum_type || 5 === dest.datum_type) return point;
            var src_a = source.a,
              src_es = source.es,
              dst_a = dest.a,
              dst_es = dest.es,
              fallback = source.datum_type;
            if (3 === fallback)
              if (0 === this.apply_gridshift(source, 0, point))
                (source.a = 6378137), (source.es = SRS_WGS84_ESQUARED);
              else {
                if (!source.datum_params)
                  return (source.a = src_a), (source.es = source.es), point;
                for (wp = 1, i = 0, l = source.datum_params.length; i < l; i++)
                  wp *= source.datum_params[i];
                if (0 === wp)
                  return (source.a = src_a), (source.es = source.es), point;
                fallback =
                  source.datum_params.length > 3 ? PJD_7PARAM : PJD_3PARAM;
              }
            return (
              3 === dest.datum_type &&
                ((dest.a = 6378137), (dest.es = SRS_WGS84_ESQUARED)),
              (source.es !== dest.es ||
                source.a !== dest.a ||
                checkParams(fallback) ||
                checkParams(dest.datum_type)) &&
                (source.geodetic_to_geocentric(point),
                checkParams(source.datum_type) &&
                  source.geocentric_to_wgs84(point),
                checkParams(dest.datum_type) &&
                  dest.geocentric_from_wgs84(point),
                dest.geocentric_to_geodetic(point)),
              3 === dest.datum_type && this.apply_gridshift(dest, 1, point),
              (source.a = src_a),
              (source.es = src_es),
              (dest.a = dst_a),
              (dest.es = dst_es),
              point
            );
          };
        },
        {},
      ],
      95: [
        function (require, module, exports) {
          var globals = require("./global"),
            parseProj = require("./projString"),
            wkt = require("./wkt");
          function defs(name) {
            var that = this;
            if (2 === arguments.length) {
              var def = arguments[1];
              "string" == typeof def
                ? "+" === def.charAt(0)
                  ? (defs[name] = parseProj(arguments[1]))
                  : (defs[name] = wkt(arguments[1]))
                : (defs[name] = def);
            } else if (1 === arguments.length) {
              if (Array.isArray(name))
                return name.map(function (v) {
                  Array.isArray(v) ? defs.apply(that, v) : defs(v);
                });
              if ("string" == typeof name) {
                if (name in defs) return defs[name];
              } else
                "EPSG" in name
                  ? (defs["EPSG:" + name.EPSG] = name)
                  : "ESRI" in name
                  ? (defs["ESRI:" + name.ESRI] = name)
                  : "IAU2000" in name
                  ? (defs["IAU2000:" + name.IAU2000] = name)
                  : console.log(name);
              return;
            }
          }
          globals(defs), (module.exports = defs);
        },
        { "./global": 98, "./projString": 102, "./wkt": 130 },
      ],
      96: [
        function (require, module, exports) {
          var Datum = require("./constants/Datum"),
            Ellipsoid = require("./constants/Ellipsoid"),
            extend = require("./extend"),
            datum = require("./datum"),
            EPSLN = 1e-10,
            SIXTH = 0.16666666666666666,
            RA4 = 0.04722222222222222,
            RA6 = 0.022156084656084655;
          module.exports = function (json) {
            if (json.datumCode && "none" !== json.datumCode) {
              var datumDef = Datum[json.datumCode];
              datumDef &&
                ((json.datum_params = datumDef.towgs84
                  ? datumDef.towgs84.split(",")
                  : null),
                (json.ellps = datumDef.ellipse),
                (json.datumName = datumDef.datumName
                  ? datumDef.datumName
                  : json.datumCode));
            }
            if (!json.a) {
              var ellipse = Ellipsoid[json.ellps]
                ? Ellipsoid[json.ellps]
                : Ellipsoid.WGS84;
              extend(json, ellipse);
            }
            return (
              json.rf && !json.b && (json.b = (1 - 1 / json.rf) * json.a),
              (0 === json.rf || Math.abs(json.a - json.b) < 1e-10) &&
                ((json.sphere = !0), (json.b = json.a)),
              (json.a2 = json.a * json.a),
              (json.b2 = json.b * json.b),
              (json.es = (json.a2 - json.b2) / json.a2),
              (json.e = Math.sqrt(json.es)),
              json.R_A &&
                ((json.a *=
                  1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6))),
                (json.a2 = json.a * json.a),
                (json.b2 = json.b * json.b),
                (json.es = 0)),
              (json.ep2 = (json.a2 - json.b2) / json.b2),
              json.k0 || (json.k0 = 1),
              json.axis || (json.axis = "enu"),
              json.datum || (json.datum = datum(json)),
              json
            );
          };
        },
        {
          "./constants/Datum": 88,
          "./constants/Ellipsoid": 89,
          "./datum": 93,
          "./extend": 97,
        },
      ],
      97: [
        function (require, module, exports) {
          module.exports = function (destination, source) {
            var value, property;
            if (((destination = destination || {}), !source))
              return destination;
            for (property in source)
              void 0 !== (value = source[property]) &&
                (destination[property] = value);
            return destination;
          };
        },
        {},
      ],
      98: [
        function (require, module, exports) {
          module.exports = function (defs) {
            defs(
              "EPSG:4326",
              "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"
            ),
              defs(
                "EPSG:4269",
                "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"
              ),
              defs(
                "EPSG:3857",
                "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"
              ),
              (defs.WGS84 = defs["EPSG:4326"]),
              (defs["EPSG:3785"] = defs["EPSG:3857"]),
              (defs.GOOGLE = defs["EPSG:3857"]),
              (defs["EPSG:900913"] = defs["EPSG:3857"]),
              (defs["EPSG:102113"] = defs["EPSG:3857"]);
          };
        },
        {},
      ],
      99: [
        function (require, module, exports) {
          var projs = [
            require("./projections/tmerc"),
            require("./projections/utm"),
            require("./projections/sterea"),
            require("./projections/stere"),
            require("./projections/somerc"),
            require("./projections/omerc"),
            require("./projections/lcc"),
            require("./projections/krovak"),
            require("./projections/cass"),
            require("./projections/laea"),
            require("./projections/aea"),
            require("./projections/gnom"),
            require("./projections/cea"),
            require("./projections/eqc"),
            require("./projections/poly"),
            require("./projections/nzmg"),
            require("./projections/mill"),
            require("./projections/sinu"),
            require("./projections/moll"),
            require("./projections/eqdc"),
            require("./projections/vandg"),
            require("./projections/aeqd"),
          ];
          module.exports = function (proj4) {
            projs.forEach(function (proj) {
              proj4.Proj.projections.add(proj);
            });
          };
        },
        {
          "./projections/aea": 104,
          "./projections/aeqd": 105,
          "./projections/cass": 106,
          "./projections/cea": 107,
          "./projections/eqc": 108,
          "./projections/eqdc": 109,
          "./projections/gnom": 111,
          "./projections/krovak": 112,
          "./projections/laea": 113,
          "./projections/lcc": 114,
          "./projections/mill": 117,
          "./projections/moll": 118,
          "./projections/nzmg": 119,
          "./projections/omerc": 120,
          "./projections/poly": 121,
          "./projections/sinu": 122,
          "./projections/somerc": 123,
          "./projections/stere": 124,
          "./projections/sterea": 125,
          "./projections/tmerc": 126,
          "./projections/utm": 127,
          "./projections/vandg": 128,
        },
      ],
      100: [
        function (require, module, exports) {
          var proj4 = require("./core");
          (proj4.defaultDatum = "WGS84"),
            (proj4.Proj = require("./Proj")),
            (proj4.WGS84 = new proj4.Proj("WGS84")),
            (proj4.Point = require("./Point")),
            (proj4.toPoint = require("./common/toPoint")),
            (proj4.defs = require("./defs")),
            (proj4.transform = require("./transform")),
            (proj4.mgrs = require("mgrs")),
            (proj4.version = require("../package.json").version),
            require("./includedProjections")(proj4),
            (module.exports = proj4);
        },
        {
          "../package.json": 132,
          "./Point": 64,
          "./Proj": 65,
          "./common/toPoint": 86,
          "./core": 92,
          "./defs": 95,
          "./includedProjections": 99,
          "./transform": 129,
          mgrs: 131,
        },
      ],
      101: [
        function (require, module, exports) {
          var defs = require("./defs"),
            wkt = require("./wkt"),
            projStr = require("./projString");
          function testObj(code) {
            return "string" == typeof code;
          }
          function testDef(code) {
            return code in defs;
          }
          function testWKT(code) {
            var codeWords;
            return ["GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS"].reduce(function (
              a,
              b
            ) {
              return a + 1 + code.indexOf(b);
            },
            0);
          }
          function testProj(code) {
            return "+" === code[0];
          }
          function parse(code) {
            return testObj(code)
              ? testDef(code)
                ? defs[code]
                : testWKT(code)
                ? wkt(code)
                : testProj(code)
                ? projStr(code)
                : void 0
              : code;
          }
          module.exports = parse;
        },
        { "./defs": 95, "./projString": 102, "./wkt": 130 },
      ],
      102: [
        function (require, module, exports) {
          var D2R = 0.017453292519943295,
            PrimeMeridian = require("./constants/PrimeMeridian"),
            units = require("./constants/units");
          module.exports = function (defData) {
            var self = {},
              paramObj = {},
              paramName,
              paramVal,
              paramOutname;
            defData
              .split("+")
              .map(function (v) {
                return v.trim();
              })
              .filter(function (a) {
                return a;
              })
              .forEach(function (a) {
                var split = a.split("=");
                split.push(!0), (paramObj[split[0].toLowerCase()] = split[1]);
              });
            var params = {
              proj: "projName",
              datum: "datumCode",
              rf: function (v) {
                self.rf = parseFloat(v);
              },
              lat_0: function (v) {
                self.lat0 = v * D2R;
              },
              lat_1: function (v) {
                self.lat1 = v * D2R;
              },
              lat_2: function (v) {
                self.lat2 = v * D2R;
              },
              lat_ts: function (v) {
                self.lat_ts = v * D2R;
              },
              lon_0: function (v) {
                self.long0 = v * D2R;
              },
              lon_1: function (v) {
                self.long1 = v * D2R;
              },
              lon_2: function (v) {
                self.long2 = v * D2R;
              },
              alpha: function (v) {
                self.alpha = parseFloat(v) * D2R;
              },
              lonc: function (v) {
                self.longc = v * D2R;
              },
              x_0: function (v) {
                self.x0 = parseFloat(v);
              },
              y_0: function (v) {
                self.y0 = parseFloat(v);
              },
              k_0: function (v) {
                self.k0 = parseFloat(v);
              },
              k: function (v) {
                self.k0 = parseFloat(v);
              },
              a: function (v) {
                self.a = parseFloat(v);
              },
              b: function (v) {
                self.b = parseFloat(v);
              },
              r_a: function () {
                self.R_A = !0;
              },
              zone: function (v) {
                self.zone = parseInt(v, 10);
              },
              south: function () {
                self.utmSouth = !0;
              },
              towgs84: function (v) {
                self.datum_params = v.split(",").map(function (a) {
                  return parseFloat(a);
                });
              },
              to_meter: function (v) {
                self.to_meter = parseFloat(v);
              },
              units: function (v) {
                (self.units = v),
                  units[v] && (self.to_meter = units[v].to_meter);
              },
              from_greenwich: function (v) {
                self.from_greenwich = v * D2R;
              },
              pm: function (v) {
                self.from_greenwich =
                  (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
              },
              nadgrids: function (v) {
                "@null" === v ? (self.datumCode = "none") : (self.nadgrids = v);
              },
              axis: function (v) {
                var legalAxis = "ewnsud";
                3 === v.length &&
                  -1 !== "ewnsud".indexOf(v.substr(0, 1)) &&
                  -1 !== "ewnsud".indexOf(v.substr(1, 1)) &&
                  -1 !== "ewnsud".indexOf(v.substr(2, 1)) &&
                  (self.axis = v);
              },
            };
            for (paramName in paramObj)
              (paramVal = paramObj[paramName]),
                paramName in params
                  ? "function" == typeof (paramOutname = params[paramName])
                    ? paramOutname(paramVal)
                    : (self[paramOutname] = paramVal)
                  : (self[paramName] = paramVal);
            return (
              "string" == typeof self.datumCode &&
                "WGS84" !== self.datumCode &&
                (self.datumCode = self.datumCode.toLowerCase()),
              self
            );
          };
        },
        { "./constants/PrimeMeridian": 90, "./constants/units": 91 },
      ],
      103: [
        function (require, module, exports) {
          var projs = [
              require("./projections/merc"),
              require("./projections/longlat"),
            ],
            names = {},
            projStore = [];
          function add(proj, i) {
            var len = projStore.length;
            return proj.names
              ? ((projStore[len] = proj),
                proj.names.forEach(function (n) {
                  names[n.toLowerCase()] = len;
                }),
                this)
              : (console.log(i), !0);
          }
          (exports.add = add),
            (exports.get = function (name) {
              if (!name) return !1;
              var n = name.toLowerCase();
              return void 0 !== names[n] && projStore[names[n]]
                ? projStore[names[n]]
                : void 0;
            }),
            (exports.start = function () {
              projs.forEach(add);
            });
        },
        { "./projections/longlat": 115, "./projections/merc": 116 },
      ],
      104: [
        function (require, module, exports) {
          var EPSLN = 1e-10,
            msfnz = require("../common/msfnz"),
            qsfnz = require("../common/qsfnz"),
            adjust_lon = require("../common/adjust_lon"),
            asinz = require("../common/asinz");
          (exports.init = function () {
            Math.abs(this.lat1 + this.lat2) < 1e-10 ||
              ((this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e3 = Math.sqrt(this.es)),
              (this.sin_po = Math.sin(this.lat1)),
              (this.cos_po = Math.cos(this.lat1)),
              (this.t1 = this.sin_po),
              (this.con = this.sin_po),
              (this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po)),
              (this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po)),
              (this.sin_po = Math.sin(this.lat2)),
              (this.cos_po = Math.cos(this.lat2)),
              (this.t2 = this.sin_po),
              (this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po)),
              (this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po)),
              (this.sin_po = Math.sin(this.lat0)),
              (this.cos_po = Math.cos(this.lat0)),
              (this.t3 = this.sin_po),
              (this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po)),
              Math.abs(this.lat1 - this.lat2) > 1e-10
                ? (this.ns0 =
                    (this.ms1 * this.ms1 - this.ms2 * this.ms2) /
                    (this.qs2 - this.qs1))
                : (this.ns0 = this.con),
              (this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1),
              (this.rh =
                (this.a * Math.sqrt(this.c - this.ns0 * this.qs0)) / this.ns0));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y;
              (this.sin_phi = Math.sin(lat)), (this.cos_phi = Math.cos(lat));
              var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi),
                rh1 = (this.a * Math.sqrt(this.c - this.ns0 * qs)) / this.ns0,
                theta = this.ns0 * adjust_lon(lon - this.long0),
                x = rh1 * Math.sin(theta) + this.x0,
                y = this.rh - rh1 * Math.cos(theta) + this.y0;
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var rh1, qs, con, theta, lon, lat;
              return (
                (p.x -= this.x0),
                (p.y = this.rh - p.y + this.y0),
                this.ns0 >= 0
                  ? ((rh1 = Math.sqrt(p.x * p.x + p.y * p.y)), (con = 1))
                  : ((rh1 = -Math.sqrt(p.x * p.x + p.y * p.y)), (con = -1)),
                (theta = 0),
                0 !== rh1 && (theta = Math.atan2(con * p.x, con * p.y)),
                (con = (rh1 * this.ns0) / this.a),
                this.sphere
                  ? (lat = Math.asin((this.c - con * con) / (2 * this.ns0)))
                  : ((qs = (this.c - con * con) / this.ns0),
                    (lat = this.phi1z(this.e3, qs))),
                (lon = adjust_lon(theta / this.ns0 + this.long0)),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.phi1z = function (eccent, qs) {
              var sinphi,
                cosphi,
                con,
                com,
                dphi,
                phi = asinz(0.5 * qs);
              if (eccent < 1e-10) return phi;
              for (var eccnts = eccent * eccent, i = 1; i <= 25; i++)
                if (
                  ((phi += dphi =
                    ((0.5 *
                      (com =
                        1 - (con = eccent * (sinphi = Math.sin(phi))) * con) *
                      com) /
                      (cosphi = Math.cos(phi))) *
                    (qs / (1 - eccnts) -
                      sinphi / com +
                      (0.5 / eccent) * Math.log((1 - con) / (1 + con)))),
                  Math.abs(dphi) <= 1e-7)
                )
                  return phi;
              return null;
            }),
            (exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/asinz": 69,
          "../common/msfnz": 78,
          "../common/qsfnz": 83,
        },
      ],
      105: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            mlfn = require("../common/mlfn"),
            e0fn = require("../common/e0fn"),
            e1fn = require("../common/e1fn"),
            e2fn = require("../common/e2fn"),
            e3fn = require("../common/e3fn"),
            gN = require("../common/gN"),
            asinz = require("../common/asinz"),
            imlfn = require("../common/imlfn");
          (exports.init = function () {
            (this.sin_p12 = Math.sin(this.lat0)),
              (this.cos_p12 = Math.cos(this.lat0));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                sinphi = Math.sin(p.y),
                cosphi = Math.cos(p.y),
                dlon = adjust_lon(lon - this.long0),
                e0,
                e1,
                e2,
                e3,
                Mlp,
                Ml,
                tanphi,
                Nl1,
                Nl,
                psi,
                Az,
                G,
                H,
                GH,
                Hs,
                c,
                kp,
                cos_c,
                s,
                s2,
                s3,
                s4,
                s5;
              return this.sphere
                ? Math.abs(this.sin_p12 - 1) <= 1e-10
                  ? ((p.x =
                      this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon)),
                    (p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon)),
                    p)
                  : Math.abs(this.sin_p12 + 1) <= 1e-10
                  ? ((p.x =
                      this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon)),
                    (p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon)),
                    p)
                  : ((cos_c =
                      this.sin_p12 * sinphi +
                      this.cos_p12 * cosphi * Math.cos(dlon)),
                    (kp = (c = Math.acos(cos_c)) / Math.sin(c)),
                    (p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon)),
                    (p.y =
                      this.y0 +
                      this.a *
                        kp *
                        (this.cos_p12 * sinphi -
                          this.sin_p12 * cosphi * Math.cos(dlon))),
                    p)
                : ((e0 = e0fn(this.es)),
                  (e1 = e1fn(this.es)),
                  (e2 = e2fn(this.es)),
                  (e3 = e3fn(this.es)),
                  Math.abs(this.sin_p12 - 1) <= 1e-10
                    ? ((Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI)),
                      (Ml = this.a * mlfn(e0, e1, e2, e3, lat)),
                      (p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon)),
                      (p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon)),
                      p)
                    : Math.abs(this.sin_p12 + 1) <= 1e-10
                    ? ((Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI)),
                      (Ml = this.a * mlfn(e0, e1, e2, e3, lat)),
                      (p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon)),
                      (p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon)),
                      p)
                    : ((tanphi = sinphi / cosphi),
                      (Nl1 = gN(this.a, this.e, this.sin_p12)),
                      (Nl = gN(this.a, this.e, sinphi)),
                      (psi = Math.atan(
                        (1 - this.es) * tanphi +
                          (this.es * Nl1 * this.sin_p12) / (Nl * cosphi)
                      )),
                      (s =
                        0 ===
                        (Az = Math.atan2(
                          Math.sin(dlon),
                          this.cos_p12 * Math.tan(psi) -
                            this.sin_p12 * Math.cos(dlon)
                        ))
                          ? Math.asin(
                              this.cos_p12 * Math.sin(psi) -
                                this.sin_p12 * Math.cos(psi)
                            )
                          : Math.abs(Math.abs(Az) - Math.PI) <= 1e-10
                          ? -Math.asin(
                              this.cos_p12 * Math.sin(psi) -
                                this.sin_p12 * Math.cos(psi)
                            )
                          : Math.asin(
                              (Math.sin(dlon) * Math.cos(psi)) / Math.sin(Az)
                            )),
                      (G = (this.e * this.sin_p12) / Math.sqrt(1 - this.es)),
                      (c =
                        Nl1 *
                        s *
                        (1 -
                          ((s2 = s * s) *
                            (Hs =
                              (H =
                                (this.e * this.cos_p12 * Math.cos(Az)) /
                                Math.sqrt(1 - this.es)) * H) *
                            (1 - Hs)) /
                            6 +
                          ((s3 = s2 * s) / 8) * (GH = G * H) * (1 - 2 * Hs) +
                          ((s4 = s3 * s) / 120) *
                            (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) -
                          ((s5 = s4 * s) / 48) * GH)),
                      (p.x = this.x0 + c * Math.sin(Az)),
                      (p.y = this.y0 + c * Math.cos(Az)),
                      p));
            }),
            (exports.inverse = function (p) {
              var rh,
                z,
                sinz,
                cosz,
                lon,
                lat,
                con,
                e0,
                e1,
                e2,
                e3,
                Mlp,
                M,
                N1,
                psi,
                Az,
                cosAz,
                tmp,
                A,
                B,
                D,
                Ee,
                F;
              if (((p.x -= this.x0), (p.y -= this.y0), this.sphere)) {
                if (
                  (rh = Math.sqrt(p.x * p.x + p.y * p.y)) >
                  2 * HALF_PI * this.a
                )
                  return;
                return (
                  (z = rh / this.a),
                  (sinz = Math.sin(z)),
                  (cosz = Math.cos(z)),
                  (lon = this.long0),
                  Math.abs(rh) <= 1e-10
                    ? (lat = this.lat0)
                    : ((lat = asinz(
                        cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh
                      )),
                      (con = Math.abs(this.lat0) - HALF_PI),
                      (lon =
                        Math.abs(con) <= 1e-10
                          ? this.lat0 >= 0
                            ? adjust_lon(this.long0 + Math.atan2(p.x, -p.y))
                            : adjust_lon(this.long0 - Math.atan2(-p.x, p.y))
                          : adjust_lon(
                              this.long0 +
                                Math.atan2(
                                  p.x * sinz,
                                  rh * this.cos_p12 * cosz -
                                    p.y * this.sin_p12 * sinz
                                )
                            ))),
                  (p.x = lon),
                  (p.y = lat),
                  p
                );
              }
              return (
                (e0 = e0fn(this.es)),
                (e1 = e1fn(this.es)),
                (e2 = e2fn(this.es)),
                (e3 = e3fn(this.es)),
                Math.abs(this.sin_p12 - 1) <= 1e-10
                  ? ((Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI)),
                    (rh = Math.sqrt(p.x * p.x + p.y * p.y)),
                    (lat = imlfn((M = Mlp - rh) / this.a, e0, e1, e2, e3)),
                    (lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y))),
                    (p.x = lon),
                    (p.y = lat),
                    p)
                  : Math.abs(this.sin_p12 + 1) <= 1e-10
                  ? ((Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI)),
                    (rh = Math.sqrt(p.x * p.x + p.y * p.y)),
                    (lat = imlfn((M = rh - Mlp) / this.a, e0, e1, e2, e3)),
                    (lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y))),
                    (p.x = lon),
                    (p.y = lat),
                    p)
                  : ((rh = Math.sqrt(p.x * p.x + p.y * p.y)),
                    (Az = Math.atan2(p.x, p.y)),
                    (N1 = gN(this.a, this.e, this.sin_p12)),
                    (cosAz = Math.cos(Az)),
                    (A =
                      (-(tmp = this.e * this.cos_p12 * cosAz) * tmp) /
                      (1 - this.es)),
                    (B =
                      (3 *
                        this.es *
                        (1 - A) *
                        this.sin_p12 *
                        this.cos_p12 *
                        cosAz) /
                      (1 - this.es)),
                    (F =
                      1 -
                      (A *
                        (Ee =
                          (D = rh / N1) -
                          (A * (1 + A) * Math.pow(D, 3)) / 6 -
                          (B * (1 + 3 * A) * Math.pow(D, 4)) / 24) *
                        Ee) /
                        2 -
                      (D * Ee * Ee * Ee) / 6),
                    (psi = Math.asin(
                      this.sin_p12 * Math.cos(Ee) +
                        this.cos_p12 * Math.sin(Ee) * cosAz
                    )),
                    (lon = adjust_lon(
                      this.long0 +
                        Math.asin((Math.sin(Az) * Math.sin(Ee)) / Math.cos(psi))
                    )),
                    (lat = Math.atan(
                      ((1 - (this.es * F * this.sin_p12) / Math.sin(psi)) *
                        Math.tan(psi)) /
                        (1 - this.es)
                    )),
                    (p.x = lon),
                    (p.y = lat),
                    p)
              );
            }),
            (exports.names = ["Azimuthal_Equidistant", "aeqd"]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/asinz": 69,
          "../common/e0fn": 70,
          "../common/e1fn": 71,
          "../common/e2fn": 72,
          "../common/e3fn": 73,
          "../common/gN": 74,
          "../common/imlfn": 75,
          "../common/mlfn": 77,
        },
      ],
      106: [
        function (require, module, exports) {
          var mlfn = require("../common/mlfn"),
            e0fn = require("../common/e0fn"),
            e1fn = require("../common/e1fn"),
            e2fn = require("../common/e2fn"),
            e3fn = require("../common/e3fn"),
            gN = require("../common/gN"),
            adjust_lon = require("../common/adjust_lon"),
            adjust_lat = require("../common/adjust_lat"),
            imlfn = require("../common/imlfn"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10;
          (exports.init = function () {
            this.sphere ||
              ((this.e0 = e0fn(this.es)),
              (this.e1 = e1fn(this.es)),
              (this.e2 = e2fn(this.es)),
              (this.e3 = e3fn(this.es)),
              (this.ml0 =
                this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0)));
          }),
            (exports.forward = function (p) {
              var x,
                y,
                lam = p.x,
                phi = p.y;
              if (((lam = adjust_lon(lam - this.long0)), this.sphere))
                (x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam))),
                  (y =
                    this.a *
                    (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0));
              else {
                var sinphi = Math.sin(phi),
                  cosphi = Math.cos(phi),
                  nl = gN(this.a, this.e, sinphi),
                  tl = Math.tan(phi) * Math.tan(phi),
                  al = lam * Math.cos(phi),
                  asq = al * al,
                  cl = (this.es * cosphi * cosphi) / (1 - this.es),
                  ml;
                (x =
                  nl *
                  al *
                  (1 - asq * tl * (1 / 6 - ((8 - tl + 8 * cl) * asq) / 120))),
                  (y =
                    this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi) -
                    this.ml0 +
                    ((nl * sinphi) / cosphi) *
                      asq *
                      (0.5 + ((5 - tl + 6 * cl) * asq) / 24));
              }
              return (p.x = x + this.x0), (p.y = y + this.y0), p;
            }),
            (exports.inverse = function (p) {
              (p.x -= this.x0), (p.y -= this.y0);
              var x = p.x / this.a,
                y = p.y / this.a,
                phi,
                lam;
              if (this.sphere) {
                var dd = y + this.lat0;
                (phi = Math.asin(Math.sin(dd) * Math.cos(x))),
                  (lam = Math.atan2(Math.tan(x), Math.cos(dd)));
              } else {
                var ml1 = this.ml0 / this.a + y,
                  phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
                if (Math.abs(Math.abs(phi1) - HALF_PI) <= 1e-10)
                  return (
                    (p.x = this.long0), (p.y = HALF_PI), y < 0 && (p.y *= -1), p
                  );
                var nl1 = gN(this.a, this.e, Math.sin(phi1)),
                  rl1 = ((nl1 * nl1 * nl1) / this.a / this.a) * (1 - this.es),
                  tl1 = Math.pow(Math.tan(phi1), 2),
                  dl = (x * this.a) / nl1,
                  dsq = dl * dl;
                (phi =
                  phi1 -
                  ((nl1 * Math.tan(phi1)) / rl1) *
                    dl *
                    dl *
                    (0.5 - ((1 + 3 * tl1) * dl * dl) / 24)),
                  (lam =
                    (dl *
                      (1 -
                        dsq * (tl1 / 3 + ((1 + 3 * tl1) * tl1 * dsq) / 15))) /
                    Math.cos(phi1));
              }
              return (
                (p.x = adjust_lon(lam + this.long0)), (p.y = adjust_lat(phi)), p
              );
            }),
            (exports.names = ["Cassini", "Cassini_Soldner", "cass"]);
        },
        {
          "../common/adjust_lat": 67,
          "../common/adjust_lon": 68,
          "../common/e0fn": 70,
          "../common/e1fn": 71,
          "../common/e2fn": 72,
          "../common/e3fn": 73,
          "../common/gN": 74,
          "../common/imlfn": 75,
          "../common/mlfn": 77,
        },
      ],
      107: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            qsfnz = require("../common/qsfnz"),
            msfnz = require("../common/msfnz"),
            iqsfnz = require("../common/iqsfnz");
          (exports.init = function () {
            this.sphere ||
              (this.k0 = msfnz(
                this.e,
                Math.sin(this.lat_ts),
                Math.cos(this.lat_ts)
              ));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                x,
                y,
                dlon = adjust_lon(lon - this.long0);
              if (this.sphere)
                (x = this.x0 + this.a * dlon * Math.cos(this.lat_ts)),
                  (y =
                    this.y0 + (this.a * Math.sin(lat)) / Math.cos(this.lat_ts));
              else {
                var qs = qsfnz(this.e, Math.sin(lat));
                (x = this.x0 + this.a * this.k0 * dlon),
                  (y = this.y0 + (this.a * qs * 0.5) / this.k0);
              }
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var lon, lat;
              return (
                (p.x -= this.x0),
                (p.y -= this.y0),
                this.sphere
                  ? ((lon = adjust_lon(
                      this.long0 + p.x / this.a / Math.cos(this.lat_ts)
                    )),
                    (lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts))))
                  : ((lat = iqsfnz(this.e, (2 * p.y * this.k0) / this.a)),
                    (lon = adjust_lon(this.long0 + p.x / (this.a * this.k0)))),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = ["cea"]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/iqsfnz": 76,
          "../common/msfnz": 78,
          "../common/qsfnz": 83,
        },
      ],
      108: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            adjust_lat = require("../common/adjust_lat");
          (exports.init = function () {
            (this.x0 = this.x0 || 0),
              (this.y0 = this.y0 || 0),
              (this.lat0 = this.lat0 || 0),
              (this.long0 = this.long0 || 0),
              (this.lat_ts = this.lat_ts || 0),
              (this.title =
                this.title || "Equidistant Cylindrical (Plate Carre)"),
              (this.rc = Math.cos(this.lat_ts));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                dlon = adjust_lon(lon - this.long0),
                dlat = adjust_lat(lat - this.lat0);
              return (
                (p.x = this.x0 + this.a * dlon * this.rc),
                (p.y = this.y0 + this.a * dlat),
                p
              );
            }),
            (exports.inverse = function (p) {
              var x = p.x,
                y = p.y;
              return (
                (p.x = adjust_lon(
                  this.long0 + (x - this.x0) / (this.a * this.rc)
                )),
                (p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a)),
                p
              );
            }),
            (exports.names = [
              "Equirectangular",
              "Equidistant_Cylindrical",
              "eqc",
            ]);
        },
        { "../common/adjust_lat": 67, "../common/adjust_lon": 68 },
      ],
      109: [
        function (require, module, exports) {
          var e0fn = require("../common/e0fn"),
            e1fn = require("../common/e1fn"),
            e2fn = require("../common/e2fn"),
            e3fn = require("../common/e3fn"),
            msfnz = require("../common/msfnz"),
            mlfn = require("../common/mlfn"),
            adjust_lon = require("../common/adjust_lon"),
            adjust_lat = require("../common/adjust_lat"),
            imlfn = require("../common/imlfn"),
            EPSLN = 1e-10;
          (exports.init = function () {
            Math.abs(this.lat1 + this.lat2) < 1e-10 ||
              ((this.lat2 = this.lat2 || this.lat1),
              (this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e = Math.sqrt(this.es)),
              (this.e0 = e0fn(this.es)),
              (this.e1 = e1fn(this.es)),
              (this.e2 = e2fn(this.es)),
              (this.e3 = e3fn(this.es)),
              (this.sinphi = Math.sin(this.lat1)),
              (this.cosphi = Math.cos(this.lat1)),
              (this.ms1 = msfnz(this.e, this.sinphi, this.cosphi)),
              (this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1)),
              Math.abs(this.lat1 - this.lat2) < 1e-10
                ? (this.ns = this.sinphi)
                : ((this.sinphi = Math.sin(this.lat2)),
                  (this.cosphi = Math.cos(this.lat2)),
                  (this.ms2 = msfnz(this.e, this.sinphi, this.cosphi)),
                  (this.ml2 = mlfn(
                    this.e0,
                    this.e1,
                    this.e2,
                    this.e3,
                    this.lat2
                  )),
                  (this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1))),
              (this.g = this.ml1 + this.ms1 / this.ns),
              (this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0)),
              (this.rh = this.a * (this.g - this.ml0)));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                rh1;
              if (this.sphere) rh1 = this.a * (this.g - lat);
              else {
                var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
                rh1 = this.a * (this.g - ml);
              }
              var theta = this.ns * adjust_lon(lon - this.long0),
                x = this.x0 + rh1 * Math.sin(theta),
                y = this.y0 + this.rh - rh1 * Math.cos(theta);
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var con, rh1, lat, lon;
              (p.x -= this.x0),
                (p.y = this.rh - p.y + this.y0),
                this.ns >= 0
                  ? ((rh1 = Math.sqrt(p.x * p.x + p.y * p.y)), (con = 1))
                  : ((rh1 = -Math.sqrt(p.x * p.x + p.y * p.y)), (con = -1));
              var theta = 0;
              if (
                (0 !== rh1 && (theta = Math.atan2(con * p.x, con * p.y)),
                this.sphere)
              )
                return (
                  (lon = adjust_lon(this.long0 + theta / this.ns)),
                  (lat = adjust_lat(this.g - rh1 / this.a)),
                  (p.x = lon),
                  (p.y = lat),
                  p
                );
              var ml = this.g - rh1 / this.a;
              return (
                (lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3)),
                (lon = adjust_lon(this.long0 + theta / this.ns)),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = ["Equidistant_Conic", "eqdc"]);
        },
        {
          "../common/adjust_lat": 67,
          "../common/adjust_lon": 68,
          "../common/e0fn": 70,
          "../common/e1fn": 71,
          "../common/e2fn": 72,
          "../common/e3fn": 73,
          "../common/imlfn": 75,
          "../common/mlfn": 77,
          "../common/msfnz": 78,
        },
      ],
      110: [
        function (require, module, exports) {
          var FORTPI = Math.PI / 4,
            srat = require("../common/srat"),
            HALF_PI = Math.PI / 2,
            MAX_ITER = 20;
          (exports.init = function () {
            var sphi = Math.sin(this.lat0),
              cphi = Math.cos(this.lat0);
            (cphi *= cphi),
              (this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi)),
              (this.C = Math.sqrt(1 + (this.es * cphi * cphi) / (1 - this.es))),
              (this.phic0 = Math.asin(sphi / this.C)),
              (this.ratexp = 0.5 * this.C * this.e),
              (this.K =
                Math.tan(0.5 * this.phic0 + FORTPI) /
                (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) *
                  srat(this.e * sphi, this.ratexp)));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y;
              return (
                (p.y =
                  2 *
                    Math.atan(
                      this.K *
                        Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) *
                        srat(this.e * Math.sin(lat), this.ratexp)
                    ) -
                  HALF_PI),
                (p.x = this.C * lon),
                p
              );
            }),
            (exports.inverse = function (p) {
              for (
                var DEL_TOL = 1e-14,
                  lon = p.x / this.C,
                  lat = p.y,
                  num = Math.pow(
                    Math.tan(0.5 * lat + FORTPI) / this.K,
                    1 / this.C
                  ),
                  i = 20;
                i > 0 &&
                ((lat =
                  2 *
                    Math.atan(
                      num * srat(this.e * Math.sin(p.y), -0.5 * this.e)
                    ) -
                  HALF_PI),
                !(Math.abs(lat - p.y) < 1e-14));
                --i
              )
                p.y = lat;
              return i ? ((p.x = lon), (p.y = lat), p) : null;
            }),
            (exports.names = ["gauss"]);
        },
        { "../common/srat": 85 },
      ],
      111: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            EPSLN = 1e-10,
            asinz = require("../common/asinz");
          (exports.init = function () {
            (this.sin_p14 = Math.sin(this.lat0)),
              (this.cos_p14 = Math.cos(this.lat0)),
              (this.infinity_dist = 1e3 * this.a),
              (this.rc = 1);
          }),
            (exports.forward = function (p) {
              var sinphi,
                cosphi,
                dlon,
                coslon,
                ksp,
                g,
                x,
                y,
                lon = p.x,
                lat = p.y;
              return (
                (dlon = adjust_lon(lon - this.long0)),
                (sinphi = Math.sin(lat)),
                (cosphi = Math.cos(lat)),
                (coslon = Math.cos(dlon)),
                (ksp = 1),
                (g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon) >
                  0 || Math.abs(g) <= 1e-10
                  ? ((x = this.x0 + (1 * this.a * cosphi * Math.sin(dlon)) / g),
                    (y =
                      this.y0 +
                      (1 *
                        this.a *
                        (this.cos_p14 * sinphi -
                          this.sin_p14 * cosphi * coslon)) /
                        g))
                  : ((x =
                      this.x0 + this.infinity_dist * cosphi * Math.sin(dlon)),
                    (y =
                      this.y0 +
                      this.infinity_dist *
                        (this.cos_p14 * sinphi -
                          this.sin_p14 * cosphi * coslon))),
                (p.x = x),
                (p.y = y),
                p
              );
            }),
            (exports.inverse = function (p) {
              var rh, sinc, cosc, c, lon, lat;
              return (
                (p.x = (p.x - this.x0) / this.a),
                (p.y = (p.y - this.y0) / this.a),
                (p.x /= this.k0),
                (p.y /= this.k0),
                (rh = Math.sqrt(p.x * p.x + p.y * p.y))
                  ? ((c = Math.atan2(rh, this.rc)),
                    (sinc = Math.sin(c)),
                    (cosc = Math.cos(c)),
                    (lat = asinz(
                      cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh
                    )),
                    (lon = Math.atan2(
                      p.x * sinc,
                      rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc
                    )),
                    (lon = adjust_lon(this.long0 + lon)))
                  : ((lat = this.phic0), (lon = 0)),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = ["gnom"]);
        },
        { "../common/adjust_lon": 68, "../common/asinz": 69 },
      ],
      112: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon");
          (exports.init = function () {
            (this.a = 6377397.155),
              (this.es = 0.006674372230614),
              (this.e = Math.sqrt(this.es)),
              this.lat0 || (this.lat0 = 0.863937979737193),
              this.long0 || (this.long0 = 0.4334234309119251),
              this.k0 || (this.k0 = 0.9999),
              (this.s45 = 0.785398163397448),
              (this.s90 = 2 * this.s45),
              (this.fi0 = this.lat0),
              (this.e2 = this.es),
              (this.e = Math.sqrt(this.e2)),
              (this.alfa = Math.sqrt(
                1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2)
              )),
              (this.uq = 1.04216856380474),
              (this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa)),
              (this.g = Math.pow(
                (1 + this.e * Math.sin(this.fi0)) /
                  (1 - this.e * Math.sin(this.fi0)),
                (this.alfa * this.e) / 2
              )),
              (this.k =
                (Math.tan(this.u0 / 2 + this.s45) /
                  Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa)) *
                this.g),
              (this.k1 = this.k0),
              (this.n0 =
                (this.a * Math.sqrt(1 - this.e2)) /
                (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2))),
              (this.s0 = 1.37008346281555),
              (this.n = Math.sin(this.s0)),
              (this.ro0 = (this.k1 * this.n0) / Math.tan(this.s0)),
              (this.ad = this.s90 - this.uq);
          }),
            (exports.forward = function (p) {
              var gfi,
                u,
                deltav,
                s,
                d,
                eps,
                ro,
                lon = p.x,
                lat = p.y,
                delta_lon = adjust_lon(lon - this.long0);
              return (
                (gfi = Math.pow(
                  (1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)),
                  (this.alfa * this.e) / 2
                )),
                (u =
                  2 *
                  (Math.atan(
                    (this.k *
                      Math.pow(Math.tan(lat / 2 + this.s45), this.alfa)) /
                      gfi
                  ) -
                    this.s45)),
                (deltav = -delta_lon * this.alfa),
                (s = Math.asin(
                  Math.cos(this.ad) * Math.sin(u) +
                    Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav)
                )),
                (d = Math.asin((Math.cos(u) * Math.sin(deltav)) / Math.cos(s))),
                (eps = this.n * d),
                (ro =
                  (this.ro0 *
                    Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n)) /
                  Math.pow(Math.tan(s / 2 + this.s45), this.n)),
                (p.y = (ro * Math.cos(eps)) / 1),
                (p.x = (ro * Math.sin(eps)) / 1),
                this.czech || ((p.y *= -1), (p.x *= -1)),
                p
              );
            }),
            (exports.inverse = function (p) {
              var u,
                deltav,
                s,
                d,
                eps,
                ro,
                fi1,
                ok,
                tmp = p.x;
              (p.x = p.y),
                (p.y = tmp),
                this.czech || ((p.y *= -1), (p.x *= -1)),
                (ro = Math.sqrt(p.x * p.x + p.y * p.y)),
                (d = (eps = Math.atan2(p.y, p.x)) / Math.sin(this.s0)),
                (s =
                  2 *
                  (Math.atan(
                    Math.pow(this.ro0 / ro, 1 / this.n) *
                      Math.tan(this.s0 / 2 + this.s45)
                  ) -
                    this.s45)),
                (u = Math.asin(
                  Math.cos(this.ad) * Math.sin(s) -
                    Math.sin(this.ad) * Math.cos(s) * Math.cos(d)
                )),
                (deltav = Math.asin((Math.cos(s) * Math.sin(d)) / Math.cos(u))),
                (p.x = this.long0 - deltav / this.alfa),
                (fi1 = u),
                (ok = 0);
              var iter = 0;
              do {
                (p.y =
                  2 *
                  (Math.atan(
                    Math.pow(this.k, -1 / this.alfa) *
                      Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) *
                      Math.pow(
                        (1 + this.e * Math.sin(fi1)) /
                          (1 - this.e * Math.sin(fi1)),
                        this.e / 2
                      )
                  ) -
                    this.s45)),
                  Math.abs(fi1 - p.y) < 1e-10 && (ok = 1),
                  (fi1 = p.y),
                  (iter += 1);
              } while (0 === ok && iter < 15);
              return iter >= 15 ? null : p;
            }),
            (exports.names = ["Krovak", "krovak"]);
        },
        { "../common/adjust_lon": 68 },
      ],
      113: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2,
            FORTPI = Math.PI / 4,
            EPSLN = 1e-10,
            qsfnz = require("../common/qsfnz"),
            adjust_lon = require("../common/adjust_lon");
          (exports.S_POLE = 1),
            (exports.N_POLE = 2),
            (exports.EQUIT = 3),
            (exports.OBLIQ = 4),
            (exports.init = function () {
              var t = Math.abs(this.lat0),
                sinphi;
              if (
                (Math.abs(t - HALF_PI) < 1e-10
                  ? (this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE)
                  : Math.abs(t) < 1e-10
                  ? (this.mode = this.EQUIT)
                  : (this.mode = this.OBLIQ),
                this.es > 0)
              )
                switch (
                  ((this.qp = qsfnz(this.e, 1)),
                  (this.mmf = 0.5 / (1 - this.es)),
                  (this.apa = this.authset(this.es)),
                  this.mode)
                ) {
                  case this.N_POLE:
                  case this.S_POLE:
                    this.dd = 1;
                    break;
                  case this.EQUIT:
                    (this.rq = Math.sqrt(0.5 * this.qp)),
                      (this.dd = 1 / this.rq),
                      (this.xmf = 1),
                      (this.ymf = 0.5 * this.qp);
                    break;
                  case this.OBLIQ:
                    (this.rq = Math.sqrt(0.5 * this.qp)),
                      (sinphi = Math.sin(this.lat0)),
                      (this.sinb1 = qsfnz(this.e, sinphi) / this.qp),
                      (this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1)),
                      (this.dd =
                        Math.cos(this.lat0) /
                        (Math.sqrt(1 - this.es * sinphi * sinphi) *
                          this.rq *
                          this.cosb1)),
                      (this.ymf = (this.xmf = this.rq) / this.dd),
                      (this.xmf *= this.dd);
                }
              else
                this.mode === this.OBLIQ &&
                  ((this.sinph0 = Math.sin(this.lat0)),
                  (this.cosph0 = Math.cos(this.lat0)));
            }),
            (exports.forward = function (p) {
              var x,
                y,
                coslam,
                sinlam,
                sinphi,
                q,
                sinb,
                cosb,
                b,
                cosphi,
                lam = p.x,
                phi = p.y;
              if (((lam = adjust_lon(lam - this.long0)), this.sphere)) {
                if (
                  ((sinphi = Math.sin(phi)),
                  (cosphi = Math.cos(phi)),
                  (coslam = Math.cos(lam)),
                  this.mode === this.OBLIQ || this.mode === this.EQUIT)
                ) {
                  if (
                    (y =
                      this.mode === this.EQUIT
                        ? 1 + cosphi * coslam
                        : 1 +
                          this.sinph0 * sinphi +
                          this.cosph0 * cosphi * coslam) <= 1e-10
                  )
                    return null;
                  (x = (y = Math.sqrt(2 / y)) * cosphi * Math.sin(lam)),
                    (y *=
                      this.mode === this.EQUIT
                        ? sinphi
                        : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam);
                } else if (
                  this.mode === this.N_POLE ||
                  this.mode === this.S_POLE
                ) {
                  if (
                    (this.mode === this.N_POLE && (coslam = -coslam),
                    Math.abs(phi + this.phi0) < 1e-10)
                  )
                    return null;
                  (y = FORTPI - 0.5 * phi),
                    (x =
                      (y =
                        2 *
                        (this.mode === this.S_POLE
                          ? Math.cos(y)
                          : Math.sin(y))) * Math.sin(lam)),
                    (y *= coslam);
                }
              } else {
                switch (
                  ((sinb = 0),
                  (cosb = 0),
                  (b = 0),
                  (coslam = Math.cos(lam)),
                  (sinlam = Math.sin(lam)),
                  (sinphi = Math.sin(phi)),
                  (q = qsfnz(this.e, sinphi)),
                  (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
                    ((sinb = q / this.qp), (cosb = Math.sqrt(1 - sinb * sinb))),
                  this.mode)
                ) {
                  case this.OBLIQ:
                    b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                    break;
                  case this.EQUIT:
                    b = 1 + cosb * coslam;
                    break;
                  case this.N_POLE:
                    (b = HALF_PI + phi), (q = this.qp - q);
                    break;
                  case this.S_POLE:
                    (b = phi - HALF_PI), (q = this.qp + q);
                }
                if (Math.abs(b) < 1e-10) return null;
                switch (this.mode) {
                  case this.OBLIQ:
                  case this.EQUIT:
                    (b = Math.sqrt(2 / b)),
                      (y =
                        this.mode === this.OBLIQ
                          ? this.ymf *
                            b *
                            (this.cosb1 * sinb - this.sinb1 * cosb * coslam)
                          : (b = Math.sqrt(2 / (1 + cosb * coslam))) *
                            sinb *
                            this.ymf),
                      (x = this.xmf * b * cosb * sinlam);
                    break;
                  case this.N_POLE:
                  case this.S_POLE:
                    q >= 0
                      ? ((x = (b = Math.sqrt(q)) * sinlam),
                        (y = coslam * (this.mode === this.S_POLE ? b : -b)))
                      : (x = y = 0);
                }
              }
              return (
                (p.x = this.a * x + this.x0), (p.y = this.a * y + this.y0), p
              );
            }),
            (exports.inverse = function (p) {
              (p.x -= this.x0), (p.y -= this.y0);
              var x = p.x / this.a,
                y = p.y / this.a,
                lam,
                phi,
                cCe,
                sCe,
                q,
                rho,
                ab;
              if (this.sphere) {
                var cosz = 0,
                  rh,
                  sinz = 0;
                if ((phi = 0.5 * (rh = Math.sqrt(x * x + y * y))) > 1)
                  return null;
                switch (
                  ((phi = 2 * Math.asin(phi)),
                  (this.mode !== this.OBLIQ && this.mode !== this.EQUIT) ||
                    ((sinz = Math.sin(phi)), (cosz = Math.cos(phi))),
                  this.mode)
                ) {
                  case this.EQUIT:
                    (phi =
                      Math.abs(rh) <= 1e-10 ? 0 : Math.asin((y * sinz) / rh)),
                      (x *= sinz),
                      (y = cosz * rh);
                    break;
                  case this.OBLIQ:
                    (phi =
                      Math.abs(rh) <= 1e-10
                        ? this.phi0
                        : Math.asin(
                            cosz * this.sinph0 + (y * sinz * this.cosph0) / rh
                          )),
                      (x *= sinz * this.cosph0),
                      (y = (cosz - Math.sin(phi) * this.sinph0) * rh);
                    break;
                  case this.N_POLE:
                    (y = -y), (phi = HALF_PI - phi);
                    break;
                  case this.S_POLE:
                    phi -= HALF_PI;
                }
                lam =
                  0 !== y ||
                  (this.mode !== this.EQUIT && this.mode !== this.OBLIQ)
                    ? Math.atan2(x, y)
                    : 0;
              } else {
                if (
                  ((ab = 0),
                  this.mode === this.OBLIQ || this.mode === this.EQUIT)
                ) {
                  if (
                    ((x /= this.dd),
                    (y *= this.dd),
                    (rho = Math.sqrt(x * x + y * y)) < 1e-10)
                  )
                    return (p.x = 0), (p.y = this.phi0), p;
                  (sCe = 2 * Math.asin((0.5 * rho) / this.rq)),
                    (cCe = Math.cos(sCe)),
                    (x *= sCe = Math.sin(sCe)),
                    this.mode === this.OBLIQ
                      ? ((ab = cCe * this.sinb1 + (y * sCe * this.cosb1) / rho),
                        (q = this.qp * ab),
                        (y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe))
                      : ((ab = (y * sCe) / rho),
                        (q = this.qp * ab),
                        (y = rho * cCe));
                } else if (
                  this.mode === this.N_POLE ||
                  this.mode === this.S_POLE
                ) {
                  if (
                    (this.mode === this.N_POLE && (y = -y),
                    !(q = x * x + y * y))
                  )
                    return (p.x = 0), (p.y = this.phi0), p;
                  (ab = 1 - q / this.qp),
                    this.mode === this.S_POLE && (ab = -ab);
                }
                (lam = Math.atan2(x, y)),
                  (phi = this.authlat(Math.asin(ab), this.apa));
              }
              return (p.x = adjust_lon(this.long0 + lam)), (p.y = phi), p;
            }),
            (exports.P00 = 0.3333333333333333),
            (exports.P01 = 0.17222222222222222),
            (exports.P02 = 0.10257936507936508),
            (exports.P10 = 0.06388888888888888),
            (exports.P11 = 0.0664021164021164),
            (exports.P20 = 0.016415012942191543),
            (exports.authset = function (es) {
              var t,
                APA = [];
              return (
                (APA[0] = es * this.P00),
                (t = es * es),
                (APA[0] += t * this.P01),
                (APA[1] = t * this.P10),
                (t *= es),
                (APA[0] += t * this.P02),
                (APA[1] += t * this.P11),
                (APA[2] = t * this.P20),
                APA
              );
            }),
            (exports.authlat = function (beta, APA) {
              var t = beta + beta;
              return (
                beta +
                APA[0] * Math.sin(t) +
                APA[1] * Math.sin(t + t) +
                APA[2] * Math.sin(t + t + t)
              );
            }),
            (exports.names = [
              "Lambert Azimuthal Equal Area",
              "Lambert_Azimuthal_Equal_Area",
              "laea",
            ]);
        },
        { "../common/adjust_lon": 68, "../common/qsfnz": 83 },
      ],
      114: [
        function (require, module, exports) {
          var EPSLN = 1e-10,
            msfnz = require("../common/msfnz"),
            tsfnz = require("../common/tsfnz"),
            HALF_PI = Math.PI / 2,
            sign = require("../common/sign"),
            adjust_lon = require("../common/adjust_lon"),
            phi2z = require("../common/phi2z");
          (exports.init = function () {
            if (
              (this.lat2 || (this.lat2 = this.lat1),
              this.k0 || (this.k0 = 1),
              (this.x0 = this.x0 || 0),
              (this.y0 = this.y0 || 0),
              !(Math.abs(this.lat1 + this.lat2) < 1e-10))
            ) {
              var temp = this.b / this.a;
              this.e = Math.sqrt(1 - temp * temp);
              var sin1 = Math.sin(this.lat1),
                cos1 = Math.cos(this.lat1),
                ms1 = msfnz(this.e, sin1, cos1),
                ts1 = tsfnz(this.e, this.lat1, sin1),
                sin2 = Math.sin(this.lat2),
                cos2 = Math.cos(this.lat2),
                ms2 = msfnz(this.e, sin2, cos2),
                ts2 = tsfnz(this.e, this.lat2, sin2),
                ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
              Math.abs(this.lat1 - this.lat2) > 1e-10
                ? (this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2))
                : (this.ns = sin1),
                isNaN(this.ns) && (this.ns = sin1),
                (this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns))),
                (this.rh = this.a * this.f0 * Math.pow(ts0, this.ns)),
                this.title || (this.title = "Lambert Conformal Conic");
            }
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y;
              Math.abs(2 * Math.abs(lat) - Math.PI) <= 1e-10 &&
                (lat = sign(lat) * (HALF_PI - 2e-10));
              var con = Math.abs(Math.abs(lat) - HALF_PI),
                ts,
                rh1;
              if (con > 1e-10)
                (ts = tsfnz(this.e, lat, Math.sin(lat))),
                  (rh1 = this.a * this.f0 * Math.pow(ts, this.ns));
              else {
                if ((con = lat * this.ns) <= 0) return null;
                rh1 = 0;
              }
              var theta = this.ns * adjust_lon(lon - this.long0);
              return (
                (p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0),
                (p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0),
                p
              );
            }),
            (exports.inverse = function (p) {
              var rh1,
                con,
                ts,
                lat,
                lon,
                x = (p.x - this.x0) / this.k0,
                y = this.rh - (p.y - this.y0) / this.k0;
              this.ns > 0
                ? ((rh1 = Math.sqrt(x * x + y * y)), (con = 1))
                : ((rh1 = -Math.sqrt(x * x + y * y)), (con = -1));
              var theta = 0;
              if (
                (0 !== rh1 && (theta = Math.atan2(con * x, con * y)),
                0 !== rh1 || this.ns > 0)
              ) {
                if (
                  ((con = 1 / this.ns),
                  (ts = Math.pow(rh1 / (this.a * this.f0), con)),
                  -9999 === (lat = phi2z(this.e, ts)))
                )
                  return null;
              } else lat = -HALF_PI;
              return (
                (lon = adjust_lon(theta / this.ns + this.long0)),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = [
              "Lambert Tangential Conformal Conic Projection",
              "Lambert_Conformal_Conic",
              "Lambert_Conformal_Conic_2SP",
              "lcc",
            ]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/msfnz": 78,
          "../common/phi2z": 79,
          "../common/sign": 84,
          "../common/tsfnz": 87,
        },
      ],
      115: [
        function (require, module, exports) {
          function identity(pt) {
            return pt;
          }
          (exports.init = function () {}),
            (exports.forward = identity),
            (exports.inverse = identity),
            (exports.names = ["longlat", "identity"]);
        },
        {},
      ],
      116: [
        function (require, module, exports) {
          var msfnz = require("../common/msfnz"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            R2D = 57.29577951308232,
            adjust_lon = require("../common/adjust_lon"),
            FORTPI = Math.PI / 4,
            tsfnz = require("../common/tsfnz"),
            phi2z = require("../common/phi2z");
          (exports.init = function () {
            var con = this.b / this.a;
            (this.es = 1 - con * con),
              "x0" in this || (this.x0 = 0),
              "y0" in this || (this.y0 = 0),
              (this.e = Math.sqrt(this.es)),
              this.lat_ts
                ? this.sphere
                  ? (this.k0 = Math.cos(this.lat_ts))
                  : (this.k0 = msfnz(
                      this.e,
                      Math.sin(this.lat_ts),
                      Math.cos(this.lat_ts)
                    ))
                : this.k0 || (this.k ? (this.k0 = this.k) : (this.k0 = 1));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                x,
                y;
              if (
                lat * R2D > 90 &&
                lat * R2D < -90 &&
                lon * R2D > 180 &&
                lon * R2D < -180
              )
                return null;
              if (Math.abs(Math.abs(lat) - HALF_PI) <= 1e-10) return null;
              if (this.sphere)
                (x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0)),
                  (y =
                    this.y0 +
                    this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat)));
              else {
                var sinphi = Math.sin(lat),
                  ts = tsfnz(this.e, lat, sinphi);
                (x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0)),
                  (y = this.y0 - this.a * this.k0 * Math.log(ts));
              }
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var x = p.x - this.x0,
                y = p.y - this.y0,
                lon,
                lat;
              if (this.sphere)
                lat =
                  HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
              else {
                var ts = Math.exp(-y / (this.a * this.k0));
                if (-9999 === (lat = phi2z(this.e, ts))) return null;
              }
              return (
                (lon = adjust_lon(this.long0 + x / (this.a * this.k0))),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = [
              "Mercator",
              "Popular Visualisation Pseudo Mercator",
              "Mercator_1SP",
              "Mercator_Auxiliary_Sphere",
              "merc",
            ]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/msfnz": 78,
          "../common/phi2z": 79,
          "../common/tsfnz": 87,
        },
      ],
      117: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon");
          (exports.init = function () {}),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                dlon = adjust_lon(lon - this.long0),
                x = this.x0 + this.a * dlon,
                y =
                  this.y0 +
                  this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              (p.x -= this.x0), (p.y -= this.y0);
              var lon = adjust_lon(this.long0 + p.x / this.a),
                lat =
                  2.5 *
                  (Math.atan(Math.exp((0.8 * p.y) / this.a)) - Math.PI / 4);
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = ["Miller_Cylindrical", "mill"]);
        },
        { "../common/adjust_lon": 68 },
      ],
      118: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            EPSLN = 1e-10;
          (exports.init = function () {}),
            (exports.forward = function (p) {
              for (
                var lon = p.x,
                  lat = p.y,
                  delta_lon = adjust_lon(lon - this.long0),
                  theta = lat,
                  con = Math.PI * Math.sin(lat),
                  i = 0;
                ;
                i++
              ) {
                var delta_theta =
                  -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
                if (((theta += delta_theta), Math.abs(delta_theta) < 1e-10))
                  break;
              }
              (theta /= 2),
                Math.PI / 2 - Math.abs(lat) < 1e-10 && (delta_lon = 0);
              var x =
                  0.900316316158 * this.a * delta_lon * Math.cos(theta) +
                  this.x0,
                y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var theta, arg;
              (p.x -= this.x0),
                (p.y -= this.y0),
                (arg = p.y / (1.4142135623731 * this.a)),
                Math.abs(arg) > 0.999999999999 && (arg = 0.999999999999),
                (theta = Math.asin(arg));
              var lon = adjust_lon(
                this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta))
              );
              lon < -Math.PI && (lon = -Math.PI),
                lon > Math.PI && (lon = Math.PI),
                (arg = (2 * theta + Math.sin(2 * theta)) / Math.PI),
                Math.abs(arg) > 1 && (arg = 1);
              var lat = Math.asin(arg);
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = ["Mollweide", "moll"]);
        },
        { "../common/adjust_lon": 68 },
      ],
      119: [
        function (require, module, exports) {
          var SEC_TO_RAD = 484813681109536e-20;
          (exports.iterations = 1),
            (exports.init = function () {
              (this.A = []),
                (this.A[1] = 0.6399175073),
                (this.A[2] = -0.1358797613),
                (this.A[3] = 0.063294409),
                (this.A[4] = -0.02526853),
                (this.A[5] = 0.0117879),
                (this.A[6] = -0.0055161),
                (this.A[7] = 0.0026906),
                (this.A[8] = -0.001333),
                (this.A[9] = 67e-5),
                (this.A[10] = -34e-5),
                (this.B_re = []),
                (this.B_im = []),
                (this.B_re[1] = 0.7557853228),
                (this.B_im[1] = 0),
                (this.B_re[2] = 0.249204646),
                (this.B_im[2] = 0.003371507),
                (this.B_re[3] = -0.001541739),
                (this.B_im[3] = 0.04105856),
                (this.B_re[4] = -0.10162907),
                (this.B_im[4] = 0.01727609),
                (this.B_re[5] = -0.26623489),
                (this.B_im[5] = -0.36249218),
                (this.B_re[6] = -0.6870983),
                (this.B_im[6] = -1.1651967),
                (this.C_re = []),
                (this.C_im = []),
                (this.C_re[1] = 1.3231270439),
                (this.C_im[1] = 0),
                (this.C_re[2] = -0.577245789),
                (this.C_im[2] = -0.007809598),
                (this.C_re[3] = 0.508307513),
                (this.C_im[3] = -0.112208952),
                (this.C_re[4] = -0.15094762),
                (this.C_im[4] = 0.18200602),
                (this.C_re[5] = 1.01418179),
                (this.C_im[5] = 1.64497696),
                (this.C_re[6] = 1.9660549),
                (this.C_im[6] = 2.5127645),
                (this.D = []),
                (this.D[1] = 1.5627014243),
                (this.D[2] = 0.5185406398),
                (this.D[3] = -0.03333098),
                (this.D[4] = -0.1052906),
                (this.D[5] = -0.0368594),
                (this.D[6] = 0.007317),
                (this.D[7] = 0.0122),
                (this.D[8] = 0.00394),
                (this.D[9] = -0.0013);
            }),
            (exports.forward = function (p) {
              var n,
                lon = p.x,
                lat,
                delta_lat = p.y - this.lat0,
                delta_lon = lon - this.long0,
                d_phi = (delta_lat / SEC_TO_RAD) * 1e-5,
                d_lambda = delta_lon,
                d_phi_n = 1,
                d_psi = 0;
              for (n = 1; n <= 10; n++)
                (d_phi_n *= d_phi), (d_psi += this.A[n] * d_phi_n);
              var th_re = d_psi,
                th_im = d_lambda,
                th_n_re = 1,
                th_n_im = 0,
                th_n_re1,
                th_n_im1,
                z_re = 0,
                z_im = 0;
              for (n = 1; n <= 6; n++)
                (th_n_im1 = th_n_im * th_re + th_n_re * th_im),
                  (th_n_re = th_n_re1 = th_n_re * th_re - th_n_im * th_im),
                  (th_n_im = th_n_im1),
                  (z_re =
                    z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im),
                  (z_im =
                    z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
              return (
                (p.x = z_im * this.a + this.x0),
                (p.y = z_re * this.a + this.y0),
                p
              );
            }),
            (exports.inverse = function (p) {
              var n,
                x = p.x,
                y = p.y,
                delta_x = x - this.x0,
                delta_y,
                z_re = (y - this.y0) / this.a,
                z_im = delta_x / this.a,
                z_n_re = 1,
                z_n_im = 0,
                z_n_re1,
                z_n_im1,
                th_re = 0,
                th_im = 0;
              for (n = 1; n <= 6; n++)
                (z_n_im1 = z_n_im * z_re + z_n_re * z_im),
                  (z_n_re = z_n_re1 = z_n_re * z_re - z_n_im * z_im),
                  (z_n_im = z_n_im1),
                  (th_re =
                    th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im),
                  (th_im =
                    th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im);
              for (var i = 0; i < this.iterations; i++) {
                var th_n_re = th_re,
                  th_n_im = th_im,
                  th_n_re1,
                  th_n_im1,
                  num_re = z_re,
                  num_im = z_im;
                for (n = 2; n <= 6; n++)
                  (th_n_im1 = th_n_im * th_re + th_n_re * th_im),
                    (th_n_re = th_n_re1 = th_n_re * th_re - th_n_im * th_im),
                    (th_n_im = th_n_im1),
                    (num_re +=
                      (n - 1) *
                      (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im)),
                    (num_im +=
                      (n - 1) *
                      (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im));
                (th_n_re = 1), (th_n_im = 0);
                var den_re = this.B_re[1],
                  den_im = this.B_im[1];
                for (n = 2; n <= 6; n++)
                  (th_n_im1 = th_n_im * th_re + th_n_re * th_im),
                    (th_n_re = th_n_re1 = th_n_re * th_re - th_n_im * th_im),
                    (th_n_im = th_n_im1),
                    (den_re +=
                      n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im)),
                    (den_im +=
                      n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im));
                var den2 = den_re * den_re + den_im * den_im;
                (th_re = (num_re * den_re + num_im * den_im) / den2),
                  (th_im = (num_im * den_re - num_re * den_im) / den2);
              }
              var d_psi = th_re,
                d_lambda = th_im,
                d_psi_n = 1,
                d_phi = 0;
              for (n = 1; n <= 9; n++)
                (d_psi_n *= d_psi), (d_phi += this.D[n] * d_psi_n);
              var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5,
                lon = this.long0 + d_lambda;
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = ["New_Zealand_Map_Grid", "nzmg"]);
        },
        {},
      ],
      120: [
        function (require, module, exports) {
          var tsfnz = require("../common/tsfnz"),
            adjust_lon = require("../common/adjust_lon"),
            phi2z = require("../common/phi2z"),
            HALF_PI = Math.PI / 2,
            FORTPI = Math.PI / 4,
            EPSLN = 1e-10;
          (exports.init = function () {
            (this.no_off = this.no_off || !1),
              (this.no_rot = this.no_rot || !1),
              isNaN(this.k0) && (this.k0 = 1);
            var sinlat = Math.sin(this.lat0),
              coslat = Math.cos(this.lat0),
              con = this.e * sinlat;
            (this.bl = Math.sqrt(
              1 + (this.es / (1 - this.es)) * Math.pow(coslat, 4)
            )),
              (this.al =
                (this.a * this.bl * this.k0 * Math.sqrt(1 - this.es)) /
                (1 - con * con));
            var t0 = tsfnz(this.e, this.lat0, sinlat),
              dl =
                (this.bl / coslat) * Math.sqrt((1 - this.es) / (1 - con * con)),
              fl,
              gl;
            if ((dl * dl < 1 && (dl = 1), isNaN(this.longc))) {
              var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1)),
                t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
              this.lat0 >= 0
                ? (this.el =
                    (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl))
                : (this.el =
                    (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl));
              var hl = Math.pow(t1, this.bl),
                ll = Math.pow(t2, this.bl);
              gl = 0.5 * ((fl = this.el / hl) - 1 / fl);
              var jl =
                  (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl),
                pl = (ll - hl) / (ll + hl),
                dlon12 = adjust_lon(this.long1 - this.long2);
              (this.long0 =
                0.5 * (this.long1 + this.long2) -
                Math.atan((jl * Math.tan(0.5 * this.bl * dlon12)) / pl) /
                  this.bl),
                (this.long0 = adjust_lon(this.long0));
              var dlon10 = adjust_lon(this.long1 - this.long0);
              (this.gamma0 = Math.atan(Math.sin(this.bl * dlon10) / gl)),
                (this.alpha = Math.asin(dl * Math.sin(this.gamma0)));
            } else
              (fl =
                this.lat0 >= 0
                  ? dl + Math.sqrt(dl * dl - 1)
                  : dl - Math.sqrt(dl * dl - 1)),
                (this.el = fl * Math.pow(t0, this.bl)),
                (gl = 0.5 * (fl - 1 / fl)),
                (this.gamma0 = Math.asin(Math.sin(this.alpha) / dl)),
                (this.long0 =
                  this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl);
            this.no_off
              ? (this.uc = 0)
              : this.lat0 >= 0
              ? (this.uc =
                  (this.al / this.bl) *
                  Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha)))
              : (this.uc =
                  ((-1 * this.al) / this.bl) *
                  Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha)));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                dlon = adjust_lon(lon - this.long0),
                us,
                vs,
                con;
              if (Math.abs(Math.abs(lat) - HALF_PI) <= 1e-10)
                (con = lat > 0 ? -1 : 1),
                  (vs =
                    (this.al / this.bl) *
                    Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5))),
                  (us = (-1 * con * HALF_PI * this.al) / this.bl);
              else {
                var t = tsfnz(this.e, lat, Math.sin(lat)),
                  ql = this.el / Math.pow(t, this.bl),
                  sl = 0.5 * (ql - 1 / ql),
                  tl = 0.5 * (ql + 1 / ql),
                  vl = Math.sin(this.bl * dlon),
                  ul =
                    (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) /
                    tl;
                (vs =
                  Math.abs(Math.abs(ul) - 1) <= 1e-10
                    ? Number.POSITIVE_INFINITY
                    : (0.5 * this.al * Math.log((1 - ul) / (1 + ul))) /
                      this.bl),
                  (us =
                    Math.abs(Math.cos(this.bl * dlon)) <= 1e-10
                      ? this.al * this.bl * dlon
                      : (this.al *
                          Math.atan2(
                            sl * Math.cos(this.gamma0) +
                              vl * Math.sin(this.gamma0),
                            Math.cos(this.bl * dlon)
                          )) /
                        this.bl);
              }
              return (
                this.no_rot
                  ? ((p.x = this.x0 + us), (p.y = this.y0 + vs))
                  : ((us -= this.uc),
                    (p.x =
                      this.x0 +
                      vs * Math.cos(this.alpha) +
                      us * Math.sin(this.alpha)),
                    (p.y =
                      this.y0 +
                      us * Math.cos(this.alpha) -
                      vs * Math.sin(this.alpha))),
                p
              );
            }),
            (exports.inverse = function (p) {
              var us, vs;
              this.no_rot
                ? ((vs = p.y - this.y0), (us = p.x - this.x0))
                : ((vs =
                    (p.x - this.x0) * Math.cos(this.alpha) -
                    (p.y - this.y0) * Math.sin(this.alpha)),
                  (us =
                    (p.y - this.y0) * Math.cos(this.alpha) +
                    (p.x - this.x0) * Math.sin(this.alpha)),
                  (us += this.uc));
              var qp = Math.exp((-1 * this.bl * vs) / this.al),
                sp = 0.5 * (qp - 1 / qp),
                tp = 0.5 * (qp + 1 / qp),
                vp = Math.sin((this.bl * us) / this.al),
                up =
                  (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) /
                  tp,
                ts = Math.pow(
                  this.el / Math.sqrt((1 + up) / (1 - up)),
                  1 / this.bl
                );
              return (
                Math.abs(up - 1) < 1e-10
                  ? ((p.x = this.long0), (p.y = HALF_PI))
                  : Math.abs(up + 1) < 1e-10
                  ? ((p.x = this.long0), (p.y = -1 * HALF_PI))
                  : ((p.y = phi2z(this.e, ts)),
                    (p.x = adjust_lon(
                      this.long0 -
                        Math.atan2(
                          sp * Math.cos(this.gamma0) -
                            vp * Math.sin(this.gamma0),
                          Math.cos((this.bl * us) / this.al)
                        ) /
                          this.bl
                    ))),
                p
              );
            }),
            (exports.names = [
              "Hotine_Oblique_Mercator",
              "Hotine Oblique Mercator",
              "Hotine_Oblique_Mercator_Azimuth_Natural_Origin",
              "Hotine_Oblique_Mercator_Azimuth_Center",
              "omerc",
            ]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/phi2z": 79,
          "../common/tsfnz": 87,
        },
      ],
      121: [
        function (require, module, exports) {
          var e0fn = require("../common/e0fn"),
            e1fn = require("../common/e1fn"),
            e2fn = require("../common/e2fn"),
            e3fn = require("../common/e3fn"),
            adjust_lon = require("../common/adjust_lon"),
            adjust_lat = require("../common/adjust_lat"),
            mlfn = require("../common/mlfn"),
            EPSLN = 1e-10,
            gN = require("../common/gN"),
            MAX_ITER = 20;
          (exports.init = function () {
            (this.temp = this.b / this.a),
              (this.es = 1 - Math.pow(this.temp, 2)),
              (this.e = Math.sqrt(this.es)),
              (this.e0 = e0fn(this.es)),
              (this.e1 = e1fn(this.es)),
              (this.e2 = e2fn(this.es)),
              (this.e3 = e3fn(this.es)),
              (this.ml0 =
                this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                x,
                y,
                el,
                dlon = adjust_lon(lon - this.long0);
              if (((el = dlon * Math.sin(lat)), this.sphere))
                Math.abs(lat) <= 1e-10
                  ? ((x = this.a * dlon), (y = -1 * this.a * this.lat0))
                  : ((x = (this.a * Math.sin(el)) / Math.tan(lat)),
                    (y =
                      this.a *
                      (adjust_lat(lat - this.lat0) +
                        (1 - Math.cos(el)) / Math.tan(lat))));
              else if (Math.abs(lat) <= 1e-10)
                (x = this.a * dlon), (y = -1 * this.ml0);
              else {
                var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
                (x = nl * Math.sin(el)),
                  (y =
                    this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) -
                    this.ml0 +
                    nl * (1 - Math.cos(el)));
              }
              return (p.x = x + this.x0), (p.y = y + this.y0), p;
            }),
            (exports.inverse = function (p) {
              var lon, lat, x, y, i, al, bl, phi, dphi;
              if (((x = p.x - this.x0), (y = p.y - this.y0), this.sphere))
                if (Math.abs(y + this.a * this.lat0) <= 1e-10)
                  (lon = adjust_lon(x / this.a + this.long0)), (lat = 0);
                else {
                  var tanphi;
                  for (
                    al = this.lat0 + y / this.a,
                      bl = (x * x) / this.a / this.a + al * al,
                      phi = al,
                      i = 20;
                    i;
                    --i
                  )
                    if (
                      ((phi += dphi =
                        (-1 *
                          (al * (phi * (tanphi = Math.tan(phi)) + 1) -
                            phi -
                            0.5 * (phi * phi + bl) * tanphi)) /
                        ((phi - al) / tanphi - 1)),
                      Math.abs(dphi) <= 1e-10)
                    ) {
                      lat = phi;
                      break;
                    }
                  lon = adjust_lon(
                    this.long0 +
                      Math.asin((x * Math.tan(phi)) / this.a) / Math.sin(lat)
                  );
                }
              else if (Math.abs(y + this.ml0) <= 1e-10)
                (lat = 0), (lon = adjust_lon(this.long0 + x / this.a));
              else {
                var cl, mln, mlnp, ma, con;
                for (
                  al = (this.ml0 + y) / this.a,
                    bl = (x * x) / this.a / this.a + al * al,
                    phi = al,
                    i = 20;
                  i;
                  --i
                )
                  if (
                    ((con = this.e * Math.sin(phi)),
                    (cl = Math.sqrt(1 - con * con) * Math.tan(phi)),
                    (mln =
                      this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi)),
                    (mlnp =
                      this.e0 -
                      2 * this.e1 * Math.cos(2 * phi) +
                      4 * this.e2 * Math.cos(4 * phi) -
                      6 * this.e3 * Math.cos(6 * phi)),
                    (phi -= dphi =
                      (al * (cl * (ma = mln / this.a) + 1) -
                        ma -
                        0.5 * cl * (ma * ma + bl)) /
                      ((this.es *
                        Math.sin(2 * phi) *
                        (ma * ma + bl - 2 * al * ma)) /
                        (4 * cl) +
                        (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) -
                        mlnp)),
                    Math.abs(dphi) <= 1e-10)
                  ) {
                    lat = phi;
                    break;
                  }
                (cl =
                  Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) *
                  Math.tan(lat)),
                  (lon = adjust_lon(
                    this.long0 + Math.asin((x * cl) / this.a) / Math.sin(lat)
                  ));
              }
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = ["Polyconic", "poly"]);
        },
        {
          "../common/adjust_lat": 67,
          "../common/adjust_lon": 68,
          "../common/e0fn": 70,
          "../common/e1fn": 71,
          "../common/e2fn": 72,
          "../common/e3fn": 73,
          "../common/gN": 74,
          "../common/mlfn": 77,
        },
      ],
      122: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            adjust_lat = require("../common/adjust_lat"),
            pj_enfn = require("../common/pj_enfn"),
            MAX_ITER = 20,
            pj_mlfn = require("../common/pj_mlfn"),
            pj_inv_mlfn = require("../common/pj_inv_mlfn"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            asinz = require("../common/asinz");
          (exports.init = function () {
            this.sphere
              ? ((this.n = 1),
                (this.m = 0),
                (this.es = 0),
                (this.C_y = Math.sqrt((this.m + 1) / this.n)),
                (this.C_x = this.C_y / (this.m + 1)))
              : (this.en = pj_enfn(this.es));
          }),
            (exports.forward = function (p) {
              var x,
                y,
                lon = p.x,
                lat = p.y;
              if (((lon = adjust_lon(lon - this.long0)), this.sphere)) {
                if (this.m)
                  for (var k = this.n * Math.sin(lat), i = 20; i; --i) {
                    var V =
                      (this.m * lat + Math.sin(lat) - k) /
                      (this.m + Math.cos(lat));
                    if (((lat -= V), Math.abs(V) < 1e-10)) break;
                  }
                else
                  lat = 1 !== this.n ? Math.asin(this.n * Math.sin(lat)) : lat;
                (x = this.a * this.C_x * lon * (this.m + Math.cos(lat))),
                  (y = this.a * this.C_y * lat);
              } else {
                var s = Math.sin(lat),
                  c = Math.cos(lat);
                (y = this.a * pj_mlfn(lat, s, c, this.en)),
                  (x = (this.a * lon * c) / Math.sqrt(1 - this.es * s * s));
              }
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var lat, temp, lon, s;
              return (
                (p.x -= this.x0),
                (lon = p.x / this.a),
                (p.y -= this.y0),
                (lat = p.y / this.a),
                this.sphere
                  ? ((lat /= this.C_y),
                    (lon /= this.C_x * (this.m + Math.cos(lat))),
                    this.m
                      ? (lat = asinz((this.m * lat + Math.sin(lat)) / this.n))
                      : 1 !== this.n && (lat = asinz(Math.sin(lat) / this.n)),
                    (lon = adjust_lon(lon + this.long0)),
                    (lat = adjust_lat(lat)))
                  : ((lat = pj_inv_mlfn(p.y / this.a, this.es, this.en)),
                    (s = Math.abs(lat)) < HALF_PI
                      ? ((s = Math.sin(lat)),
                        (temp =
                          this.long0 +
                          (p.x * Math.sqrt(1 - this.es * s * s)) /
                            (this.a * Math.cos(lat))),
                        (lon = adjust_lon(temp)))
                      : s - 1e-10 < HALF_PI && (lon = this.long0)),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = ["Sinusoidal", "sinu"]);
        },
        {
          "../common/adjust_lat": 67,
          "../common/adjust_lon": 68,
          "../common/asinz": 69,
          "../common/pj_enfn": 80,
          "../common/pj_inv_mlfn": 81,
          "../common/pj_mlfn": 82,
        },
      ],
      123: [
        function (require, module, exports) {
          (exports.init = function () {
            var phy0 = this.lat0;
            this.lambda0 = this.long0;
            var sinPhy0 = Math.sin(phy0),
              semiMajorAxis = this.a,
              invF,
              flattening = 1 / this.rf,
              e2 = 2 * flattening - Math.pow(flattening, 2),
              e = (this.e = Math.sqrt(e2));
            (this.R =
              (this.k0 * semiMajorAxis * Math.sqrt(1 - e2)) /
              (1 - e2 * Math.pow(sinPhy0, 2))),
              (this.alpha = Math.sqrt(
                1 + (e2 / (1 - e2)) * Math.pow(Math.cos(phy0), 4)
              )),
              (this.b0 = Math.asin(sinPhy0 / this.alpha));
            var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
              k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2)),
              k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
            this.K = k1 - this.alpha * k2 + ((this.alpha * e) / 2) * k3;
          }),
            (exports.forward = function (p) {
              var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2)),
                Sa2 =
                  (this.e / 2) *
                  Math.log(
                    (1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y))
                  ),
                S = -this.alpha * (Sa1 + Sa2) + this.K,
                b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4),
                I = this.alpha * (p.x - this.lambda0),
                rotI = Math.atan(
                  Math.sin(I) /
                    (Math.sin(this.b0) * Math.tan(b) +
                      Math.cos(this.b0) * Math.cos(I))
                ),
                rotB = Math.asin(
                  Math.cos(this.b0) * Math.sin(b) -
                    Math.sin(this.b0) * Math.cos(b) * Math.cos(I)
                );
              return (
                (p.y =
                  (this.R / 2) *
                    Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) +
                  this.y0),
                (p.x = this.R * rotI + this.x0),
                p
              );
            }),
            (exports.inverse = function (p) {
              for (
                var Y = p.x - this.x0,
                  X = p.y - this.y0,
                  rotI = Y / this.R,
                  rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4),
                  b = Math.asin(
                    Math.cos(this.b0) * Math.sin(rotB) +
                      Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI)
                  ),
                  I = Math.atan(
                    Math.sin(rotI) /
                      (Math.cos(this.b0) * Math.cos(rotI) -
                        Math.sin(this.b0) * Math.tan(rotB))
                  ),
                  lambda = this.lambda0 + I / this.alpha,
                  S = 0,
                  phy = b,
                  prevPhy = -1e3,
                  iteration = 0;
                Math.abs(phy - prevPhy) > 1e-7;

              ) {
                if (++iteration > 20) return;
                (S =
                  (1 / this.alpha) *
                    (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) +
                  this.e *
                    Math.log(
                      Math.tan(
                        Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2
                      )
                    )),
                  (prevPhy = phy),
                  (phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2);
              }
              return (p.x = lambda), (p.y = phy), p;
            }),
            (exports.names = ["somerc"]);
        },
        {},
      ],
      124: [
        function (require, module, exports) {
          var HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            sign = require("../common/sign"),
            msfnz = require("../common/msfnz"),
            tsfnz = require("../common/tsfnz"),
            phi2z = require("../common/phi2z"),
            adjust_lon = require("../common/adjust_lon");
          (exports.ssfn_ = function (phit, sinphi, eccen) {
            return (
              (sinphi *= eccen),
              Math.tan(0.5 * (HALF_PI + phit)) *
                Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen)
            );
          }),
            (exports.init = function () {
              (this.coslat0 = Math.cos(this.lat0)),
                (this.sinlat0 = Math.sin(this.lat0)),
                this.sphere
                  ? 1 === this.k0 &&
                    !isNaN(this.lat_ts) &&
                    Math.abs(this.coslat0) <= 1e-10 &&
                    (this.k0 =
                      0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts)))
                  : (Math.abs(this.coslat0) <= 1e-10 &&
                      (this.lat0 > 0 ? (this.con = 1) : (this.con = -1)),
                    (this.cons = Math.sqrt(
                      Math.pow(1 + this.e, 1 + this.e) *
                        Math.pow(1 - this.e, 1 - this.e)
                    )),
                    1 === this.k0 &&
                      !isNaN(this.lat_ts) &&
                      Math.abs(this.coslat0) <= 1e-10 &&
                      (this.k0 =
                        (0.5 *
                          this.cons *
                          msfnz(
                            this.e,
                            Math.sin(this.lat_ts),
                            Math.cos(this.lat_ts)
                          )) /
                        tsfnz(
                          this.e,
                          this.con * this.lat_ts,
                          this.con * Math.sin(this.lat_ts)
                        )),
                    (this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0)),
                    (this.X0 =
                      2 *
                        Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) -
                      HALF_PI),
                    (this.cosX0 = Math.cos(this.X0)),
                    (this.sinX0 = Math.sin(this.X0)));
            }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                sinlat = Math.sin(lat),
                coslat = Math.cos(lat),
                A,
                X,
                sinX,
                cosX,
                ts,
                rh,
                dlon = adjust_lon(lon - this.long0);
              return Math.abs(Math.abs(lon - this.long0) - Math.PI) <= 1e-10 &&
                Math.abs(lat + this.lat0) <= 1e-10
                ? ((p.x = NaN), (p.y = NaN), p)
                : this.sphere
                ? ((A =
                    (2 * this.k0) /
                    (1 +
                      this.sinlat0 * sinlat +
                      this.coslat0 * coslat * Math.cos(dlon))),
                  (p.x = this.a * A * coslat * Math.sin(dlon) + this.x0),
                  (p.y =
                    this.a *
                      A *
                      (this.coslat0 * sinlat -
                        this.sinlat0 * coslat * Math.cos(dlon)) +
                    this.y0),
                  p)
                : ((X =
                    2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI),
                  (cosX = Math.cos(X)),
                  (sinX = Math.sin(X)),
                  Math.abs(this.coslat0) <= 1e-10
                    ? ((ts = tsfnz(this.e, lat * this.con, this.con * sinlat)),
                      (rh = (2 * this.a * this.k0 * ts) / this.cons),
                      (p.x = this.x0 + rh * Math.sin(lon - this.long0)),
                      (p.y =
                        this.y0 - this.con * rh * Math.cos(lon - this.long0)),
                      p)
                    : (Math.abs(this.sinlat0) < 1e-10
                        ? ((A =
                            (2 * this.a * this.k0) /
                            (1 + cosX * Math.cos(dlon))),
                          (p.y = A * sinX))
                        : ((A =
                            (2 * this.a * this.k0 * this.ms1) /
                            (this.cosX0 *
                              (1 +
                                this.sinX0 * sinX +
                                this.cosX0 * cosX * Math.cos(dlon)))),
                          (p.y =
                            A *
                              (this.cosX0 * sinX -
                                this.sinX0 * cosX * Math.cos(dlon)) +
                            this.y0)),
                      (p.x = A * cosX * Math.sin(dlon) + this.x0),
                      p));
            }),
            (exports.inverse = function (p) {
              var lon, lat, ts, ce, Chi;
              (p.x -= this.x0), (p.y -= this.y0);
              var rh = Math.sqrt(p.x * p.x + p.y * p.y);
              if (this.sphere) {
                var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
                return (
                  (lon = this.long0),
                  (lat = this.lat0),
                  rh <= 1e-10
                    ? ((p.x = lon), (p.y = lat), p)
                    : ((lat = Math.asin(
                        Math.cos(c) * this.sinlat0 +
                          (p.y * Math.sin(c) * this.coslat0) / rh
                      )),
                      (lon =
                        Math.abs(this.coslat0) < 1e-10
                          ? this.lat0 > 0
                            ? adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y))
                            : adjust_lon(this.long0 + Math.atan2(p.x, p.y))
                          : adjust_lon(
                              this.long0 +
                                Math.atan2(
                                  p.x * Math.sin(c),
                                  rh * this.coslat0 * Math.cos(c) -
                                    p.y * this.sinlat0 * Math.sin(c)
                                )
                            )),
                      (p.x = lon),
                      (p.y = lat),
                      p)
                );
              }
              if (Math.abs(this.coslat0) <= 1e-10) {
                if (rh <= 1e-10)
                  return (
                    (lat = this.lat0),
                    (lon = this.long0),
                    (p.x = lon),
                    (p.y = lat),
                    p
                  );
                (p.x *= this.con),
                  (p.y *= this.con),
                  (ts = (rh * this.cons) / (2 * this.a * this.k0)),
                  (lat = this.con * phi2z(this.e, ts)),
                  (lon =
                    this.con *
                    adjust_lon(
                      this.con * this.long0 + Math.atan2(p.x, -1 * p.y)
                    ));
              } else
                (ce =
                  2 *
                  Math.atan(
                    (rh * this.cosX0) / (2 * this.a * this.k0 * this.ms1)
                  )),
                  (lon = this.long0),
                  rh <= 1e-10
                    ? (Chi = this.X0)
                    : ((Chi = Math.asin(
                        Math.cos(ce) * this.sinX0 +
                          (p.y * Math.sin(ce) * this.cosX0) / rh
                      )),
                      (lon = adjust_lon(
                        this.long0 +
                          Math.atan2(
                            p.x * Math.sin(ce),
                            rh * this.cosX0 * Math.cos(ce) -
                              p.y * this.sinX0 * Math.sin(ce)
                          )
                      ))),
                  (lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi))));
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = [
              "stere",
              "Stereographic_South_Pole",
              "Polar Stereographic (variant B)",
            ]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/msfnz": 78,
          "../common/phi2z": 79,
          "../common/sign": 84,
          "../common/tsfnz": 87,
        },
      ],
      125: [
        function (require, module, exports) {
          var gauss = require("./gauss"),
            adjust_lon = require("../common/adjust_lon");
          (exports.init = function () {
            gauss.init.apply(this),
              this.rc &&
                ((this.sinc0 = Math.sin(this.phic0)),
                (this.cosc0 = Math.cos(this.phic0)),
                (this.R2 = 2 * this.rc),
                this.title ||
                  (this.title = "Oblique Stereographic Alternative"));
          }),
            (exports.forward = function (p) {
              var sinc, cosc, cosl, k;
              return (
                (p.x = adjust_lon(p.x - this.long0)),
                gauss.forward.apply(this, [p]),
                (sinc = Math.sin(p.y)),
                (cosc = Math.cos(p.y)),
                (cosl = Math.cos(p.x)),
                (k =
                  (this.k0 * this.R2) /
                  (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl)),
                (p.x = k * cosc * Math.sin(p.x)),
                (p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl)),
                (p.x = this.a * p.x + this.x0),
                (p.y = this.a * p.y + this.y0),
                p
              );
            }),
            (exports.inverse = function (p) {
              var sinc, cosc, lon, lat, rho;
              if (
                ((p.x = (p.x - this.x0) / this.a),
                (p.y = (p.y - this.y0) / this.a),
                (p.x /= this.k0),
                (p.y /= this.k0),
                (rho = Math.sqrt(p.x * p.x + p.y * p.y)))
              ) {
                var c = 2 * Math.atan2(rho, this.R2);
                (sinc = Math.sin(c)),
                  (cosc = Math.cos(c)),
                  (lat = Math.asin(
                    cosc * this.sinc0 + (p.y * sinc * this.cosc0) / rho
                  )),
                  (lon = Math.atan2(
                    p.x * sinc,
                    rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc
                  ));
              } else (lat = this.phic0), (lon = 0);
              return (
                (p.x = lon),
                (p.y = lat),
                gauss.inverse.apply(this, [p]),
                (p.x = adjust_lon(p.x + this.long0)),
                p
              );
            }),
            (exports.names = [
              "Stereographic_North_Pole",
              "Oblique_Stereographic",
              "Polar_Stereographic",
              "sterea",
              "Oblique Stereographic Alternative",
            ]);
        },
        { "../common/adjust_lon": 68, "./gauss": 110 },
      ],
      126: [
        function (require, module, exports) {
          var e0fn = require("../common/e0fn"),
            e1fn = require("../common/e1fn"),
            e2fn = require("../common/e2fn"),
            e3fn = require("../common/e3fn"),
            mlfn = require("../common/mlfn"),
            adjust_lon = require("../common/adjust_lon"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            sign = require("../common/sign"),
            asinz = require("../common/asinz");
          (exports.init = function () {
            (this.e0 = e0fn(this.es)),
              (this.e1 = e1fn(this.es)),
              (this.e2 = e2fn(this.es)),
              (this.e3 = e3fn(this.es)),
              (this.ml0 =
                this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0));
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                delta_lon = adjust_lon(lon - this.long0),
                con,
                x,
                y,
                sin_phi = Math.sin(lat),
                cos_phi = Math.cos(lat);
              if (this.sphere) {
                var b = cos_phi * Math.sin(delta_lon);
                if (Math.abs(Math.abs(b) - 1) < 1e-10) return 93;
                (x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b))),
                  (con = Math.acos(
                    (cos_phi * Math.cos(delta_lon)) / Math.sqrt(1 - b * b)
                  )),
                  lat < 0 && (con = -con),
                  (y = this.a * this.k0 * (con - this.lat0));
              } else {
                var al = cos_phi * delta_lon,
                  als = Math.pow(al, 2),
                  c = this.ep2 * Math.pow(cos_phi, 2),
                  tq = Math.tan(lat),
                  t = Math.pow(tq, 2);
                con = 1 - this.es * Math.pow(sin_phi, 2);
                var n = this.a / Math.sqrt(con),
                  ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);
                (x =
                  this.k0 *
                    n *
                    al *
                    (1 +
                      (als / 6) *
                        (1 -
                          t +
                          c +
                          (als / 20) *
                            (5 -
                              18 * t +
                              Math.pow(t, 2) +
                              72 * c -
                              58 * this.ep2))) +
                  this.x0),
                  (y =
                    this.k0 *
                      (ml -
                        this.ml0 +
                        n *
                          tq *
                          (als *
                            (0.5 +
                              (als / 24) *
                                (5 -
                                  t +
                                  9 * c +
                                  4 * Math.pow(c, 2) +
                                  (als / 30) *
                                    (61 -
                                      58 * t +
                                      Math.pow(t, 2) +
                                      600 * c -
                                      330 * this.ep2))))) +
                    this.y0);
              }
              return (p.x = x), (p.y = y), p;
            }),
            (exports.inverse = function (p) {
              var con,
                phi,
                delta_phi,
                i,
                max_iter = 6,
                lat,
                lon;
              if (this.sphere) {
                var f = Math.exp(p.x / (this.a * this.k0)),
                  g = 0.5 * (f - 1 / f),
                  temp = this.lat0 + p.y / (this.a * this.k0),
                  h = Math.cos(temp);
                (con = Math.sqrt((1 - h * h) / (1 + g * g))),
                  (lat = asinz(con)),
                  temp < 0 && (lat = -lat),
                  (lon =
                    0 === g && 0 === h
                      ? this.long0
                      : adjust_lon(Math.atan2(g, h) + this.long0));
              } else {
                var x = p.x - this.x0,
                  y = p.y - this.y0;
                for (
                  phi = con = (this.ml0 + y / this.k0) / this.a, i = 0;
                  (phi += delta_phi =
                    (con +
                      this.e1 * Math.sin(2 * phi) -
                      this.e2 * Math.sin(4 * phi) +
                      this.e3 * Math.sin(6 * phi)) /
                      this.e0 -
                    phi),
                    !(Math.abs(delta_phi) <= 1e-10);
                  i++
                )
                  if (i >= 6) return 95;
                if (Math.abs(phi) < HALF_PI) {
                  var sin_phi = Math.sin(phi),
                    cos_phi = Math.cos(phi),
                    tan_phi = Math.tan(phi),
                    c = this.ep2 * Math.pow(cos_phi, 2),
                    cs = Math.pow(c, 2),
                    t = Math.pow(tan_phi, 2),
                    ts = Math.pow(t, 2);
                  con = 1 - this.es * Math.pow(sin_phi, 2);
                  var n = this.a / Math.sqrt(con),
                    r = (n * (1 - this.es)) / con,
                    d = x / (n * this.k0),
                    ds = Math.pow(d, 2);
                  (lat =
                    phi -
                    ((n * tan_phi * ds) / r) *
                      (0.5 -
                        (ds / 24) *
                          (5 +
                            3 * t +
                            10 * c -
                            4 * cs -
                            9 * this.ep2 -
                            (ds / 30) *
                              (61 +
                                90 * t +
                                298 * c +
                                45 * ts -
                                252 * this.ep2 -
                                3 * cs)))),
                    (lon = adjust_lon(
                      this.long0 +
                        (d *
                          (1 -
                            (ds / 6) *
                              (1 +
                                2 * t +
                                c -
                                (ds / 20) *
                                  (5 -
                                    2 * c +
                                    28 * t -
                                    3 * cs +
                                    8 * this.ep2 +
                                    24 * ts)))) /
                          cos_phi
                    ));
                } else (lat = HALF_PI * sign(y)), (lon = this.long0);
              }
              return (p.x = lon), (p.y = lat), p;
            }),
            (exports.names = [
              "Transverse_Mercator",
              "Transverse Mercator",
              "tmerc",
            ]);
        },
        {
          "../common/adjust_lon": 68,
          "../common/asinz": 69,
          "../common/e0fn": 70,
          "../common/e1fn": 71,
          "../common/e2fn": 72,
          "../common/e3fn": 73,
          "../common/mlfn": 77,
          "../common/sign": 84,
        },
      ],
      127: [
        function (require, module, exports) {
          var D2R = 0.017453292519943295,
            tmerc = require("./tmerc");
          (exports.dependsOn = "tmerc"),
            (exports.init = function () {
              this.zone &&
                ((this.lat0 = 0),
                (this.long0 = (6 * Math.abs(this.zone) - 183) * D2R),
                (this.x0 = 5e5),
                (this.y0 = this.utmSouth ? 1e7 : 0),
                (this.k0 = 0.9996),
                tmerc.init.apply(this),
                (this.forward = tmerc.forward),
                (this.inverse = tmerc.inverse));
            }),
            (exports.names = ["Universal Transverse Mercator System", "utm"]);
        },
        { "./tmerc": 126 },
      ],
      128: [
        function (require, module, exports) {
          var adjust_lon = require("../common/adjust_lon"),
            HALF_PI = Math.PI / 2,
            EPSLN = 1e-10,
            asinz = require("../common/asinz");
          (exports.init = function () {
            this.R = this.a;
          }),
            (exports.forward = function (p) {
              var lon = p.x,
                lat = p.y,
                dlon = adjust_lon(lon - this.long0),
                x,
                y;
              Math.abs(lat) <= 1e-10 &&
                ((x = this.x0 + this.R * dlon), (y = this.y0));
              var theta = asinz(2 * Math.abs(lat / Math.PI));
              (Math.abs(dlon) <= 1e-10 ||
                Math.abs(Math.abs(lat) - HALF_PI) <= 1e-10) &&
                ((x = this.x0),
                (y =
                  lat >= 0
                    ? this.y0 + Math.PI * this.R * Math.tan(0.5 * theta)
                    : this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta)));
              var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI),
                asq = al * al,
                sinth = Math.sin(theta),
                costh = Math.cos(theta),
                g = costh / (sinth + costh - 1),
                gsq = g * g,
                m = g * (2 / sinth - 1),
                msq = m * m,
                con =
                  (Math.PI *
                    this.R *
                    (al * (g - msq) +
                      Math.sqrt(
                        asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq)
                      ))) /
                  (msq + asq);
              dlon < 0 && (con = -con), (x = this.x0 + con);
              var q = asq + g;
              return (
                (con =
                  (Math.PI *
                    this.R *
                    (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q))) /
                  (msq + asq)),
                (y = lat >= 0 ? this.y0 + con : this.y0 - con),
                (p.x = x),
                (p.y = y),
                p
              );
            }),
            (exports.inverse = function (p) {
              var lon, lat, xx, yy, xys, c1, c2, c3, a1, m1, con, th1, d;
              return (
                (p.x -= this.x0),
                (p.y -= this.y0),
                (con = Math.PI * this.R),
                (xys = (xx = p.x / con) * xx + (yy = p.y / con) * yy),
                (con =
                  (3 *
                    (d =
                      (yy * yy) /
                        (c3 =
                          -2 * (c1 = -Math.abs(yy) * (1 + xys)) +
                          1 +
                          2 * yy * yy +
                          xys * xys) +
                      ((2 * (c2 = c1 - 2 * yy * yy + xx * xx) * c2 * c2) /
                        c3 /
                        c3 /
                        c3 -
                        (9 * c1 * c2) / c3 / c3) /
                        27)) /
                  (a1 = (c1 - (c2 * c2) / 3 / c3) / c3) /
                  (m1 = 2 * Math.sqrt(-a1 / 3))),
                Math.abs(con) > 1 && (con = con >= 0 ? 1 : -1),
                (th1 = Math.acos(con) / 3),
                (lat =
                  p.y >= 0
                    ? (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) *
                      Math.PI
                    : -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) *
                      Math.PI),
                (lon =
                  Math.abs(xx) < 1e-10
                    ? this.long0
                    : adjust_lon(
                        this.long0 +
                          (Math.PI *
                            (xys -
                              1 +
                              Math.sqrt(
                                1 + 2 * (xx * xx - yy * yy) + xys * xys
                              ))) /
                            2 /
                            xx
                      )),
                (p.x = lon),
                (p.y = lat),
                p
              );
            }),
            (exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]);
        },
        { "../common/adjust_lon": 68, "../common/asinz": 69 },
      ],
      129: [
        function (require, module, exports) {
          var D2R = 0.017453292519943295,
            R2D = 57.29577951308232,
            PJD_3PARAM = 1,
            PJD_7PARAM = 2,
            datum_transform = require("./datum_transform"),
            adjust_axis = require("./adjust_axis"),
            proj = require("./Proj"),
            toPoint = require("./common/toPoint");
          module.exports = function transform(source, dest, point) {
            var wgs84;
            function checkNotWGS(source, dest) {
              return (
                (source.datum.datum_type === PJD_3PARAM ||
                  source.datum.datum_type === PJD_7PARAM) &&
                "WGS84" !== dest.datumCode
              );
            }
            return (
              Array.isArray(point) && (point = toPoint(point)),
              source.datum &&
                dest.datum &&
                (checkNotWGS(source, dest) || checkNotWGS(dest, source)) &&
                (transform(source, (wgs84 = new proj("WGS84")), point),
                (source = wgs84)),
              "enu" !== source.axis && adjust_axis(source, !1, point),
              "longlat" === source.projName
                ? ((point.x *= D2R), (point.y *= D2R))
                : (source.to_meter &&
                    ((point.x *= source.to_meter),
                    (point.y *= source.to_meter)),
                  source.inverse(point)),
              source.from_greenwich && (point.x += source.from_greenwich),
              (point = datum_transform(source.datum, dest.datum, point)),
              dest.from_greenwich && (point.x -= dest.from_greenwich),
              "longlat" === dest.projName
                ? ((point.x *= R2D), (point.y *= R2D))
                : (dest.forward(point),
                  dest.to_meter &&
                    ((point.x /= dest.to_meter), (point.y /= dest.to_meter))),
              "enu" !== dest.axis && adjust_axis(dest, !0, point),
              point
            );
          };
        },
        {
          "./Proj": 65,
          "./adjust_axis": 66,
          "./common/toPoint": 86,
          "./datum_transform": 94,
        },
      ],
      130: [
        function (require, module, exports) {
          var D2R = 0.017453292519943295,
            extend = require("./extend");
          function mapit(obj, key, v) {
            obj[key] = v
              .map(function (aa) {
                var o = {};
                return sExpr(aa, o), o;
              })
              .reduce(function (a, b) {
                return extend(a, b);
              }, {});
          }
          function sExpr(v, obj) {
            var key;
            Array.isArray(v)
              ? ("PARAMETER" === (key = v.shift()) && (key = v.shift()),
                1 === v.length
                  ? Array.isArray(v[0])
                    ? ((obj[key] = {}), sExpr(v[0], obj[key]))
                    : (obj[key] = v[0])
                  : v.length
                  ? "TOWGS84" === key
                    ? (obj[key] = v)
                    : ((obj[key] = {}),
                      ["UNIT", "PRIMEM", "VERT_DATUM"].indexOf(key) > -1
                        ? ((obj[key] = {
                            name: v[0].toLowerCase(),
                            convert: v[1],
                          }),
                          3 === v.length && (obj[key].auth = v[2]))
                        : "SPHEROID" === key
                        ? ((obj[key] = { name: v[0], a: v[1], rf: v[2] }),
                          4 === v.length && (obj[key].auth = v[3]))
                        : [
                            "GEOGCS",
                            "GEOCCS",
                            "DATUM",
                            "VERT_CS",
                            "COMPD_CS",
                            "LOCAL_CS",
                            "FITTED_CS",
                            "LOCAL_DATUM",
                          ].indexOf(key) > -1
                        ? ((v[0] = ["name", v[0]]), mapit(obj, key, v))
                        : v.every(function (aa) {
                            return Array.isArray(aa);
                          })
                        ? mapit(obj, key, v)
                        : sExpr(v, obj[key]))
                  : (obj[key] = !0))
              : (obj[v] = !0);
          }
          function rename(obj, params) {
            var outName = params[0],
              inName = params[1];
            !(outName in obj) &&
              inName in obj &&
              ((obj[outName] = obj[inName]),
              3 === params.length && (obj[outName] = params[2](obj[outName])));
          }
          function d2r(input) {
            return input * D2R;
          }
          function cleanWKT(wkt) {
            function toMeter(input) {
              var ratio = wkt.to_meter || 1;
              return parseFloat(input, 10) * ratio;
            }
            var renamer, list;
            "GEOGCS" === wkt.type
              ? (wkt.projName = "longlat")
              : "LOCAL_CS" === wkt.type
              ? ((wkt.projName = "identity"), (wkt.local = !0))
              : "object" == typeof wkt.PROJECTION
              ? (wkt.projName = Object.keys(wkt.PROJECTION)[0])
              : (wkt.projName = wkt.PROJECTION),
              wkt.UNIT &&
                ((wkt.units = wkt.UNIT.name.toLowerCase()),
                "metre" === wkt.units && (wkt.units = "meter"),
                wkt.UNIT.convert &&
                  (wkt.to_meter = parseFloat(wkt.UNIT.convert, 10))),
              wkt.GEOGCS &&
                (wkt.GEOGCS.DATUM
                  ? (wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase())
                  : (wkt.datumCode = wkt.GEOGCS.name.toLowerCase()),
                "d_" === wkt.datumCode.slice(0, 2) &&
                  (wkt.datumCode = wkt.datumCode.slice(2)),
                ("new_zealand_geodetic_datum_1949" !== wkt.datumCode &&
                  "new_zealand_1949" !== wkt.datumCode) ||
                  (wkt.datumCode = "nzgd49"),
                "wgs_1984" === wkt.datumCode &&
                  ("Mercator_Auxiliary_Sphere" === wkt.PROJECTION &&
                    (wkt.sphere = !0),
                  (wkt.datumCode = "wgs84")),
                "_ferro" === wkt.datumCode.slice(-6) &&
                  (wkt.datumCode = wkt.datumCode.slice(0, -6)),
                "_jakarta" === wkt.datumCode.slice(-8) &&
                  (wkt.datumCode = wkt.datumCode.slice(0, -8)),
                ~wkt.datumCode.indexOf("belge") && (wkt.datumCode = "rnb72"),
                wkt.GEOGCS.DATUM &&
                  wkt.GEOGCS.DATUM.SPHEROID &&
                  ((wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name
                    .replace("_19", "")
                    .replace(/[Cc]larke\_18/, "clrk")),
                  "international" === wkt.ellps.toLowerCase().slice(0, 13) &&
                    (wkt.ellps = "intl"),
                  (wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a),
                  (wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10))),
                ~wkt.datumCode.indexOf("osgb_1936") &&
                  (wkt.datumCode = "osgb36")),
              wkt.b && !isFinite(wkt.b) && (wkt.b = wkt.a),
              [
                ["standard_parallel_1", "Standard_Parallel_1"],
                ["standard_parallel_2", "Standard_Parallel_2"],
                ["false_easting", "False_Easting"],
                ["false_northing", "False_Northing"],
                ["central_meridian", "Central_Meridian"],
                ["latitude_of_origin", "Latitude_Of_Origin"],
                ["latitude_of_origin", "Central_Parallel"],
                ["scale_factor", "Scale_Factor"],
                ["k0", "scale_factor"],
                ["latitude_of_center", "Latitude_of_center"],
                ["lat0", "latitude_of_center", d2r],
                ["longitude_of_center", "Longitude_Of_Center"],
                ["longc", "longitude_of_center", d2r],
                ["x0", "false_easting", toMeter],
                ["y0", "false_northing", toMeter],
                ["long0", "central_meridian", d2r],
                ["lat0", "latitude_of_origin", d2r],
                ["lat0", "standard_parallel_1", d2r],
                ["lat1", "standard_parallel_1", d2r],
                ["lat2", "standard_parallel_2", d2r],
                ["alpha", "azimuth", d2r],
                ["srsCode", "name"],
              ].forEach(function (a) {
                return rename(wkt, a);
              }),
              wkt.long0 ||
                !wkt.longc ||
                ("Albers_Conic_Equal_Area" !== wkt.projName &&
                  "Lambert_Azimuthal_Equal_Area" !== wkt.projName) ||
                (wkt.long0 = wkt.longc),
              wkt.lat_ts ||
                !wkt.lat1 ||
                ("Stereographic_South_Pole" !== wkt.projName &&
                  "Polar Stereographic (variant B)" !== wkt.projName) ||
                ((wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90)),
                (wkt.lat_ts = wkt.lat1));
          }
          module.exports = function (wkt, self) {
            var lisp = JSON.parse(
                ("," + wkt)
                  .replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",')
                  .slice(1)
                  .replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]')
                  .replace(/,\["VERTCS".+/, "")
              ),
              type = lisp.shift(),
              name = lisp.shift();
            lisp.unshift(["name", name]),
              lisp.unshift(["type", type]),
              lisp.unshift("output");
            var obj = {};
            return (
              sExpr(lisp, obj), cleanWKT(obj.output), extend(self, obj.output)
            );
          };
        },
        { "./extend": 97 },
      ],
      131: [
        function (require, module, exports) {
          var NUM_100K_SETS = 6,
            SET_ORIGIN_COLUMN_LETTERS = "AJSAJS",
            SET_ORIGIN_ROW_LETTERS = "AFAFAF",
            A = 65,
            I = 73,
            O = 79,
            V = 86,
            Z = 90;
          function degToRad(deg) {
            return deg * (Math.PI / 180);
          }
          function radToDeg(rad) {
            return (rad / Math.PI) * 180;
          }
          function LLtoUTM(ll) {
            var Lat = ll.lat,
              Long = ll.lon,
              a = 6378137,
              eccSquared = 0.00669438,
              k0 = 0.9996,
              LongOrigin,
              eccPrimeSquared,
              N,
              T,
              C,
              A,
              M,
              LatRad = degToRad(Lat),
              LongRad = degToRad(Long),
              LongOriginRad,
              ZoneNumber;
            (ZoneNumber = Math.floor((Long + 180) / 6) + 1),
              180 === Long && (ZoneNumber = 60),
              Lat >= 56 &&
                Lat < 64 &&
                Long >= 3 &&
                Long < 12 &&
                (ZoneNumber = 32),
              Lat >= 72 &&
                Lat < 84 &&
                (Long >= 0 && Long < 9
                  ? (ZoneNumber = 31)
                  : Long >= 9 && Long < 21
                  ? (ZoneNumber = 33)
                  : Long >= 21 && Long < 33
                  ? (ZoneNumber = 35)
                  : Long >= 33 && Long < 42 && (ZoneNumber = 37)),
              (LongOriginRad = degToRad(
                (LongOrigin = 6 * (ZoneNumber - 1) - 180 + 3)
              )),
              (eccPrimeSquared = 0.006739496752268451),
              (N =
                a /
                Math.sqrt(
                  1 - 0.00669438 * Math.sin(LatRad) * Math.sin(LatRad)
                )),
              (T = Math.tan(LatRad) * Math.tan(LatRad)),
              (C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad));
            var UTMEasting =
                k0 *
                  N *
                  ((A = Math.cos(LatRad) * (LongRad - LongOriginRad)) +
                    ((1 - T + C) * A * A * A) / 6 +
                    ((5 - 18 * T + T * T + 72 * C - 0.39089081163157013) *
                      A *
                      A *
                      A *
                      A *
                      A) /
                      120) +
                5e5,
              UTMNorthing =
                k0 *
                ((M =
                  a *
                  (0.9983242984503243 * LatRad -
                    0.002514607064228144 * Math.sin(2 * LatRad) +
                    2639046602129982e-21 * Math.sin(4 * LatRad) -
                    3.418046101696858e-9 * Math.sin(6 * LatRad))) +
                  N *
                    Math.tan(LatRad) *
                    ((A * A) / 2 +
                      ((5 - T + 9 * C + 4 * C * C) * A * A * A * A) / 24 +
                      ((61 - 58 * T + T * T + 600 * C - 2.2240339282485886) *
                        A *
                        A *
                        A *
                        A *
                        A *
                        A) /
                        720));
            return (
              Lat < 0 && (UTMNorthing += 1e7),
              {
                northing: Math.round(UTMNorthing),
                easting: Math.round(UTMEasting),
                zoneNumber: ZoneNumber,
                zoneLetter: getLetterDesignator(Lat),
              }
            );
          }
          function UTMtoLL(utm) {
            var UTMNorthing = utm.northing,
              UTMEasting = utm.easting,
              zoneLetter = utm.zoneLetter,
              zoneNumber = utm.zoneNumber;
            if (zoneNumber < 0 || zoneNumber > 60) return null;
            var k0 = 0.9996,
              a = 6378137,
              eccSquared = 0.00669438,
              eccPrimeSquared,
              e1 = (1 - Math.sqrt(0.99330562)) / (1 + Math.sqrt(0.99330562)),
              N1,
              T1,
              C1,
              R1,
              D,
              M,
              LongOrigin,
              mu,
              phi1Rad,
              x = UTMEasting - 5e5,
              y = UTMNorthing;
            zoneLetter < "N" && (y -= 1e7),
              (LongOrigin = 6 * (zoneNumber - 1) - 180 + 3),
              (eccPrimeSquared = 0.006739496752268451),
              (phi1Rad =
                (mu = (M = y / k0) / 6367449.145945056) +
                ((3 * e1) / 2 - (27 * e1 * e1 * e1) / 32) * Math.sin(2 * mu) +
                ((21 * e1 * e1) / 16 - (55 * e1 * e1 * e1 * e1) / 32) *
                  Math.sin(4 * mu) +
                ((151 * e1 * e1 * e1) / 96) * Math.sin(6 * mu)),
              (N1 =
                a /
                Math.sqrt(
                  1 - 0.00669438 * Math.sin(phi1Rad) * Math.sin(phi1Rad)
                )),
              (T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad)),
              (C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad)),
              (R1 =
                (0.99330562 * a) /
                Math.pow(
                  1 - 0.00669438 * Math.sin(phi1Rad) * Math.sin(phi1Rad),
                  1.5
                )),
              (D = x / (N1 * k0));
            var lat =
              phi1Rad -
              ((N1 * Math.tan(phi1Rad)) / R1) *
                ((D * D) / 2 -
                  ((5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) *
                    D *
                    D *
                    D *
                    D) /
                    24 +
                  ((61 +
                    90 * T1 +
                    298 * C1 +
                    45 * T1 * T1 -
                    1.6983531815716497 -
                    3 * C1 * C1) *
                    D *
                    D *
                    D *
                    D *
                    D *
                    D) /
                    720);
            lat = radToDeg(lat);
            var lon =
                (D -
                  ((1 + 2 * T1 + C1) * D * D * D) / 6 +
                  ((5 -
                    2 * C1 +
                    28 * T1 -
                    3 * C1 * C1 +
                    8 * eccPrimeSquared +
                    24 * T1 * T1) *
                    D *
                    D *
                    D *
                    D *
                    D) /
                    120) /
                Math.cos(phi1Rad),
              result;
            if (((lon = LongOrigin + radToDeg(lon)), utm.accuracy)) {
              var topRight = UTMtoLL({
                northing: utm.northing + utm.accuracy,
                easting: utm.easting + utm.accuracy,
                zoneLetter: utm.zoneLetter,
                zoneNumber: utm.zoneNumber,
              });
              result = {
                top: topRight.lat,
                right: topRight.lon,
                bottom: lat,
                left: lon,
              };
            } else result = { lat: lat, lon: lon };
            return result;
          }
          function getLetterDesignator(lat) {
            var LetterDesignator = "Z";
            return (
              84 >= lat && lat >= 72
                ? (LetterDesignator = "X")
                : 72 > lat && lat >= 64
                ? (LetterDesignator = "W")
                : 64 > lat && lat >= 56
                ? (LetterDesignator = "V")
                : 56 > lat && lat >= 48
                ? (LetterDesignator = "U")
                : 48 > lat && lat >= 40
                ? (LetterDesignator = "T")
                : 40 > lat && lat >= 32
                ? (LetterDesignator = "S")
                : 32 > lat && lat >= 24
                ? (LetterDesignator = "R")
                : 24 > lat && lat >= 16
                ? (LetterDesignator = "Q")
                : 16 > lat && lat >= 8
                ? (LetterDesignator = "P")
                : 8 > lat && lat >= 0
                ? (LetterDesignator = "N")
                : 0 > lat && lat >= -8
                ? (LetterDesignator = "M")
                : -8 > lat && lat >= -16
                ? (LetterDesignator = "L")
                : -16 > lat && lat >= -24
                ? (LetterDesignator = "K")
                : -24 > lat && lat >= -32
                ? (LetterDesignator = "J")
                : -32 > lat && lat >= -40
                ? (LetterDesignator = "H")
                : -40 > lat && lat >= -48
                ? (LetterDesignator = "G")
                : -48 > lat && lat >= -56
                ? (LetterDesignator = "F")
                : -56 > lat && lat >= -64
                ? (LetterDesignator = "E")
                : -64 > lat && lat >= -72
                ? (LetterDesignator = "D")
                : -72 > lat && lat >= -80 && (LetterDesignator = "C"),
              LetterDesignator
            );
          }
          function encode(utm, accuracy) {
            var seasting = "00000" + utm.easting,
              snorthing = "00000" + utm.northing;
            return (
              utm.zoneNumber +
              utm.zoneLetter +
              get100kID(utm.easting, utm.northing, utm.zoneNumber) +
              seasting.substr(seasting.length - 5, accuracy) +
              snorthing.substr(snorthing.length - 5, accuracy)
            );
          }
          function get100kID(easting, northing, zoneNumber) {
            var setParm = get100kSetForZone(zoneNumber),
              setColumn,
              setRow;
            return getLetter100kID(
              Math.floor(easting / 1e5),
              Math.floor(northing / 1e5) % 20,
              setParm
            );
          }
          function get100kSetForZone(i) {
            var setParm = i % NUM_100K_SETS;
            return 0 === setParm && (setParm = NUM_100K_SETS), setParm;
          }
          function getLetter100kID(column, row, parm) {
            var index = parm - 1,
              colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index),
              rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index),
              colInt = colOrigin + column - 1,
              rowInt = rowOrigin + row,
              rollover = !1,
              twoLetter;
            return (
              colInt > Z && ((colInt = colInt - Z + A - 1), (rollover = !0)),
              (colInt === I ||
                (colOrigin < I && colInt > I) ||
                ((colInt > I || colOrigin < I) && rollover)) &&
                colInt++,
              (colInt === O ||
                (colOrigin < O && colInt > O) ||
                ((colInt > O || colOrigin < O) && rollover)) &&
                ++colInt === I &&
                colInt++,
              colInt > Z && (colInt = colInt - Z + A - 1),
              rowInt > V
                ? ((rowInt = rowInt - V + A - 1), (rollover = !0))
                : (rollover = !1),
              (rowInt === I ||
                (rowOrigin < I && rowInt > I) ||
                ((rowInt > I || rowOrigin < I) && rollover)) &&
                rowInt++,
              (rowInt === O ||
                (rowOrigin < O && rowInt > O) ||
                ((rowInt > O || rowOrigin < O) && rollover)) &&
                ++rowInt === I &&
                rowInt++,
              rowInt > V && (rowInt = rowInt - V + A - 1),
              String.fromCharCode(colInt) + String.fromCharCode(rowInt)
            );
          }
          function decode(mgrsString) {
            if (mgrsString && 0 === mgrsString.length)
              throw "MGRSPoint coverting from nothing";
            for (
              var length = mgrsString.length,
                hunK = null,
                sb = "",
                testChar,
                i = 0;
              !/[A-Z]/.test((testChar = mgrsString.charAt(i)));

            ) {
              if (i >= 2) throw "MGRSPoint bad conversion from: " + mgrsString;
              (sb += testChar), i++;
            }
            var zoneNumber = parseInt(sb, 10);
            if (0 === i || i + 3 > length)
              throw "MGRSPoint bad conversion from: " + mgrsString;
            var zoneLetter = mgrsString.charAt(i++);
            if (
              zoneLetter <= "A" ||
              "B" === zoneLetter ||
              "Y" === zoneLetter ||
              zoneLetter >= "Z" ||
              "I" === zoneLetter ||
              "O" === zoneLetter
            )
              throw (
                "MGRSPoint zone letter " +
                zoneLetter +
                " not handled: " +
                mgrsString
              );
            hunK = mgrsString.substring(i, (i += 2));
            for (
              var set = get100kSetForZone(zoneNumber),
                east100k = getEastingFromChar(hunK.charAt(0), set),
                north100k = getNorthingFromChar(hunK.charAt(1), set);
              north100k < getMinNorthing(zoneLetter);

            )
              north100k += 2e6;
            var remainder = length - i;
            if (remainder % 2 != 0)
              throw (
                "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" +
                mgrsString
              );
            var sep = remainder / 2,
              sepEasting = 0,
              sepNorthing = 0,
              accuracyBonus,
              sepEastingString,
              sepNorthingString,
              easting,
              northing;
            return (
              sep > 0 &&
                ((accuracyBonus = 1e5 / Math.pow(10, sep)),
                (sepEastingString = mgrsString.substring(i, i + sep)),
                (sepEasting = parseFloat(sepEastingString) * accuracyBonus),
                (sepNorthingString = mgrsString.substring(i + sep)),
                (sepNorthing = parseFloat(sepNorthingString) * accuracyBonus)),
              {
                easting: (easting = sepEasting + east100k),
                northing: (northing = sepNorthing + north100k),
                zoneLetter: zoneLetter,
                zoneNumber: zoneNumber,
                accuracy: accuracyBonus,
              }
            );
          }
          function getEastingFromChar(e, set) {
            for (
              var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1),
                eastingValue = 1e5,
                rewindMarker = !1;
              curCol !== e.charCodeAt(0);

            ) {
              if (
                (++curCol === I && curCol++,
                curCol === O && curCol++,
                curCol > Z)
              ) {
                if (rewindMarker) throw "Bad character: " + e;
                (curCol = A), (rewindMarker = !0);
              }
              eastingValue += 1e5;
            }
            return eastingValue;
          }
          function getNorthingFromChar(n, set) {
            if (n > "V") throw "MGRSPoint given invalid Northing " + n;
            for (
              var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1),
                northingValue = 0,
                rewindMarker = !1;
              curRow !== n.charCodeAt(0);

            ) {
              if (
                (++curRow === I && curRow++,
                curRow === O && curRow++,
                curRow > V)
              ) {
                if (rewindMarker) throw "Bad character: " + n;
                (curRow = A), (rewindMarker = !0);
              }
              northingValue += 1e5;
            }
            return northingValue;
          }
          function getMinNorthing(zoneLetter) {
            var northing;
            switch (zoneLetter) {
              case "C":
                northing = 11e5;
                break;
              case "D":
                northing = 2e6;
                break;
              case "E":
                northing = 28e5;
                break;
              case "F":
                northing = 37e5;
                break;
              case "G":
                northing = 46e5;
                break;
              case "H":
                northing = 55e5;
                break;
              case "J":
                northing = 64e5;
                break;
              case "K":
                northing = 73e5;
                break;
              case "L":
                northing = 82e5;
                break;
              case "M":
                northing = 91e5;
                break;
              case "N":
                northing = 0;
                break;
              case "P":
                northing = 8e5;
                break;
              case "Q":
                northing = 17e5;
                break;
              case "R":
                northing = 26e5;
                break;
              case "S":
                northing = 35e5;
                break;
              case "T":
                northing = 44e5;
                break;
              case "U":
                northing = 53e5;
                break;
              case "V":
                northing = 62e5;
                break;
              case "W":
                northing = 7e6;
                break;
              case "X":
                northing = 79e5;
                break;
              default:
                northing = -1;
            }
            if (northing >= 0) return northing;
            throw "Invalid zone letter: " + zoneLetter;
          }
          (exports.forward = function (ll, accuracy) {
            return (
              (accuracy = accuracy || 5),
              encode(LLtoUTM({ lat: ll[1], lon: ll[0] }), accuracy)
            );
          }),
            (exports.inverse = function (mgrs) {
              var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
              return bbox.lat && bbox.lon
                ? [bbox.lon, bbox.lat, bbox.lon, bbox.lat]
                : [bbox.left, bbox.bottom, bbox.right, bbox.top];
            }),
            (exports.toPoint = function (mgrs) {
              var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
              return bbox.lat && bbox.lon
                ? [bbox.lon, bbox.lat]
                : [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
            });
        },
        {},
      ],
      132: [
        function (require, module, exports) {
          module.exports = {
            name: "proj4",
            version: "2.3.7",
            description:
              "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
            main: "lib/index.js",
            directories: { test: "test", doc: "docs" },
            scripts: {
              test: "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js",
            },
            repository: {
              type: "git",
              url: "git://github.com/proj4js/proj4js.git",
            },
            author: "",
            license: "MIT",
            jam: {
              main: "dist/proj4.js",
              include: ["dist/proj4.js", "README.md", "AUTHORS", "LICENSE.md"],
            },
            devDependencies: {
              "grunt-cli": "~0.1.13",
              grunt: "~0.4.2",
              "grunt-contrib-connect": "~0.6.0",
              "grunt-contrib-jshint": "~0.8.0",
              chai: "~1.8.1",
              mocha: "~1.17.1",
              "grunt-mocha-phantomjs": "~0.4.0",
              browserify: "~3.24.5",
              "grunt-browserify": "~1.3.0",
              "grunt-contrib-uglify": "~0.3.2",
              curl: "git://github.com/cujojs/curl.git",
              istanbul: "~0.2.4",
              tin: "~0.4.0",
            },
            dependencies: { mgrs: "~0.0.2" },
            contributors: [
              { name: "Mike Adair", email: "madair@dmsolutions.ca" },
              { name: "Richard Greenwood", email: "rich@greenwoodmap.com" },
              { name: "Calvin Metcalf", email: "calvin.metcalf@gmail.com" },
              { name: "Richard Marsden", url: "http://www.winwaed.com" },
              { name: "T. Mittan" },
              { name: "D. Steinwand" },
              { name: "S. Nelson" },
            ],
            gitHead: "52b3a4f6bf8b609251d06f1f7ddd29d7074f3ce4",
            bugs: { url: "https://github.com/proj4js/proj4js/issues" },
            homepage: "https://github.com/proj4js/proj4js#readme",
            _id: "proj4@2.3.7",
            _shasum: "248a30b2dc346dd1896dc5526c1a5e6b546f334a",
            _from: "proj4@>=2.1.0 <3.0.0",
            _npmVersion: "2.11.2",
            _nodeVersion: "0.12.5",
            _npmUser: { name: "ahocevar", email: "andreas.hocevar@gmail.com" },
            maintainers: [
              { name: "cwmma", email: "calvin.metcalf@gmail.com" },
              { name: "ahocevar", email: "andreas.hocevar@gmail.com" },
            ],
            dist: {
              shasum: "248a30b2dc346dd1896dc5526c1a5e6b546f334a",
              tarball: "http://registry.npmjs.org/proj4/-/proj4-2.3.7.tgz",
            },
            _resolved: "https://registry.npmjs.org/proj4/-/proj4-2.3.7.tgz",
          };
        },
        {},
      ],
      133: [
        function (require, module, exports) {
          (function (Buffer) {
            "use strict";
            var proj4 = require("proj4"),
              unzip = require("./unzip"),
              binaryAjax = require("./binaryajax"),
              parseShp = require("./parseShp"),
              toArrayBuffer = require("./toArrayBuffer"),
              parseDbf = require("parsedbf"),
              Promise = require("lie"),
              Cache,
              cache = new (require("lru-cache"))({ max: 20 });
            function shp(base, whiteList) {
              return "string" == typeof base && cache.has(base)
                ? Promise.resolve(cache.get(base))
                : shp.getShapefile(base, whiteList).then(function (resp) {
                    return (
                      "string" == typeof base && cache.set(base, resp), resp
                    );
                  });
            }
            function getZip(base, whiteList) {
              return binaryAjax(base).then(function (a) {
                return shp.parseZip(a, whiteList);
              });
            }
            (shp.combine = function (arr) {
              for (
                var out = { type: "FeatureCollection", features: [] },
                  i = 0,
                  len = arr[0].length;
                i < len;

              )
                out.features.push({
                  type: "Feature",
                  geometry: arr[0][i],
                  properties: arr[1][i],
                }),
                  i++;
              return out;
            }),
              (shp.parseZip = function (buffer, whiteList) {
                var key,
                  zip = unzip(buffer),
                  names = [];
                for (key in ((whiteList = whiteList || []), zip))
                  -1 === key.indexOf("__MACOSX") &&
                    ("shp" === key.slice(-3).toLowerCase()
                      ? names.push(key.slice(0, -4))
                      : "dbf" === key.slice(-3).toLowerCase()
                      ? (zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] =
                          parseDbf(zip[key]))
                      : "prj" === key.slice(-3).toLowerCase()
                      ? (zip[key.slice(0, -3) + key.slice(-3).toLowerCase()] =
                          proj4(zip[key]))
                      : ("json" === key.slice(-4).toLowerCase() ||
                          whiteList.indexOf(key.split(".").pop()) > -1) &&
                        names.push(
                          key.slice(0, -3) + key.slice(-3).toLowerCase()
                        ));
                if (!names.length) throw new Error("no layers founds");
                var geojson = names.map(function (name) {
                  var parsed;
                  return (
                    "json" === name.slice(-4).toLowerCase()
                      ? ((parsed = JSON.parse(zip[name])).fileName = name.slice(
                          0,
                          name.lastIndexOf(".")
                        ))
                      : whiteList.indexOf(
                          name.slice(name.lastIndexOf(".") + 1)
                        ) > -1
                      ? ((parsed = zip[name]).fileName = name)
                      : ((parsed = shp.combine([
                          parseShp(zip[name + ".shp"], zip[name + ".prj"]),
                          zip[name + ".dbf"],
                        ])).fileName = name),
                    parsed
                  );
                });
                return 1 === geojson.length ? geojson[0] : geojson;
              }),
              (shp.getShapefile = function (base, whiteList) {
                return "string" == typeof base
                  ? ".zip" === base.slice(-4)
                    ? getZip(base, whiteList)
                    : Promise.all([
                        Promise.all([
                          binaryAjax(base + ".shp"),
                          binaryAjax(base + ".prj"),
                        ]).then(function (args) {
                          return parseShp(args[0], !!args[1] && proj4(args[1]));
                        }),
                        binaryAjax(base + ".dbf").then(parseDbf),
                      ]).then(shp.combine)
                  : new Promise(function (resolve) {
                      resolve(shp.parseZip(base));
                    });
              }),
              (shp.parseShp = function (shp, prj) {
                return (
                  Buffer.isBuffer(shp) && (shp = toArrayBuffer(shp)),
                  Buffer.isBuffer(prj) && (prj = prj.toString()),
                  "string" == typeof prj
                    ? ((prj = proj4(prj)), parseShp(shp, prj))
                    : parseShp(shp)
                );
              }),
              (shp.parseDbf = function (dbf) {
                return (
                  Buffer.isBuffer(dbf) && (dbf = toArrayBuffer(dbf)),
                  parseDbf(dbf)
                );
              }),
              (module.exports = shp);
          }).call(this, require("buffer").Buffer);
        },
        {
          "./binaryajax": 1,
          "./parseShp": 2,
          "./toArrayBuffer": 3,
          "./unzip": 4,
          buffer: 5,
          lie: 51,
          "lru-cache": 62,
          parsedbf: 63,
          proj4: 100,
        },
      ],
    },
    {},
    [133]
  )(133);
});
