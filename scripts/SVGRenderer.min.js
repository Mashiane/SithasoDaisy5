class SVGRenderer extends HTMLElement {
  constructor() {
    super();
    this.eventListeners = new Map(); // Store event listeners for cleanup
  }

  // List of attributes to observe for changes
  static get observedAttributes() {
    return ["data-src", "width", "height", "fill", "background", "data-js", "style", "replace", "class"];
  }

  // Called when the element is inserted into the DOM
  async connectedCallback() {
    await this.loadSVG(); // Load SVG when the element is connected to the DOM
  }

  // Called when observed attributes change
  async attributeChangedCallback(t, e, s) {
    if (e !== s) { // Only proceed if the attribute value has changed
      if (t === "data-src") {
        await this.loadSVG(); // Reload the SVG if the source changes
      } else if (t === "data-js") {
        this.updateEventHandling(); // Update event listeners if JS interaction changes
      } else {
        // Reapply styles if any other attribute changes
        this.svgContent && this.applyStyles(this.svgContent);
      }
    }
  }

  // Load the SVG, either from cache or by fetching it
  async loadSVG() {
    const t = this.getAttribute("data-src");
    this.svgContent = null; // Reset the SVG content reference
    this.eventListeners.clear(); // Clear old event listeners
    if (t) {
      try {
        let e = localStorage.getItem(t); // Check localStorage for cached SVG

        if (!e) {
          const s = await fetch(t); // Fetch the SVG if not cached
          if (!s.ok) throw new Error("Failed to fetch SVG");
          e = await s.text(); // Get the SVG content
          localStorage.setItem(t, e); // Cache the SVG in localStorage
        }

        const s = document.createElement("div");
        s.innerHTML = e; // Convert the SVG string into DOM elements
        const n = s.querySelector("svg"); // Get the <svg> element from the content
        if (!n) throw new Error("Invalid SVG content");

        // Copy all attributes (except data-src) to the SVG element
        Array.from(this.attributes).forEach((t) => {
          if (t.name !== "data-src") n.setAttribute(t.name, t.value);
        });

        this.applyStyles(n); // Apply the necessary styles to the SVG
        if (!this.hasAttribute("replace")) {
            this.setAttribute("replace", "true");
        }
        this._replace = this.getAttribute("replace") === "true"; // Check if replace is enabled
        if (this._replace) {
          const parent = this.parentNode;
          if (parent) {
            parent.replaceChild(n, this);
          } else {
            console.warn("SVGRenderer: parentNode is null. Deferring replacement until connected to the DOM.");
            this.addEventListener("connected", () => {
              if (this.parentNode) {
                this.parentNode.replaceChild(n, this);
              }
            }, { once: true });
          }
        } else {
          this.innerHTML = "";
          this.appendChild(n); // Clear the inner HTML of the custom element
        }
        
        this.svgContent = n; // Save a reference to the SVG content

        // Enable JS interactivity if needed
        if (this.getAttribute("data-js") === "enabled") {
          this.updateEventHandling();
        }
      } catch (t) {
        console.error("Error loading SVG:", t);
        const e = document.createElement("div");
        e.style.color = "red";
        e.textContent = "Failed to load SVG"; // Show error if SVG loading fails
        this.replaceWith(e);
      }
    }
  }

  // Apply styles from attributes and style attribute to the SVG
  applyStyles(target) {
    const width = this.getAttribute("width"),
      height = this.getAttribute("height"),
      fill = this.getAttribute("fill"),
      background = this.getAttribute("background"),
      styleAttr = this.getAttribute("style"),
      classAttr = this.getAttribute("class");

    if (width) target.setAttribute("width", width); // Apply width
    if (height) target.setAttribute("height", height); // Apply height
    if (background) target.style.background = background; // Apply background
    if (classAttr) target.setAttribute("class", classAttr); // Apply class

    // Apply `fill` directly from attribute
    if (fill) {
      target.style.fill = fill; // Apply fill from attribute
      target.style.color = fill; // For SVGs using currentColor
      target.querySelectorAll("[fill]").forEach((el) => {
        el.setAttribute("fill", fill); // Apply fill to inner elements
      });
    }

    // Parse `style` attribute and apply to SVG
    if (styleAttr) {
      target.setAttribute("style", styleAttr); // Apply the style attribute

      // Extract color from the style string if specified
      const colorMatch = styleAttr.match(/color\s*:\s*([^;]+);?/i);
      if (colorMatch) {
        const styleColor = colorMatch[1].trim(); // Get the color value
        target.style.fill = styleColor; // Apply color to fill
        target.style.color = styleColor; // Apply color to currentColor
        target.querySelectorAll("[fill]").forEach((el) => {
          el.setAttribute("fill", styleColor); // Apply fill to inner elements
        });
      }
    }
  }

  // Set up or remove event listeners for interaction
  updateEventHandling() {
    if (!this.svgContent) return;

    // Remove old event listeners
    this.eventListeners.forEach((handler, event) => {
      this.svgContent.removeEventListener(event, handler);
    });
    this.eventListeners.clear();

    // Check if event handling is enabled
    const isEnabled = this.getAttribute("data-js") === "enabled";
    if (isEnabled) {
      const events = ["click", "mouseover", "mouseout", "mousedown", "mouseup"];
      events.forEach((event) => {
        const handler = (e) => {
          const customEvent = new CustomEvent(`svg-${event}`, {
            detail: { originalEvent: e, svgElement: this.svgContent },
            bubbles: true,
          });
          this.svgContent.dispatchEvent(customEvent); // Dispatch custom event
        };
        this.svgContent.addEventListener(event, handler);
        this.eventListeners.set(event, handler); // Store the handler for cleanup
      });

      this.svgContent.style.cursor = "pointer"; // Change cursor to pointer
    } else {
      this.svgContent.style.cursor = "default"; // Default cursor style
      this.svgContent.style.pointerEvents = "none"; // Disable pointer events
    }
  }

  // Utility methods for manipulating styles and classes
  addStyle(t, e) {
    if (this.svgContent) this.svgContent.style[t] = e; // Apply a single style
  }

  removeStyle(t) {
    if (this.svgContent) this.svgContent.style[t] = ""; // Remove a style
  }

  addClass(t) {
    if (this.svgContent) this.svgContent.classList.add(t); // Add a class
  }

  removeClass(t) {
    if (this.svgContent) this.svgContent.classList.remove(t); // Remove a class
  }

  toggleClass(t) {
    if (this.svgContent) this.svgContent.classList.toggle(t); // Toggle a class
  }
}

// Register the custom element with the browser
customElements.define("svg-renderer", SVGRenderer);